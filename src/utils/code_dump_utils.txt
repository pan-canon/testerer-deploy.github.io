// File: DeviceOrientationControls.js
/**
 * @author richt / http://richt.me
 * @author WestLangley / http://github.com/WestLangley
 *
 * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)
 */

THREE.DeviceOrientationControls = function( object ) {

	var scope = this;

	this.object = object;
	this.object.rotation.reorder( "YXZ" );

	this.enabled = true;

	this.deviceOrientation = {};
	this.screenOrientation = 0;

	this.alpha = 0;
	this.alphaOffsetAngle = 0;
	this.betaOffsetAngle = 0;
	this.gammaOffsetAngle = 0;


	var onDeviceOrientationChangeEvent = function( event ) {

		scope.deviceOrientation = event;

	};

	var onScreenOrientationChangeEvent = function() {

		scope.screenOrientation = window.orientation || 0;

	};

	// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

	var setObjectQuaternion = function() {

		var zee = new THREE.Vector3( 0, 0, 1 );

		var euler = new THREE.Euler();

		var q0 = new THREE.Quaternion();

		var q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis

		return function( quaternion, alpha, beta, gamma, orient ) {

			euler.set( beta, alpha, - gamma, 'YXZ' ); // 'ZXY' for the device, but 'YXZ' for us

			quaternion.setFromEuler( euler ); // orient the device

			quaternion.multiply( q1 ); // camera looks out the back of the device, not the top

			quaternion.multiply( q0.setFromAxisAngle( zee, - orient ) ); // adjust for screen orientation

		};

	}();

	this.connect = function() {

		onScreenOrientationChangeEvent(); // run once on load

		window.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );
		window.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );

		scope.enabled = true;

	};

	this.disconnect = function() {

		window.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );
		window.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );

		scope.enabled = false;

	};

	this.update = function() {

		if ( scope.enabled === false ) return;

		var alpha = scope.deviceOrientation.alpha ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) + this.alphaOffsetAngle : 0; // Z
		var beta = scope.deviceOrientation.beta ? THREE.Math.degToRad( scope.deviceOrientation.beta ) + this.betaOffsetAngle : 0; // X'
		var gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) + this.gammaOffsetAngle : 0; // Y''
		var orient = scope.screenOrientation ? THREE.Math.degToRad( scope.screenOrientation ) : 0; // O

		setObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );
		this.alpha = alpha;

	};

	this.updateAlphaOffsetAngle = function( angle ) {

		this.alphaOffsetAngle = angle;
		this.update();

	};

	this.updateBetaOffsetAngle = function( angle ) {

		this.betaOffsetAngle = angle;
		this.update();

	};

	this.updateGammaOffsetAngle = function( angle ) {

		this.gammaOffsetAngle = angle;
		this.update();

	};

	this.dispose = function() {

		this.disconnect();

	};

	this.connect();

};

// File: GameEntityLoader.js
/**
 * GameEntityLoader.js
 * 
 * Provides functions to load the game entities configuration (events, quests, and sequence)
 * from a unified JSON file and derive mappings for use in managers.
 */

/**
 * Loads the game entities configuration by fetching the JSON file.
 * Returns an object containing `events`, `quests`, and `sequence`.
 */
export async function loadGameEntitiesConfig() {
  const response = await fetch('./src/config/gameEntities.json');
  if (!response.ok) {
    throw new Error('Failed to load game entities configuration');
  }
  const config = await response.json();
  return config;
}

/**
 * Constructs a mapping from questKey to its parent eventKey based on the sequence.
 * 
 * Example return value:
 * {
 *   "mirror_quest": "welcome",
 *   "repeating_quest": "post_repeating_event",
 *   "final_quest": "final_event"
 * }
 * 
 * Usage:
 *   const questKeyToEventKey = await getQuestKeyToEventKeyMap();
 */
export async function getQuestKeyToEventKeyMap() {
  const config = await loadGameEntitiesConfig();
  const map = {};
  config.sequence.forEach(triad => {
    // triad: { eventKey, questKey, nextEventKey }
    map[triad.questKey] = triad.eventKey;
  });
  return map;
}

// File: ImageUtils.js
// ImageUtils.js
export class ImageUtils {
  /**
   * Converts the canvas image to grayscale and returns the data URL.
   * @param {HTMLCanvasElement} canvas 
   * @returns {string} Data URL with PNG format.
   */
  static convertToGrayscale(canvas) {
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;
    for (let i = 0; i < pixels.length; i += 4) {
      const avg = (pixels[i] + pixels[i+1] + pixels[i+2]) / 3;
      pixels[i] = avg;
      pixels[i+1] = avg;
      pixels[i+2] = avg;
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas.toDataURL("image/png");
  }

  /**
   * Performs pixel-wise comparison between two base64 images.
   * @param {string} img1 Base64 string of the first image.
   * @param {string} img2 Base64 string of the second image.
   * @returns {number} Matching coefficient between 0 and 1.
   */
  static pixelWiseComparison(img1, img2) {
    const decodeBase64 = img => atob(img.split(',')[1]);
    const image1 = decodeBase64(img1);
    const image2 = decodeBase64(img2);
    let matchCount = 0;
    const len = Math.min(image1.length, image2.length);
    for (let i = 0; i < len; i++) {
      if (Math.abs(image1.charCodeAt(i) - image2.charCodeAt(i)) < 100) {
        matchCount++;
      }
    }
    return matchCount / len;
  }

  /**
   * Performs histogram comparison between two base64 images.
   * @param {string} img1 Base64 string of the first image.
   * @param {string} img2 Base64 string of the second image.
   * @returns {number} Matching coefficient between 0 and 1.
   */
  static histogramComparison(img1, img2) {
    const hist1 = this.createHistogram(img1);
    const hist2 = this.createHistogram(img2);
    const diff = hist1.reduce((acc, val, i) => acc + Math.abs(val - hist2[i]), 0);
    const totalPixels = hist1.reduce((sum, val) => sum + val, 0);
    return 1 - (diff / (totalPixels * 1.2));
  }

  /**
   * Creates a histogram (256 levels) for a base64 image.
   * @param {string} img Base64 string of the image.
   * @returns {number[]} Array of length 256 with pixel counts.
   */
  static createHistogram(img) {
    const hist = new Array(256).fill(0);
    const imgData = atob(img.split(',')[1]);
    for (let i = 0; i < imgData.length; i++) {
      hist[imgData.charCodeAt(i)]++;
    }
    return hist;
  }

  /**
   * applyFilterToCanvas
   * Applies a filter effect to a canvas and returns a new data URL.
   * For example, for 'nightVision' the image brightness/contrast can be adjusted.
   * @param {HTMLCanvasElement} canvas
   * @param {string} filterType - 'nightVision', 'blackWhite', or ''.
   * @returns {string} Data URL of the processed image.
   */
  static applyFilterToCanvas(canvas, filterType) {
    const ctx = canvas.getContext("2d");
    // Save current state
    ctx.save();
    if (filterType === 'nightVision') {
      // Example: increase brightness and add a green tint
      ctx.filter = 'brightness(150%) contrast(120%) sepia(100%) hue-rotate(90deg)';
    } else if (filterType === 'blackWhite') {
      ctx.filter = 'grayscale(100%)';
    } else {
      ctx.filter = 'none';
    }
    // Redraw the current canvas content with the filter applied
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.putImageData(imageData, 0, 0);
    // Restore state and return new data URL
    ctx.restore();
    return canvas.toDataURL("image/png");
  }
}

// File: QuestControlUtils.js
/**
 * Determines whether a quest can be launched.
 * Checks if any quest is already active (via persistent flag) and, if a sequence manager is provided,
 * verifies that the provided questKey matches the expected quest.
 *
 * @param {string} questKey - The quest key to launch.
 * @param {function} isQuestActiveFn - Function returning true if a quest is active.
 * @param {object} [sequenceManager] - Optional SequenceManager instance.
 * @returns {boolean} True if the quest can be launched, false otherwise.
 */
export function canLaunchQuest(questKey, isQuestActiveFn, sequenceManager) {
  if (isQuestActiveFn()) {
    return false;
  }
  if (sequenceManager) {
    const currentEntry = sequenceManager.getCurrentEntry();
    if (currentEntry && currentEntry.questKey !== questKey) {
      return false;
    }
  }
  return true;
}

// File: SequenceManager.js
/**
 * SequenceManager.js
 * 
 * Provides methods to manage the eventâ€“quest sequence.
 *
 * @typedef {Object} SequenceEntry
 * @property {string} eventKey - The event key.
 * @property {string} questKey - The quest key that will be started after the event.
 * @property {string|null} nextEventKey - The key of the next event (or null if the sequence is complete).
 */

export class SequenceManager {
  /**
   * @param {SequenceEntry[]} sequenceList - The list of sequence entries.
   */
  constructor(sequenceList) {
    this.sequenceList = sequenceList;
    this.currentIndex = 0;
  }

  /**
   * Returns the current sequence entry.
   * @returns {SequenceEntry|null}
   */
  getCurrentEntry() {
    return (this.sequenceList && this.sequenceList[this.currentIndex]) || null;
  }

  /**
   * Checks if the provided quest key matches the expected quest in the current sequence entry.
   * @param {string} questKey 
   * @returns {boolean}
   */
  isNextQuest(questKey) {
    const entry = this.getCurrentEntry();
    return entry ? entry.questKey === questKey : false;
  }

  /**
   * Checks if the provided event key matches the expected event in the current sequence entry.
   * @param {string} eventKey 
   * @returns {boolean}
   */
  isNextEvent(eventKey) {
    const entry = this.getCurrentEntry();
    return entry ? entry.eventKey === eventKey : false;
  }

  /**
   * Increments the sequence index if not at the end.
   */
  increment() {
    if (this.currentIndex < this.sequenceList.length - 1) {
      this.currentIndex++;
    }
  }

  /**
   * Resets the sequence index to the beginning.
   */
  reset() {
    this.currentIndex = 0;
  }
}

// File: SpiritBoardUtils.js
/**
 * SpiritBoardUtils.js
 *
 * This module provides utility functions for visual effects on the spirit board.
 * It includes functions to animate text by sequentially revealing letters.
 */

/**
 * animateText
 * Sequentially animates each letter of the given text within the provided HTML element.
 * It splits the text into individual letters, wraps each in a span, and applies a fade-in effect.
 *
 * @param {HTMLElement} element - The target element where the text animation will occur.
 * @param {string} text - The text to be animated.
 */
export function animateText(element, text) {
  // Clear the current content of the element
  element.innerHTML = '';

  // Split the text into individual letters
  const letters = text.split('');

  // Create a span for each letter and animate its appearance
  letters.forEach((letter, index) => {
    const span = document.createElement('span');
    span.innerText = letter;
    // Set initial opacity to 0 for the animation effect
    span.style.opacity = '0';
    span.style.transition = 'opacity 0.3s ease-in';
    element.appendChild(span);

    // Reveal each letter sequentially with a delay (e.g., 100ms between letters)
    setTimeout(() => {
      span.style.opacity = '1';
    }, index * 100);
  });
}

// File: TemplateEngine.js
/**
 * TemplateEngine.js
 *
 * A simple template engine for dynamic HTML rendering.
 * It replaces placeholders in the template string with values from a data object.
 *
 * Placeholders are defined using double curly braces, e.g., {{ variableName }}.
 *
 * Example usage:
 *   const template = "<h1>{{ title }}</h1><p>{{ content }}</p>";
 *   const data = { title: "Hello", content: "World" };
 *   const renderedHTML = TemplateEngine.render(template, data);
 *   // renderedHTML: "<h1>Hello</h1><p>World</p>"
 */
export class TemplateEngine {
  /**
   * Renders an HTML template using the provided data.
   *
   * @param {string} template - The template string containing placeholders.
   * @param {Object} data - The data object with keys corresponding to placeholder names.
   * @returns {string} - The rendered HTML string with placeholders replaced by data values.
   */
  static render(template, data) {
    return template.replace(/{{\s*([\s\S]+?)\s*}}/g, (match, key) => {
      const trimmedKey = key.trim();
      return data.hasOwnProperty(trimmedKey) ? data[trimmedKey] : match;
    });
  }

  /**
   * Loads an HTML template from `templatePath` with `fetch`, then renders it with the data.
   * @param {string} templatePath â€“ relative / absolute URL to the HTML file.
   * @param {Object} [data={}] â€“ placeholder values.
   */
  static async renderFile(templatePath, data = {}) {
    const response = await fetch(templatePath);
    if (!response.ok) {
      throw new Error(`[TemplateEngine] Failed to load template: ${templatePath}`);
    }
    const templateText = await response.text();
    return TemplateEngine.render(templateText, data);
  }
}
