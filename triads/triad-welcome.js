"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunktesterer_deploy_github_io"] = self["webpackChunktesterer_deploy_github_io"] || []).push([["triads/triad-welcome"],{

/***/ "./build/triads/triad-welcome.js":
/*!***************************************!*\
  !*** ./build/triads/triad-welcome.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMirrorQuest: () => (/* reexport safe */ quests_BaseMirrorQuest_js__WEBPACK_IMPORTED_MODULE_1__.BaseMirrorQuest),\n/* harmony export */   PostMirrorEvent: () => (/* reexport safe */ events_PostMirrorEvent_js__WEBPACK_IMPORTED_MODULE_2__.PostMirrorEvent),\n/* harmony export */   WelcomeEvent: () => (/* reexport safe */ events_WelcomeEvent_js__WEBPACK_IMPORTED_MODULE_0__.WelcomeEvent)\n/* harmony export */ });\n/* harmony import */ var events_WelcomeEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events/WelcomeEvent.js */ \"./src/events/WelcomeEvent.js\");\n/* harmony import */ var quests_BaseMirrorQuest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! quests/BaseMirrorQuest.js */ \"./src/quests/BaseMirrorQuest.js\");\n/* harmony import */ var events_PostMirrorEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events/PostMirrorEvent.js */ \"./src/events/PostMirrorEvent.js\");\n\n\n\n\n\n//# sourceURL=webpack://testerer-deploy.github.io/./build/triads/triad-welcome.js?");

/***/ }),

/***/ "./src/events/BaseEvent.js":
/*!*********************************!*\
  !*** ./src/events/BaseEvent.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseEvent: () => (/* binding */ BaseEvent)\n/* harmony export */ });\n/* harmony import */ var _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n\n\n/**\n * BaseEvent - Base class for events, providing common functionality\n * for activation and logging in the diary.\n * This class is used in an Observer Pattern where each event notifies\n * subscribed components (e.g., diary UI) about changes.\n */\nclass BaseEvent {\n  /**\n   * Constructor for the BaseEvent.\n   * @param {EventManager} eventManager - Instance of the event manager responsible for diary operations.\n   *\n   * @property {string} key - Unique identifier for the event, which should be set by subclasses.\n   */\n  constructor(eventManager) {\n    /** @type {EventManager} */\n    this.eventManager = eventManager;\n    // Event key; should be overridden in subclasses.\n    this.key = \"\";\n  }\n\n  /**\n   * activate - Activates the event.\n   * If an event with the given key has not been logged yet, the event is logged via the eventManager.\n   * This method handles logging and notification without triggering subsequent actions.\n   *\n   * NOTE: No direct UI manipulations should be placed here — any UI updates\n   *       (e.g. enabling/disabling buttons) happen in specialized managers.\n   *\n   * @returns {Promise<void>} Asynchronous execution.\n   */\n  async activate() {\n    try {\n      // Check if the event with this key has not been logged yet.\n      if (!this.eventManager.isEventLogged(this.key)) {\n        console.log(`Activating event: ${this.key}`);\n        // Log the event in the diary (as a user post, without ghost flag).\n        await this.eventManager.addDiaryEntry(this.key);\n      }\n    } catch (error) {\n      // Delegate error logging and user notification.\n      _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(error, \"BaseEvent.activate\");\n      _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.showError(\"An error occurred during event activation.\");\n    }\n  }\n\n  /**\n   * addDiaryEntry - Convenience method to add a diary entry.\n   * Delegates the addition to the eventManager.\n   *\n   * @param {string} text - The text of the entry to be added to the diary.\n   * @param {boolean} [isGhostPost=false] - Flag indicating if this is a ghost post.\n   * @returns {Promise<void>} Asynchronous execution.\n   */\n  async addDiaryEntry(text, isGhostPost = false) {\n    try {\n      await this.eventManager.addDiaryEntry(text, isGhostPost);\n    } catch (error) {\n      _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(error, \"BaseEvent.addDiaryEntry\");\n      _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.showError(\"An error occurred while adding a diary entry.\");\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/events/BaseEvent.js?");

/***/ }),

/***/ "./src/events/PostMirrorEvent.js":
/*!***************************************!*\
  !*** ./src/events/PostMirrorEvent.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostMirrorEvent: () => (/* binding */ PostMirrorEvent)\n/* harmony export */ });\n/* harmony import */ var _BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseEvent.js */ \"./src/events/BaseEvent.js\");\n/* harmony import */ var _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../managers/StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../managers/ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n// File: src/events/PostMirrorEvent.js\n\n\n\n\n\n/**\n * PostMirrorEvent\n * \n * This event publishes a ghost post and signals that the mirror quest cycle has ended.\n * It updates the UI via ViewManager without directly setting quest-specific flags.\n *\n * NOTE: This event is part of the sequential chain managed by GhostManager.\n * It only performs its task and then dispatches a \"gameEventCompleted\" event.\n */\nclass PostMirrorEvent extends _BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__.BaseEvent {\n  /**\n   * @param {EventManager} eventManager - Manager handling diary operations.\n   * @param {App} appInstance - Reference to the main application instance.\n   * @param {Object} config - Configuration object from gameEntities.json, contains `key`.\n   * @param {LanguageManager} [languageManager] - (unused here, but kept for signature consistency)\n   */\n  constructor(eventManager, appInstance, config, languageManager) {\n    super(eventManager);\n    this.app = appInstance;\n    this.key = config.key;\n  }\n  async activate() {\n    if (this.eventManager.isEventLogged(this.key)) {\n      console.log(`[PostMirrorEvent] Event '${this.key}' is already logged, skipping activation.`);\n      return;\n    }\n    console.log(`[PostMirrorEvent] Activating event '${this.key}'.`);\n    await this.addDiaryEntry(this.key, true);\n\n    // Instead of directly setting mirrorQuestReady or isRepeatingCycle,\n    // signal that the mirror quest cycle has completed by enabling the Post button \n    // and triggering the mirror effect. The universal active quest state is managed elsewhere.\n    if (this.app.viewManager && typeof this.app.viewManager.setPostButtonEnabled === \"function\") {\n      this.app.viewManager.setPostButtonEnabled(true);\n    }\n    if (this.app.visualEffectsManager && typeof this.app.visualEffectsManager.triggerMirrorEffect === \"function\") {\n      this.app.visualEffectsManager.triggerMirrorEffect();\n    }\n    console.log(\"[PostMirrorEvent] Mirror quest cycle ended; waiting for user action to trigger the next quest.\");\n\n    // Dispatch an event to signal that this event has completed.\n    document.dispatchEvent(new CustomEvent(\"gameEventCompleted\", {\n      detail: this.key\n    }));\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/events/PostMirrorEvent.js?");

/***/ }),

/***/ "./src/events/WelcomeEvent.js":
/*!************************************!*\
  !*** ./src/events/WelcomeEvent.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WelcomeEvent: () => (/* binding */ WelcomeEvent)\n/* harmony export */ });\n/* harmony import */ var _BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseEvent.js */ \"./src/events/BaseEvent.js\");\n/* harmony import */ var _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../managers/StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../managers/ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n// File: src/events/WelcomeEvent.js\n\n\n\n\n\n/**\n * WelcomeEvent\n * \n * This event is triggered immediately after registration. It logs a welcome message\n * (invitation to approach the mirror) in the diary and enables the \"Post\" button.\n * It uses StateManager to check and update the \"welcomeDone\" flag so that the event\n * is launched only once per registration cycle.\n *\n * NOTE: This event is part of the sequential chain managed by GhostManager.\n * It only performs its task (publishing a ghost post and setting flags) and then\n * dispatches a \"gameEventCompleted\" event.\n */\nclass WelcomeEvent extends _BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__.BaseEvent {\n  /**\n   * @param {EventManager} eventManager - Manager handling diary operations.\n   * @param {App} appInstance - Reference to the main application instance.\n   * @param {Object} config - Configuration object from gameEntities.json, contains `key`.\n   * @param {LanguageManager} [languageManager] - Optional localization manager.\n   */\n  constructor(eventManager, appInstance, config, languageManager) {\n    super(eventManager);\n    this.app = appInstance;\n    this.languageManager = languageManager;\n    this.key = config.key;\n  }\n  async activate() {\n    // If the welcome event has already been completed, skip activation.\n    if (_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.get(_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.WELCOME_DONE) === \"true\") {\n      console.log(`Welcome event '${this.key}' already completed; skipping activation.`);\n      if (this.app.viewManager && typeof this.app.viewManager.setPostButtonEnabled === \"function\") {\n        this.app.viewManager.setPostButtonEnabled(true);\n      }\n      return;\n    }\n\n    // If the event is already logged, check the universal active quest key for enabling the Post button.\n    if (this.eventManager.isEventLogged(this.key)) {\n      console.log(`Event '${this.key}' is already logged.`);\n      if (_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.get(_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.ACTIVE_QUEST_KEY) === \"mirror_quest\") {\n        if (this.app.viewManager && typeof this.app.viewManager.setPostButtonEnabled === \"function\") {\n          this.app.viewManager.setPostButtonEnabled(true);\n          console.log(\"Post button enabled based on activeQuestKey 'mirror_quest'.\");\n        }\n      } else {\n        if (this.app.viewManager && typeof this.app.viewManager.setPostButtonEnabled === \"function\") {\n          this.app.viewManager.setPostButtonEnabled(false);\n          console.log(\"Post button remains disabled as activeQuestKey is not set to 'mirror_quest'.\");\n        }\n      }\n      return;\n    }\n\n    // Log the event as a ghost post via the unified method.\n    console.log(`Activating event '${this.key}': Logging invitation to approach the mirror`);\n    await this.addDiaryEntry(this.key, true);\n\n    // Instead of setting \"mirrorQuestReady\", update the universal active quest key.\n    if (this.app.viewManager && typeof this.app.viewManager.setPostButtonEnabled === \"function\") {\n      this.app.viewManager.setPostButtonEnabled(true);\n    }\n\n    // Trigger the mirror effect if available.\n    if (this.app.visualEffectsManager && typeof this.app.visualEffectsManager.triggerMirrorEffect === \"function\") {\n      this.app.visualEffectsManager.triggerMirrorEffect();\n    }\n\n    // Mark the welcome event as completed.\n    _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.WELCOME_DONE, \"true\");\n\n    // Dispatch an event to signal that the welcome event has completed.\n    document.dispatchEvent(new CustomEvent(\"gameEventCompleted\", {\n      detail: this.key\n    }));\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/events/WelcomeEvent.js?");

/***/ }),

/***/ "./src/quests/BaseMirrorQuest.js":
/*!***************************************!*\
  !*** ./src/quests/BaseMirrorQuest.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMirrorQuest: () => (/* binding */ BaseMirrorQuest)\n/* harmony export */ });\n/* harmony import */ var _events_BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/BaseEvent.js */ \"./src/events/BaseEvent.js\");\n/* harmony import */ var _utils_ImageUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ImageUtils.js */ \"./src/utils/ImageUtils.js\");\n/* harmony import */ var _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../managers/StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../managers/ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n\n\n\n\n\n/**\n * BaseMirrorQuest – Base class for the mirror quest.\n * Encapsulates the logic for comparing the current frame (canvas → grayscale → compare),\n * managing the check loop, and delegating UI updates to the ViewManager.\n */\nclass BaseMirrorQuest extends _events_BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__.BaseEvent {\n  constructor(eventManager, appInstance, config = {}) {\n    super(eventManager);\n    this.app = appInstance;\n    this.key = config.key || \"mirror_quest\"; // Allows overriding the key.\n    this.doneKey = config.doneKey || \"mirror_done\";\n\n    // UI configuration (identifiers used by ViewManager)\n    this.statusElementId = config.statusElementId || \"mirror-quest-status\";\n    this.shootButtonId = config.shootButtonId || \"btn_shoot\";\n    this.checkInterval = null; // For startCheckLoop\n    this.finished = false;\n\n    // Canvas for frame comparison\n    this.tempCanvas = document.createElement(\"canvas\");\n    this.tempCtx = this.tempCanvas.getContext(\"2d\");\n    this.registerEvents();\n  }\n\n  /**\n   * registerEvents\n   * If the universal active quest key matches this quest's key,\n   * starts the check loop when the camera becomes ready.\n   */\n  registerEvents() {\n    document.addEventListener('cameraReady', () => {\n      // Instead of checking a specific flag, check the universal \"activeQuestKey\"\n      if (_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.getActiveQuestKey() === this.key) {\n        this.startCheckLoop();\n      }\n    });\n  }\n\n  /**\n   * activate\n   * Activates the mirror quest if it is not yet logged and creates an \"active\" quest record in the database.\n   * Note: The universal active quest key is set by the GhostManager/QuestManager.\n   */\n  async activate() {\n    if (!this.eventManager.isEventLogged(this.key)) {\n      console.log(`Activating event: ${this.key}`);\n      // Use the unified diary entry method from BaseEvent.\n      await this.addDiaryEntry(this.key);\n    }\n    console.log(\"[BaseMirrorQuest] Mirror quest activated.\");\n    // Save quest record as active.\n    await this.app.databaseManager.saveQuestRecord({\n      quest_key: this.key,\n      status: \"active\",\n      current_stage: 1,\n      total_stages: 1\n    });\n  }\n\n  /**\n   * startCheckLoop\n   * Displays the mirror quest UI (via ViewManager) and starts a loop that checks \n   * \"compareFrameInternally\" every 2 seconds.\n   */\n  startCheckLoop() {\n    if (this.checkInterval) return; // Already running.\n\n    if (this.app.viewManager && typeof this.app.viewManager.startMirrorQuestUI === 'function') {\n      this.app.viewManager.startMirrorQuestUI({\n        statusElementId: this.statusElementId,\n        shootButtonId: this.shootButtonId,\n        onShoot: () => this.finish() // When user clicks the shoot button, finish the quest.\n      });\n    }\n    this.checkInterval = setInterval(async () => {\n      if (!this.app.isCameraOpen) {\n        console.warn(\"[BaseMirrorQuest] Camera is not active - stopping check loop.\");\n        this.stopCheckLoop();\n        return;\n      }\n      const success = await this.checkStatus();\n      if (this.app.viewManager && typeof this.app.viewManager.updateMirrorQuestStatus === 'function') {\n        this.app.viewManager.updateMirrorQuestStatus(success, this.statusElementId, this.shootButtonId);\n      }\n    }, 2000);\n  }\n\n  /**\n   * stopCheckLoop\n   * Clears the interval and hides the quest UI via ViewManager.\n   */\n  stopCheckLoop() {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n    if (this.app.viewManager && typeof this.app.viewManager.stopMirrorQuestUI === 'function') {\n      this.app.viewManager.stopMirrorQuestUI(this.statusElementId);\n    }\n  }\n\n  /**\n   * checkStatus\n   * Uses compareFrameInternally to decide if the user is \"in front of the mirror.\"\n   */\n  async checkStatus() {\n    console.log(\"[BaseMirrorQuest] checkStatus() -> compareFrameInternally()\");\n    return await this.compareFrameInternally();\n  }\n\n  /**\n   * compareFrameInternally\n   * Captures the current camera frame, converts it to grayscale, compares it to the saved selfieData,\n   * and returns a boolean indicating success or failure.\n   */\n  async compareFrameInternally() {\n    if (!this.app.isCameraOpen) {\n      console.warn(\"[BaseMirrorQuest] Camera is not active (app.isCameraOpen false)\");\n      return false;\n    }\n    if (!this.app.selfieData) {\n      console.warn(\"[BaseMirrorQuest] No saved selfie (app.selfieData)\");\n      return false;\n    }\n    const videoEl = this.app.cameraSectionManager?.videoElement;\n    if (!videoEl || !videoEl.srcObject) {\n      console.warn(\"[BaseMirrorQuest] Camera is not active!\");\n      return false;\n    }\n    this.tempCanvas.width = videoEl.videoWidth || 640;\n    this.tempCanvas.height = videoEl.videoHeight || 480;\n    this.tempCtx.drawImage(videoEl, 0, 0, this.tempCanvas.width, this.tempCanvas.height);\n    const currentFrameData = _utils_ImageUtils_js__WEBPACK_IMPORTED_MODULE_1__.ImageUtils.convertToGrayscale(this.tempCanvas);\n    const matchPixel = _utils_ImageUtils_js__WEBPACK_IMPORTED_MODULE_1__.ImageUtils.pixelWiseComparison(this.app.selfieData, currentFrameData);\n    const matchHist = _utils_ImageUtils_js__WEBPACK_IMPORTED_MODULE_1__.ImageUtils.histogramComparison(this.app.selfieData, currentFrameData);\n    console.log(`[BaseMirrorQuest] pixel=${matchPixel.toFixed(2)}, hist=${matchHist.toFixed(2)}`);\n    const success = matchPixel > 0.6 && matchHist > 0.7;\n    if (success) {\n      this.app.lastMirrorPhoto = currentFrameData;\n    }\n    return success;\n  }\n\n  /**\n   * updateUIAfterFinish\n   * Calls a custom \"updateMirrorQuestUIAfterFinish\" method in ViewManager (if available)\n   * to update UI elements after quest completion.\n   *\n   * @param {boolean} success - Indicates whether the final check was successful.\n   */\n  updateUIAfterFinish(success) {\n    if (this.app.viewManager && typeof this.app.viewManager.updateMirrorQuestUIAfterFinish === 'function') {\n      this.app.viewManager.updateMirrorQuestUIAfterFinish(success, {\n        statusElementId: this.statusElementId,\n        shootButtonId: this.shootButtonId,\n        cameraButtonId: \"toggle-camera\"\n      });\n    }\n  }\n\n  /**\n   * finish\n   * Finalizes the mirror quest:\n   * - Stops the check loop.\n   * - Performs a final status check.\n   * - Logs a diary entry indicating success or failure.\n   * - Updates the UI (e.g., disables camera highlights, resets buttons).\n   * - Clears the quest-specific state.\n   * - Marks the quest as finished in the database.\n   * - Does NOT automatically trigger the next quest or event.\n   * - Dispatches a \"questCompleted\" event to signal completion to GhostManager.\n   */\n  async finish() {\n    if (this.finished) return;\n    this.finished = true;\n    this.stopCheckLoop(); // Stop the quest UI check loop.\n\n    const success = await this.checkStatus();\n    const ghost = this.app.ghostManager.getCurrentGhost();\n    const randomLetter = ghost ? this.getRandomLetter(ghost.name) : \"\";\n    if (success) {\n      const photoData = this.app.lastMirrorPhoto ? ` [photo attached]\\n${this.app.lastMirrorPhoto}` : \"\";\n      // Use the unified method for adding a diary entry.\n      await this.addDiaryEntry(`user_post_success: ${randomLetter}${photoData}`, false);\n    } else {\n      await this.addDiaryEntry(`user_post_failed: ${randomLetter}`, false);\n    }\n\n    // Update the UI after finishing the quest.\n    this.updateUIAfterFinish(success);\n\n    // Reset the \"Open Camera\" button if necessary.\n    if (this.app.viewManager && typeof this.app.viewManager.setCameraButtonActive === 'function') {\n      this.app.viewManager.setCameraButtonActive(false);\n    }\n\n    // Mark the quest as finished in the database.\n    await this.app.databaseManager.saveQuestRecord({\n      quest_key: this.key,\n      status: \"finished\",\n      current_stage: 1,\n      total_stages: 1\n    });\n\n    // Synchronize the quest state so that the \"Post\" button updates.\n    await this.app.questManager.syncQuestState();\n\n    // Dispatch a custom event to signal that the quest has been completed.\n    document.dispatchEvent(new CustomEvent(\"questCompleted\", {\n      detail: this.key\n    }));\n  }\n\n  /**\n   * getCurrentQuestStatus\n   * Retrieves the quest state from the database along with local flags.\n   * Now, instead of checking \"mirrorQuestActive\", it checks if the universal active quest key\n   * matches this quest's key.\n   * @returns {Promise<Object>} An object containing quest status information.\n   */\n  async getCurrentQuestStatus() {\n    const record = this.app.databaseManager.getQuestRecord(this.key);\n    const activeFlag = _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.getActiveQuestKey() === this.key;\n    return {\n      key: this.key,\n      active: activeFlag,\n      finished: this.finished,\n      dbStatus: record ? record.status : \"not recorded\"\n    };\n  }\n\n  /**\n   * getRandomLetter\n   * Utility function: returns a random letter from the ghost's name.\n   * @param {string} name - The ghost's name.\n   * @returns {string} A random letter from the name.\n   */\n  getRandomLetter(name) {\n    if (!name) return \"\";\n    const letters = name.replace(/[^A-Za-zА-Яа-яЁё]/g, '').split('');\n    if (!letters.length) return '';\n    return letters[Math.floor(Math.random() * letters.length)];\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/quests/BaseMirrorQuest.js?");

/***/ })

}]);