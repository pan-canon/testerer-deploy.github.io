"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunktesterer_deploy_github_io"] = self["webpackChunktesterer_deploy_github_io"] || []).push([["src_managers_ChatScenarioManager_js"],{

/***/ "./src/managers/ChatScenarioManager.js":
/*!*********************************************!*\
  !*** ./src/managers/ChatScenarioManager.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatScenarioManager: () => (/* binding */ ChatScenarioManager)\n/* harmony export */ });\n/* harmony import */ var _config_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/paths.js */ \"./src/config/paths.js\");\n/* harmony import */ var _StateManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateManager.js */ \"./src/managers/StateManager.js\");\n\n\nclass ChatScenarioManager {\n  /**\n   * ChatScenarioManager is responsible for managing the dialogue flow of the chat.\n   * It loads dialogue stages from a configuration file and advances the conversation\n   * based on user selections. All dialogue texts (both messages and options) are expected\n   * to be localization keys, which are converted to localized strings by ChatManager.\n   *\n   * With the new conversation independence functionality, the dialogue state can be reset\n   * independently via ChatManager's restartConversation() method.\n   *\n   * @param {ChatManager} chatManager - An instance of ChatManager that handles the chat UI.\n   * @param {Object} scenarioConfig - A JSON object representing the chat scenario.\n   * Expected format:\n   * {\n   *   \"dialogues\": [\n   *     {\n   *       \"messages\": [\n   *         { \"sender\": \"spirit\", \"text\": \"chat_welcome_message\", \"animateOnBoard\": true }\n   *       ],\n   *       \"options\": [\n   *         { \"text\": \"chat_option_1\", \"nextDialogueIndex\": 1 },\n   *         { \"text\": \"chat_option_2\", \"nextDialogueIndex\": 2 },\n   *         { \"text\": \"chat_option_3\", \"nextDialogueIndex\": 3 }\n   *       ]\n   *     },\n   *     ...\n   *   ]\n   * }\n   */\n  constructor(chatManager, scenarioConfig = null) {\n    this.chatManager = chatManager;\n    this.scenarioConfig = scenarioConfig; // Scenario configuration data\n    this.currentDialogueIndex = 0;\n    // Optional callback when the scenario ends.\n    this.onScenarioEnd = null;\n  }\n\n  /**\n   * Asynchronously initializes the scenario manager.\n   * If no configuration is provided, it fetches the dialogue configuration from\n   * 'src/config/chatDialogueConfig.json'. This method also restores any saved dialogue\n   * state unless the conversation has been marked as completed.\n   * Previously, if chat messages were already present in the database, dialogue initialization\n   * was skipped, which caused the dialogue options to disappear after a page reload.\n   * This behavior has been corrected: the dialogue state (including options) is restored regardless\n   * of existing messages, provided the conversation is not completed.\n   */\n  async init() {\n    if (!this.scenarioConfig) {\n      try {\n        const response = await fetch(`${_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.BASE_PATH}/src/config/chatDialogueConfig.json`);\n        if (!response.ok) {\n          throw new Error(\"Failed to load dialogue configuration from 'src/config/chatDialogueConfig.json'\");\n        }\n        this.scenarioConfig = await response.json();\n      } catch (error) {\n        console.error(\"Error loading dialogue configuration:\", error);\n        return;\n      }\n    }\n    // Check if the conversation is already completed for this section.\n    if (_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.get(this.chatManager.getStateKey('chat_conversation_completed')) === 'true') {\n      console.log(\"Chat conversation already completed, skipping dialogue initialization.\");\n      return;\n    }\n    // Removed check for existing chat messages to ensure dialogue options are always restored.\n    // Restore the current dialogue index if available; default to 0.\n    const savedIndex = _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.get(this.chatManager.getStateKey('chat_currentDialogueIndex'));\n    this.currentDialogueIndex = savedIndex !== null ? parseInt(savedIndex, 10) : 0;\n    this.loadCurrentDialogue();\n  }\n\n  /**\n   * Loads the current dialogue configuration and passes the dialogue to ChatManager to render.\n   * The dialogue texts (messages and options) are expected to be localization keys,\n   * and ChatManager will convert them into localized strings.\n   */\n  loadCurrentDialogue() {\n    if (!this.scenarioConfig || !this.scenarioConfig.dialogues) {\n      console.error(\"Scenario configuration is missing or invalid.\");\n      return;\n    }\n    const dialogue = this.scenarioConfig.dialogues[this.currentDialogueIndex];\n    if (!dialogue) {\n      console.warn(\"No dialogue found at the current index.\");\n      return;\n    }\n    // Render the dialogue. Message saving is handled in ChatManager.loadDialogue().\n    this.chatManager.loadDialogue(dialogue);\n  }\n\n  /**\n   * Advances the dialogue based on the user's selected option.\n   *\n   * If the selected option defines a nextDialogueIndex, the conversation advances accordingly.\n   * Otherwise, the conversation is marked as completed and the saved dialogue index is removed.\n   *\n   * @param {number} optionIndex - The index of the chosen option.\n   */\n  advanceDialogue(optionIndex) {\n    const currentDialogue = this.scenarioConfig.dialogues[this.currentDialogueIndex];\n    if (!currentDialogue || !Array.isArray(currentDialogue.options) || currentDialogue.options.length <= optionIndex) {\n      console.error(\"Invalid option index.\");\n      return;\n    }\n    const selectedOption = currentDialogue.options[optionIndex];\n    if (selectedOption && typeof selectedOption.onSelect === \"function\") {\n      selectedOption.onSelect();\n    }\n    if (selectedOption && typeof selectedOption.nextDialogueIndex === \"number\") {\n      this.currentDialogueIndex = selectedOption.nextDialogueIndex;\n      // Persist the updated dialogue index for this section.\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(this.chatManager.getStateKey('chat_currentDialogueIndex'), this.currentDialogueIndex);\n      this.loadCurrentDialogue();\n    } else {\n      console.log(\"No next dialogue defined; scenario may have ended.\");\n      // Mark conversation as completed and remove the saved dialogue index for this section.\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(this.chatManager.getStateKey('chat_conversation_completed'), 'true');\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.remove(this.chatManager.getStateKey('chat_currentDialogueIndex'));\n      // Remove the 'chat_started' flag so that conversation is not auto-resumed on reload.\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.remove(this.chatManager.getStateKey('chat_started'));\n      if (typeof this.onScenarioEnd === \"function\") {\n        this.onScenarioEnd();\n      }\n    }\n  }\n\n  /**\n   * Sets a new scenario configuration and resets the dialogue index.\n   * This facilitates conversation independence by allowing a fresh dialogue session.\n   *\n   * @param {Object} scenarioConfig - The new scenario configuration.\n   */\n  setScenario(scenarioConfig) {\n    this.scenarioConfig = scenarioConfig;\n    this.currentDialogueIndex = 0;\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(this.chatManager.getStateKey('chat_currentDialogueIndex'), this.currentDialogueIndex);\n    this.loadCurrentDialogue();\n  }\n\n  /**\n   * Registers a callback function to be executed when the dialogue scenario ends.\n   *\n   * @param {Function} callback - The callback function.\n   */\n  setOnScenarioEnd(callback) {\n    if (typeof callback === \"function\") {\n      this.onScenarioEnd = callback;\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/ChatScenarioManager.js?");

/***/ })

}]);