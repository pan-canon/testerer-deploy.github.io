"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunktesterer_deploy_github_io"] = self["webpackChunktesterer_deploy_github_io"] || []).push([["triads/triad-post_repeating_event"],{

/***/ "./build/triads/triad-post_repeating_event.js":
/*!****************************************************!*\
  !*** ./build/triads/triad-post_repeating_event.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseRepeatingQuest: () => (/* reexport safe */ quests_BaseRepeatingQuest_js__WEBPACK_IMPORTED_MODULE_1__.BaseRepeatingQuest),\n/* harmony export */   FinalEvent: () => (/* reexport safe */ events_FinalEvent_js__WEBPACK_IMPORTED_MODULE_2__.FinalEvent),\n/* harmony export */   PostRepeatingEvent: () => (/* reexport safe */ events_PostRepeatingEvent_js__WEBPACK_IMPORTED_MODULE_0__.PostRepeatingEvent)\n/* harmony export */ });\n/* harmony import */ var events_PostRepeatingEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events/PostRepeatingEvent.js */ \"./src/events/PostRepeatingEvent.js\");\n/* harmony import */ var quests_BaseRepeatingQuest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! quests/BaseRepeatingQuest.js */ \"./src/quests/BaseRepeatingQuest.js\");\n/* harmony import */ var events_FinalEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events/FinalEvent.js */ \"./src/events/FinalEvent.js\");\n\n\n\n\n\n//# sourceURL=webpack://testerer-deploy.github.io/./build/triads/triad-post_repeating_event.js?");

/***/ }),

/***/ "./src/config/detectableItems.js":
/*!***************************************!*\
  !*** ./src/config/detectableItems.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectableItems: () => (/* binding */ detectableItems)\n/* harmony export */ });\n// src/config/detectableItems.js\n// List of household items for repeating quest detection\nconst detectableItems = ['toilet', 'clock', 'lamp', 'chair', 'table', 'couch', 'bed', 'refrigerator', 'book', 'cup'];\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/config/detectableItems.js?");

/***/ }),

/***/ "./src/events/BaseEvent.js":
/*!*********************************!*\
  !*** ./src/events/BaseEvent.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseEvent: () => (/* binding */ BaseEvent)\n/* harmony export */ });\n/* harmony import */ var _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n\n\n/**\n * BaseEvent - Base class for events, providing common functionality\n * for activation and logging in the diary.\n * This class is used in an Observer Pattern where each event notifies\n * subscribed components (e.g., diary UI) about changes.\n */\nclass BaseEvent {\n  /**\n   * Constructor for the BaseEvent.\n   * @param {EventManager} eventManager - Instance of the event manager responsible for diary operations.\n   *\n   * @property {string} key - Unique identifier for the event, which should be set by subclasses.\n   */\n  constructor(eventManager) {\n    /** @type {EventManager} */\n    this.eventManager = eventManager;\n    // Event key; should be overridden in subclasses.\n    this.key = \"\";\n  }\n\n  /**\n   * activate - Activates the event.\n   * If an event with the given key has not been logged yet, the event is logged via the eventManager.\n   * This method handles logging and notification without triggering subsequent actions.\n   *\n   * NOTE: No direct UI manipulations should be placed here — any UI updates\n   *       (e.g. enabling/disabling buttons) happen in specialized managers.\n   *\n   * @returns {Promise<void>} Asynchronous execution.\n   */\n  async activate() {\n    try {\n      // Check if the event with this key has not been logged yet.\n      if (!this.eventManager.isEventLogged(this.key)) {\n        console.log(`Activating event: ${this.key}`);\n        // Log the event in the diary (as a user post, without ghost flag).\n        await this.eventManager.addDiaryEntry(this.key);\n      }\n    } catch (error) {\n      // Delegate error logging and user notification.\n      _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(error, \"BaseEvent.activate\");\n      _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.showError(\"An error occurred during event activation.\");\n    }\n  }\n\n  /**\n   * addDiaryEntry - Convenience method to add a diary entry.\n   * Delegates the addition to the eventManager.\n   *\n   * @param {string} text - The text of the entry to be added to the diary.\n   * @param {boolean} [isGhostPost=false] - Flag indicating if this is a ghost post.\n   * @returns {Promise<void>} Asynchronous execution.\n   */\n  async addDiaryEntry(text, isGhostPost = false) {\n    try {\n      await this.eventManager.addDiaryEntry(text, isGhostPost);\n    } catch (error) {\n      _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(error, \"BaseEvent.addDiaryEntry\");\n      _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.showError(\"An error occurred while adding a diary entry.\");\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/events/BaseEvent.js?");

/***/ }),

/***/ "./src/events/FinalEvent.js":
/*!**********************************!*\
  !*** ./src/events/FinalEvent.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FinalEvent: () => (/* binding */ FinalEvent)\n/* harmony export */ });\n/* harmony import */ var _BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseEvent.js */ \"./src/events/BaseEvent.js\");\n/* harmony import */ var _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../managers/StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../managers/ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n// File: src/events/FinalEvent.js\n\n\n\n\n\n/**\n * FinalEvent\n *\n * This event finalizes the scenario. It logs the final event,\n * sets the game as finalized, triggers a ghost fade-out effect,\n * marks the current ghost as finished, disables active UI elements,\n * and notifies the user via the ViewManager.\n *\n * NOTE: FinalEvent is part of the sequential chain managed by GhostManager.\n * It performs its task and signals completion via the \"gameEventCompleted\" event.\n */\nclass FinalEvent extends _BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__.BaseEvent {\n  /**\n   * @param {EventManager} eventManager - The diary/event manager.\n   * @param {App} appInstance - The main application instance.\n   * @param {Object} config - Configuration object from gameEntities.json, contains `key`.\n   * @param {LanguageManager} [languageManager] - Optional localization manager.\n   */\n  constructor(eventManager, appInstance, config, languageManager) {\n    super(eventManager);\n    this.app = appInstance;\n    this.languageManager = languageManager;\n    this.key = config.key;\n  }\n  async activate() {\n    if (this.eventManager.isEventLogged(this.key)) {\n      console.log(`Event '${this.key}' is already logged, skipping activation.`);\n      return;\n    }\n    console.log(`Activating final event: '${this.key}'`);\n    await this.addDiaryEntry(this.key, true);\n\n    // Set the game as finalized.\n    _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.GAME_FINALIZED, \"true\");\n\n    // Trigger the ghost fade-out effect.\n    if (this.app.visualEffectsManager && typeof this.app.visualEffectsManager.triggerGhostAppearanceEffect === \"function\") {\n      this.app.visualEffectsManager.triggerGhostAppearanceEffect(\"ghost_fade_out\");\n    }\n\n    // Mark the current ghost as finished.\n    await this.app.ghostManager.finishCurrentGhost();\n\n    // Disable active UI elements (e.g. Post button).\n    if (this.app.viewManager && typeof this.app.viewManager.setPostButtonEnabled === \"function\") {\n      this.app.viewManager.setPostButtonEnabled(false);\n    }\n\n    // Re-sync UI state.\n    if (this.app.questManager && typeof this.app.questManager.syncQuestState === \"function\") {\n      await this.app.questManager.syncQuestState();\n    }\n\n    // Remove the universal active quest key to clear any remaining quest state.\n    _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.setActiveQuestKey(null);\n\n    // Notify the user that the scenario is finished.\n    if (this.app.viewManager && typeof this.app.viewManager.showNotification === \"function\") {\n      this.app.viewManager.showNotification(\"🎉 Congratulations, the scenario is finished!\");\n    } else {\n      console.log(\"🎉 Congratulations, the scenario is finished!\");\n    }\n\n    // Dispatch an event to signal completion of the final event.\n    document.dispatchEvent(new CustomEvent(\"gameEventCompleted\", {\n      detail: this.key\n    }));\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/events/FinalEvent.js?");

/***/ }),

/***/ "./src/events/PostRepeatingEvent.js":
/*!******************************************!*\
  !*** ./src/events/PostRepeatingEvent.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostRepeatingEvent: () => (/* binding */ PostRepeatingEvent)\n/* harmony export */ });\n/* harmony import */ var _BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseEvent.js */ \"./src/events/BaseEvent.js\");\n/* harmony import */ var _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../managers/StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../managers/ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n// File: src/events/PostRepeatingEvent.js\n\n\n\n\n\n/**\n * PostRepeatingEvent\n * \n * This event finalizes the mirror quest cycle and prepares the system for the repeating quest cycle.\n * It logs a ghost post and, if the current ghost is not finished, enables the Post button and triggers the mirror effect.\n * It does not directly set quest-specific flags; these are managed via the universal state.\n *\n * NOTE: This event does not automatically trigger quest activation;\n * it simply performs its task and dispatches a \"gameEventCompleted\" event.\n */\nclass PostRepeatingEvent extends _BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__.BaseEvent {\n  /**\n   * @param {EventManager} eventManager - Manager handling diary operations.\n   * @param {App} appInstance - Reference to the main application instance.\n   * @param {Object} config - Configuration object from gameEntities.json, contains `key`.\n   * @param {LanguageManager} [languageManager] - (unused here, but kept for signature consistency)\n   */\n  constructor(eventManager, appInstance, config, languageManager) {\n    super(eventManager);\n    this.app = appInstance;\n    // Use key from config instead of hardcoded literal\n    this.key = config.key;\n  }\n\n  /**\n   * activate - Activates the post repeating event.\n   * Accepts an optional dynamicKey to generate a unique event id (e.g., \"post_repeating_event_stage_2\").\n   *\n   * @param {string} [dynamicKey] - Optional unique event key.\n   */\n  async activate(dynamicKey) {\n    const eventKey = dynamicKey || this.key;\n    if (this.eventManager.isEventLogged(eventKey)) {\n      console.log(`[PostRepeatingEvent] Event '${eventKey}' is already logged, skipping activation.`);\n      return;\n    }\n    console.log(`[PostRepeatingEvent] Activating event '${eventKey}'.`);\n    await this.addDiaryEntry(eventKey, true);\n\n    // Check if the current ghost is finished.\n    const ghost = this.app.ghostManager.getCurrentGhost();\n    if (ghost && ghost.isFinished) {\n      console.log(\"[PostRepeatingEvent] Ghost is finished; ready to dispatch event completion.\");\n      // No additional processing is needed if the ghost is finished.\n    } else {\n      // Instead of setting a mirrorQuestReady flag,\n      // simply enable the Post button and trigger the mirror effect.\n      if (this.app.viewManager && typeof this.app.viewManager.setPostButtonEnabled === \"function\") {\n        this.app.viewManager.setPostButtonEnabled(true);\n      }\n      if (this.app.visualEffectsManager && typeof this.app.visualEffectsManager.triggerMirrorEffect === \"function\") {\n        this.app.visualEffectsManager.triggerMirrorEffect();\n      }\n      console.log(\"[PostRepeatingEvent] Repeating quest cycle ended; waiting for user action.\");\n    }\n\n    // Dispatch an event to signal completion of this event.\n    document.dispatchEvent(new CustomEvent(\"gameEventCompleted\", {\n      detail: eventKey\n    }));\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/events/PostRepeatingEvent.js?");

/***/ }),

/***/ "./src/quests/BaseRepeatingQuest.js":
/*!******************************************!*\
  !*** ./src/quests/BaseRepeatingQuest.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseRepeatingQuest: () => (/* binding */ BaseRepeatingQuest)\n/* harmony export */ });\n/* harmony import */ var _events_BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/BaseEvent.js */ \"./src/events/BaseEvent.js\");\n/* harmony import */ var _utils_ImageUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ImageUtils.js */ \"./src/utils/ImageUtils.js\");\n/* harmony import */ var _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../managers/StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../managers/ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n/* harmony import */ var _config_detectableItems_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../config/detectableItems.js */ \"./src/config/detectableItems.js\");\n\n\n\n\n\n\n/**\n * BaseRepeatingQuest – Base class for the repeating quest.\n * Manages quest progress by updating state across multiple stages,\n * saving progress via StateManager, and delegating UI updates to ViewManager.\n *\n * NOTE: This quest is part of the sequential chain managed by GhostManager.\n */\nclass BaseRepeatingQuest extends _events_BaseEvent_js__WEBPACK_IMPORTED_MODULE_0__.BaseEvent {\n  constructor(eventManager, appInstance, config = {}) {\n    super(eventManager);\n    this.app = appInstance;\n    this.key = config.key || \"repeating_quest\";\n    this.doneKey = config.doneKey || this.key + \"_done\";\n\n    // UI configuration (delegated to ViewManager)\n    this.statusElementId = config.statusElementId || \"repeating-quest-status\";\n    this.shootButtonId = config.shootButtonId || \"btn_shoot\";\n\n    // Quest state\n    this.totalStages = config.totalStages || 3;\n    this.currentStage = 1;\n    this.activated = false;\n    this.finished = false;\n\n    // (Optional flag – not used further, can be removed if unnecessary)\n    this.finalRepeatingQuestCompleted = false;\n\n    // Restore saved quest state from StateManager.\n    this.loadState();\n\n    // ==== new: initialize remaining items and pick the currentTarget ====\n    // Restore the list of remaining items from StateManager or use the default array\n    const savedItems = _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.get('remainingItems');\n    this.remainingItems = savedItems ? JSON.parse(savedItems) : [..._config_detectableItems_js__WEBPACK_IMPORTED_MODULE_4__.detectableItems];\n    // Save the remaining items list (if not already saved)\n    _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.set('remainingItems', JSON.stringify(this.remainingItems));\n\n    // Pick the first item from the list as the current target\n    this.currentTarget = this.remainingItems.length > 0 ? this.remainingItems[0] : null;\n\n    // subscribe to AI‐detection events and enable Shoot button when target is found\n    document.addEventListener(\"objectDetected\", this.onObjectDetected.bind(this));\n  }\n\n  /**\n   * generateDetectionConfig\n   * Returns an object with current target for AI detection.\n   * @returns {{ target: string }}\n   */\n  generateDetectionConfig() {\n    // Use the quest’s currentTarget (set in constructor)\n    console.log(`[BaseRepeatingQuest] Providing detection target: ${this.currentTarget}`);\n    return {\n      target: this.currentTarget\n    };\n  }\n\n  /**\n   * loadState – Restores the quest state from StateManager.\n   */\n  loadState() {\n    const saved = _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.get(`quest_state_${this.key}`);\n    if (saved) {\n      try {\n        const state = JSON.parse(saved);\n        this.currentStage = state.currentStage;\n        this.finished = state.finished;\n        if (state.totalStages) {\n          this.totalStages = state.totalStages;\n        }\n        console.log(`[BaseRepeatingQuest] Restored quest state: stage=${this.currentStage}, finished=${this.finished}`);\n      } catch (e) {\n        console.error(\"[BaseRepeatingQuest] Error parsing saved quest state:\", e);\n      }\n    }\n  }\n\n  /**\n   * saveState – Saves the current quest state to StateManager.\n   */\n  saveState() {\n    const state = {\n      currentStage: this.currentStage,\n      finished: this.finished,\n      totalStages: this.totalStages\n    };\n    _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.set(`quest_state_${this.key}`, JSON.stringify(state));\n    console.log(`[BaseRepeatingQuest] Saved quest state: stage=${this.currentStage}, finished=${this.finished}`);\n  }\n\n  /**\n   * activate – Activates the repeating quest.\n   * Waits for the camera to be open (using a \"cameraReady\" event) if needed,\n   * then starts the UI check loop and sets the \"Open Camera\" button active via ViewManager.\n   * Also saves the quest record in the database with status \"active\".\n   */\n  async activate() {\n    console.log(`Activating repeating quest: ${this.key}`);\n\n    // 1) запишем в дневник и в БД\n    await this.addDiaryEntry(this.key, true);\n    await this.app.databaseManager.saveQuestRecord({\n      quest_key: this.key,\n      status: \"active\",\n      current_stage: this.currentStage,\n      total_stages: this.totalStages\n    });\n\n    // 2) визуально подсветить камеру-кнопку\n    if (this.app.viewManager?.setCameraButtonActive) {\n      this.app.viewManager.setCameraButtonActive(true);\n    }\n\n    // 3) флажок что квест стартанул\n    this.activated = true;\n\n    // 4) Ждём, пока пользователь сам откроет камеру…\n    if (this.app.isCameraOpen) {\n      this.startCheckLoop();\n    } else {\n      document.addEventListener(\"cameraReady\", () => {\n        console.log(\"[BaseRepeatingQuest] cameraReady received — starting quest loop\");\n        this.startCheckLoop();\n      }, {\n        once: true\n      });\n    }\n  }\n\n  /**\n   * startCheckLoop – Delegates UI initialization for the quest stage to ViewManager,\n   * then awaits user action (via the shoot button).\n   */\n  startCheckLoop() {\n    // теперь запускаем детекцию ТОЛЬКО если камера открыта, квест активирован и он не завершён\n    if (this.app.isCameraOpen && this.activated && !this.finished) {\n      console.log(`[BaseRepeatingQuest] Starting AI detection for target '${this.currentTarget}'.`);\n      this.app.cameraSectionManager?.startAIDetection?.({\n        target: this.currentTarget\n      });\n    }\n\n    // далее — инициализируем UI (статус + disabled Shoot)\n    if (this.app.viewManager?.startRepeatingQuestUI) {\n      this.app.viewManager.startRepeatingQuestUI({\n        statusElementId: this.statusElementId,\n        shootButtonId: this.shootButtonId,\n        stage: this.currentStage,\n        totalStages: this.totalStages,\n        target: this.currentTarget,\n        onShoot: () => this.finishStage(),\n        quest: this\n      });\n    } else {\n      console.error(\"[BaseRepeatingQuest] ViewManager.startRepeatingQuestUI is not available.\");\n    }\n    console.log(\"[BaseRepeatingQuest] Repeating quest UI updated. Awaiting user action to capture snapshot.\");\n  }\n\n  /**\n   * restoreUI – Restores the UI for the repeating quest if a cycle is active.\n   * This method now checks the DB record and, if the quest is active there,\n   * sets the local 'activated' flag to true before restoring the UI.\n   */\n  restoreUI() {\n    console.log(\"[BaseRepeatingQuest] Attempting to restore repeating quest UI...\");\n\n    // Retrieve the DB record for this quest.\n    const record = this.app.databaseManager.getQuestRecord(this.key);\n\n    // If there is no record or the status is not \"active\", skip restoration.\n    if (!record || record.status !== \"active\") {\n      console.log(\"[BaseRepeatingQuest] DB record is not active; UI restoration skipped.\");\n      return;\n    }\n\n    // If the quest is finished locally, skip restoration.\n    if (this.finished) {\n      console.log(\"[BaseRepeatingQuest] Quest is finished; UI restoration skipped.\");\n      return;\n    }\n\n    // If the quest was not activated locally (e.g. after a page reload), set it to active based on DB record.\n    if (!this.activated) {\n      console.log(\"[BaseRepeatingQuest] Quest not activated locally; setting activated=true based on DB record.\");\n      this.activated = true;\n    }\n\n    // Function to restore UI state.\n    const restoreButtonState = () => {\n      // Переинициализируем UI: статусы, статус-бар и запустим детекцию,\n      // но кнопку “Shoot” оставляем выключенной до фактической objectDetected().\n      this.startCheckLoop();\n      console.log(\"[BaseRepeatingQuest] UI restored; shoot button will be enabled upon detection.\");\n    };\n\n    // If the camera is not open yet, wait for the \"cameraReady\" event.\n    if (!this.app.isCameraOpen) {\n      document.addEventListener(\"cameraReady\", restoreButtonState, {\n        once: true\n      });\n    } else {\n      restoreButtonState();\n    }\n\n    // Если камера была открыта и videoElement уже готов,\n    // сразу запускаем восстановление (на случай, если loadedmetadata уже случился).\n    const video = this.app.cameraSectionManager.videoElement;\n    if (_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.isCameraOpen() && video && video.srcObject && video.readyState >= 2) {\n      console.log(\"[BaseRepeatingQuest] videoElement.readyState >= 2 — сразу восстанавливаем детекцию\");\n      restoreButtonState();\n    }\n  }\n\n  /**\n   * finishStage – Completes one stage of the repeating quest.\n   * Disables the \"Shoot\" button, captures a snapshot, logs the stage completion,\n   * updates quest state, and enables the \"Post\" button for the next stage (if any).\n   * \n   * IMPORTANT: After finishing a stage (if quest is not finished),\n   * a \"questCompleted\" event is dispatched to notify GhostManager.\n   */\n  async finishStage() {\n    if (this.finished) return;\n\n    // stop AI detection as soon as user pressed Shoot\n    if (this.app.cameraSectionManager && typeof this.app.cameraSectionManager.stopAIDetection === 'function') {\n      this.app.cameraSectionManager.stopAIDetection();\n      console.log(\"[BaseRepeatingQuest] AI detection stopped after shoot.\");\n    }\n    if (this.app.viewManager && typeof this.app.viewManager.setShootButtonActive === 'function') {\n      this.app.viewManager.setShootButtonActive(false);\n      console.log(\"[BaseRepeatingQuest] Shoot button disabled after click.\");\n    }\n    const photoData = this.captureSimplePhoto();\n    console.log(`[BaseRepeatingQuest] Captured snapshot for stage ${this.currentStage}.`);\n\n    // Use unified method to log diary entry.\n    await this.addDiaryEntry(`repeating_stage_${this.currentStage} [photo attached]\\n${photoData}`, false);\n    console.log(`[BaseRepeatingQuest] Completed stage: ${this.currentStage}`);\n    this.currentStage++;\n    this.saveState();\n\n    // Remove the processed item from remainingItems and persist for next cycles\n    if (this.currentTarget) {\n      this.remainingItems.shift();\n      _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.set('remainingItems', JSON.stringify(this.remainingItems));\n      this.currentTarget = this.remainingItems[0] || null;\n      console.log(`[BaseRepeatingQuest] Next detection target: ${this.currentTarget}`);\n    }\n    if (this.currentStage <= this.totalStages) {\n      // For intermediate stages, force the quest record to be \"finished\"\n      // so that a new instance of the quest can be started.\n      await this.app.databaseManager.saveQuestRecord({\n        quest_key: this.key,\n        status: \"finished\",\n        current_stage: this.currentStage,\n        total_stages: this.totalStages\n      });\n      // Removed direct call to set \"mirrorQuestReady\"; universal active quest state is managed externally.\n      if (this.app.viewManager && typeof this.app.viewManager.setPostButtonEnabled === 'function') {\n        this.app.viewManager.setPostButtonEnabled(true);\n        console.log(\"[BaseRepeatingQuest] Post button enabled for next stage.\");\n      }\n      // Dispatch event to notify that a stage of the repeating quest is completed.\n      document.dispatchEvent(new CustomEvent(\"questCompleted\", {\n        detail: this.key\n      }));\n      console.log(\"[BaseRepeatingQuest] questCompleted event dispatched for repeating quest stage.\");\n    } else {\n      // If the current stage exceeds the total stages, finish the quest completely.\n      await this.finishCompletely();\n    }\n  }\n\n  /**\n   * finishCompletely – Finalizes the repeating quest.\n   * Sets the quest as finished in the database, removes the quest state from StateManager,\n   * and dispatches the questCompleted event to signal full completion.\n   */\n  async finishCompletely() {\n    // Mark the quest as finished.\n    this.finished = true;\n    // Save the final state in the database with status \"finished\".\n    await this.app.databaseManager.saveQuestRecord({\n      quest_key: this.key,\n      status: \"finished\",\n      current_stage: this.currentStage,\n      total_stages: this.totalStages\n    });\n    // Remove the quest state from StateManager so that it doesn't get restored on page refresh.\n    _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.remove(`quest_state_${this.key}`);\n    // Dispatch the questCompleted event to signal full completion.\n    document.dispatchEvent(new CustomEvent(\"questCompleted\", {\n      detail: this.key\n    }));\n    console.log(`[BaseRepeatingQuest] Quest completely finished. questCompleted event dispatched.`);\n  }\n\n  /**\n   * captureSimplePhoto – Captures a snapshot from the active camera and returns a data URL.\n   * @returns {string} Data URL of the captured image.\n   */\n  captureSimplePhoto() {\n    const video = this.app.cameraSectionManager?.videoElement;\n    if (!video || !video.srcObject) {\n      console.warn(\"[BaseRepeatingQuest] Camera is not active — returning an empty string\");\n      return \"\";\n    }\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = video.videoWidth || 640;\n    canvas.height = video.videoHeight || 480;\n    const ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n    return canvas.toDataURL(\"image/png\");\n  }\n\n  /**\n   * resetCycle – Resets the state of the repeating quest for a new cycle.\n   */\n  resetCycle() {\n    this.finished = false;\n    this.currentStage = 1;\n    console.log(\"[BaseRepeatingQuest] Quest state has been reset for a new cycle.\");\n    this.saveState();\n  }\n\n  /**\n   * getCurrentQuestStatus – Retrieves the current status of the repeating quest.\n   * Now, instead of using a local boolean, the active flag is determined by comparing\n   * the universal active quest key with this quest's key.\n   * @returns {Promise<Object>} An object containing quest status information.\n   */\n  async getCurrentQuestStatus() {\n    const record = this.app.databaseManager.getQuestRecord(this.key);\n    const active = _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_2__.StateManager.getActiveQuestKey() === this.key;\n    return {\n      key: this.key,\n      active: active,\n      finished: this.finished,\n      currentStage: this.currentStage,\n      totalStages: this.totalStages,\n      dbStatus: record ? record.status : \"not recorded\"\n    };\n  }\n\n  /**\n   * getRandomLetter – Utility function that returns a random letter from the ghost's name.\n   * @param {string} name - The ghost's name.\n   * @returns {string} A random letter from the name.\n   */\n  getRandomLetter(name) {\n    if (!name) return \"\";\n    const letters = name.replace(/[^A-Za-zА-Яа-яЁё]/g, '').split('');\n    if (!letters.length) return '';\n    return letters[Math.floor(Math.random() * letters.length)];\n  }\n\n  /**\n   * onObjectDetected – called when the AI model detects the current target.\n   * Enables the Shoot button in the UI.\n   */\n  onObjectDetected(event) {\n    const detectedClass = event.detail;\n    if (detectedClass === this.currentTarget && this.app.isCameraOpen) {\n      console.log(`[BaseRepeatingQuest] Detected '${detectedClass}', enabling Shoot button.`);\n      if (this.app.viewManager && typeof this.app.viewManager.setShootButtonActive === 'function') {\n        this.app.viewManager.setShootButtonActive(true);\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/quests/BaseRepeatingQuest.js?");

/***/ })

}]);