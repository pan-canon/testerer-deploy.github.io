<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º COCO-SSD</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
  <style>
    #videoContainer {
      width: 640px;
      height: 480px;
      background: #000;
      position: relative;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 16px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <h1>–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ —Å –∫–∞–º–µ—Ä–æ–π</h1>
  <div id="videoContainer">
    <div id="overlay"></div>
  </div>
  <button id="startButton">–ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
  <button id="stopButton">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–∞–º–µ—Ä—É</button>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      class cameraSectionManager {
        constructor() {
          this.videoElement = null;
          this.stream = null;
          this.onVideoReady = null;
          this.onCameraClosed = null;
          this.model = null;
          this.isDetecting = false;
          this.onObjectDetected = null;
        }

        attachTo(containerId, options = {}) {
          const container = document.getElementById(containerId);
          if (!container) {
            console.error(`–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å id "${containerId}" –Ω–µ –Ω–∞–π–¥–µ–Ω!`);
            return;
          }
          if (!this.videoElement) {
            this.videoElement = document.createElement('video');
            this.videoElement.autoplay = true;
            this.videoElement.playsInline = true;
          } else if (this.videoElement.parentNode) {
            this.videoElement.parentNode.removeChild(this.videoElement);
          }
          for (const prop in options) {
            this.videoElement.style[prop] = options[prop];
          }
          container.innerHTML = "";
          container.appendChild(this.videoElement);
        }

        async startCamera() {
          if (this.stream) {
            console.log("–ö–∞–º–µ—Ä–∞ —É–∂–µ –∑–∞–ø—É—â–µ–Ω–∞");
            return;
          }
          try {
            const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            const constraints = { video: { facingMode: isMobile ? "environment" : "user" } };
            console.log(`üé• –ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã —Å —Ä–µ–∂–∏–º–æ–º: ${constraints.video.facingMode}`);
            this.stream = await navigator.mediaDevices.getUserMedia(constraints);
            if (!this.videoElement) {
              console.error("Video —ç–ª–µ–º–µ–Ω—Ç –Ω–µ —Å–æ–∑–¥–∞–Ω!");
              return;
            }
            this.videoElement.srcObject = this.stream;
            this.videoElement.addEventListener("loadedmetadata", async () => {
              console.log("loadedmetadata: –í–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ");
              if (typeof this.onVideoReady === "function") {
                this.onVideoReady();
              }
              await this.loadModel();
              this.startDetection();
              const event = new CustomEvent("cameraReady");
              document.dispatchEvent(event);
            }, { once: true });
          } catch (error) {
            console.error("‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:", error);
          }
        }

        stopCamera() {
          if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
            if (typeof this.onCameraClosed === "function") {
              this.onCameraClosed();
            }
          }
          this.isDetecting = false;
        }

        async loadModel() {
          if (!this.model) {
            console.log("–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ COCO-SSD...");
            try {
              this.model = await cocoSsd.load();
              console.log("–ú–æ–¥–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞");
            } catch (error) {
              console.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:", error);
            }
          }
        }

        startDetection() {
          if (!this.model) {
            console.error("–ú–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞. –ó–∞–ø—É—Å—Ç–∏—Ç–µ loadModel() –ø–µ—Ä–µ–¥ startDetection().");
            return;
          }
          this.isDetecting = true;
          const detectFrame = async () => {
            if (!this.isDetecting) return;
            const predictions = await this.model.detect(this.videoElement);
            if (predictions && predictions.length > 0) {
              const detectedObject = predictions[0];
              console.log("–û–±—ä–µ–∫—Ç –æ–±–Ω–∞—Ä—É–∂–µ–Ω:", detectedObject);
              if (typeof this.onObjectDetected === "function") {
                this.onObjectDetected(detectedObject);
              }
            }
            requestAnimationFrame(detectFrame);
          };
          detectFrame();
        }
      }

      const cameraManager = new cameraSectionManager();
      cameraManager.attachTo("videoContainer", { width: "640px", height: "480px" });

      // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç overlay –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ DOM
      const overlay = document.getElementById("overlay");

      cameraManager.onObjectDetected = (detectedObject) => {
        if (overlay) {
          overlay.innerHTML = `–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ: ${detectedObject.class}`;
        }
      };

      document.getElementById("startButton").addEventListener("click", () => {
        cameraManager.startCamera();
      });
      document.getElementById("stopButton").addEventListener("click", () => {
        cameraManager.stopCamera();
        if (overlay) {
          overlay.innerHTML = "";
        }
      });
    });
  </script>
</body>
</html>