/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./build/triads lazy recursive ^\\.\\/triad\\-.*$":
/*!*****************************************************************************************!*\
  !*** ./build/triads/ lazy ^\.\/triad\-.*$ chunkName: triads/[request] namespace object ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./triad-final_event\": [\n\t\t\"./build/triads/triad-final_event.js\",\n\t\t\"triads/triad-final_event\"\n\t],\n\t\"./triad-final_event.js\": [\n\t\t\"./build/triads/triad-final_event.js\",\n\t\t\"triads/triad-final_event\"\n\t],\n\t\"./triad-post_mirror_event\": [\n\t\t\"./build/triads/triad-post_mirror_event.js\",\n\t\t\"triads/triad-post_mirror_event\"\n\t],\n\t\"./triad-post_mirror_event.js\": [\n\t\t\"./build/triads/triad-post_mirror_event.js\",\n\t\t\"triads/triad-post_mirror_event\"\n\t],\n\t\"./triad-post_repeating_event\": [\n\t\t\"./build/triads/triad-post_repeating_event.js\",\n\t\t\"triads/triad-post_repeating_event\"\n\t],\n\t\"./triad-post_repeating_event.js\": [\n\t\t\"./build/triads/triad-post_repeating_event.js\",\n\t\t\"triads/triad-post_repeating_event\"\n\t],\n\t\"./triad-welcome\": [\n\t\t\"./build/triads/triad-welcome.js\",\n\t\t\"triads/triad-welcome\"\n\t],\n\t\"./triad-welcome.js\": [\n\t\t\"./build/triads/triad-welcome.js\",\n\t\t\"triads/triad-welcome\"\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = \"./build/triads lazy recursive ^\\\\.\\\\/triad\\\\-.*$\";\nmodule.exports = webpackAsyncContext;\n\n//# sourceURL=webpack://testerer-deploy.github.io/./build/triads/_lazy_^\\.\\/triad\\-.*$_chunkName:_triads/%5Brequest%5D_namespace_object?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_config_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/config/paths.js */ \"./src/config/paths.js\");\n/* harmony import */ var _src_App_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/App.js */ \"./src/App.js\");\n\n\n\n// Function to dynamically load a script and return a Promise\nfunction loadScript(src) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.src = src;\n    script.async = false; // preserve execution order\n    script.onload = () => resolve(src);\n    script.onerror = () => reject(new Error(`Failed to load ${src}`));\n    document.head.appendChild(script);\n  });\n}\n\n// 1. Load SQL.js, TF.js and COCO-SSD in sequence before doing anything else\nPromise.all([loadScript(_src_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.SQL_WASM_URL), loadScript(_src_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.TFJS_URL), loadScript(_src_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.COCO_SSD_URL)]).then(() => {\n  console.log('All external libraries loaded');\n\n  // 2. Wait for DOM, then initialize App and PWA logic\n  document.addEventListener('DOMContentLoaded', () => {\n    const app = new _src_App_js__WEBPACK_IMPORTED_MODULE_1__.App();\n\n    // PWA installation prompt handling\n    let deferredPrompt;\n    window.addEventListener('beforeinstallprompt', e => {\n      e.preventDefault();\n      deferredPrompt = e;\n      const btn = document.getElementById('install-btn');\n      if (btn) btn.style.display = 'block';\n    });\n    const installBtn = document.getElementById('install-btn');\n    if (installBtn) {\n      installBtn.addEventListener('click', async () => {\n        if (!deferredPrompt) return;\n        deferredPrompt.prompt();\n        const {\n          outcome\n        } = await deferredPrompt.userChoice;\n        console.log(`User response to the install prompt: ${outcome}`);\n        installBtn.style.display = 'none';\n        deferredPrompt = null;\n      });\n    }\n\n    // 3. Service Worker registration with auto-update hooks\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.register(`${_src_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.BASE_PATH}/sw.js`).then(reg => {\n        console.log('Service Worker registered with scope:', reg.scope);\n\n        // If there's an update ready, tell it to skip waiting\n        if (reg.waiting) {\n          reg.waiting.postMessage({\n            type: 'SKIP_WAITING'\n          });\n        }\n\n        // Listen for new SW installations\n        reg.addEventListener('updatefound', () => {\n          const newSW = reg.installing;\n          newSW.addEventListener('statechange', () => {\n            if (newSW.state === 'installed' && navigator.serviceWorker.controller) {\n              newSW.postMessage({\n                type: 'SKIP_WAITING'\n              });\n            }\n          });\n        });\n      }).catch(err => console.error('Error during Service Worker registration:', err));\n      // When a new SW takes control, reload the page so that all clients use the new version\n      navigator.serviceWorker.addEventListener('controllerchange', () => {\n        console.log(\"New Service Worker activated; reloading page\");\n        window.location.reload();\n      });\n    }\n\n    // 4. “Update” button clears caches via SW message\n    const updateBtn = document.getElementById('update-btn');\n    if (updateBtn) {\n      updateBtn.addEventListener('click', () => {\n        console.log('Update button clicked; clearing caches');\n        if (navigator.serviceWorker.controller) {\n          navigator.serviceWorker.controller.postMessage({\n            action: 'CLEAR_CACHE'\n          });\n        }\n      });\n    }\n  });\n}).catch(err => console.error('Loader error:', err));\n\n//# sourceURL=webpack://testerer-deploy.github.io/./main.js?");

/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   App: () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var _config_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config/paths.js */ \"./src/config/paths.js\");\n/* harmony import */ var _utils_ImageUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/ImageUtils.js */ \"./src/utils/ImageUtils.js\");\n/* harmony import */ var _managers_VisualEffectsManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./managers/VisualEffectsManager.js */ \"./src/managers/VisualEffectsManager.js\");\n/* harmony import */ var _managers_SQLiteDataManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./managers/SQLiteDataManager.js */ \"./src/managers/SQLiteDataManager.js\");\n/* harmony import */ var _managers_DatabaseManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./managers/DatabaseManager.js */ \"./src/managers/DatabaseManager.js\");\n/* harmony import */ var _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./managers/StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _managers_ErrorManager_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./managers/ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n/* harmony import */ var _managers_ViewManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./managers/ViewManager.js */ \"./src/managers/ViewManager.js\");\n/* harmony import */ var _managers_LanguageManager_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./managers/LanguageManager.js */ \"./src/managers/LanguageManager.js\");\n/* harmony import */ var _managers_CameraSectionManager_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./managers/CameraSectionManager.js */ \"./src/managers/CameraSectionManager.js\");\n/* harmony import */ var _managers_ProfileManager_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./managers/ProfileManager.js */ \"./src/managers/ProfileManager.js\");\n/* harmony import */ var _managers_GhostManager_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./managers/GhostManager.js */ \"./src/managers/GhostManager.js\");\n/* harmony import */ var _managers_EventManager_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./managers/EventManager.js */ \"./src/managers/EventManager.js\");\n/* harmony import */ var _managers_QuestManager_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./managers/QuestManager.js */ \"./src/managers/QuestManager.js\");\n/* harmony import */ var _managers_GameEventManager_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./managers/GameEventManager.js */ \"./src/managers/GameEventManager.js\");\n/* harmony import */ var _managers_ShowProfileModal_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./managers/ShowProfileModal.js */ \"./src/managers/ShowProfileModal.js\");\n/* harmony import */ var _managers_ChatManager_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./managers/ChatManager.js */ \"./src/managers/ChatManager.js\");\n// File: src/App.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// NEW IMPORTS FOR CHAT MODULE using the wrapper for simplified instantiation\n\n\n/**\n * Main application class.\n * This class initializes core managers, sets up the UI,\n * loads persisted state, and launches the test chat section (\"support\").\n *\n * All chat-related logic (state management, dialogue, localization)\n * is encapsulated within ChatManager.\n */\nclass App {\n  constructor(deps = {}) {\n    // Initialize or inject ViewManager and bind UI events.\n    this.viewManager = deps.viewManager || new _managers_ViewManager_js__WEBPACK_IMPORTED_MODULE_7__.ViewManager(this);\n    this.viewManager.bindEvents(this);\n\n    // Create or inject persistence managers.\n    this.sqliteDataManager = deps.sqliteDataManager || new _managers_SQLiteDataManager_js__WEBPACK_IMPORTED_MODULE_3__.SQLiteDataManager();\n    this.databaseManager = deps.databaseManager || new _managers_DatabaseManager_js__WEBPACK_IMPORTED_MODULE_4__.DatabaseManager(this.sqliteDataManager);\n\n    // Application state variables.\n    this.isCameraOpen = false;\n    this.selfieData = null;\n\n    // Initialize core domain managers.\n    this.languageManager = deps.languageManager || new _managers_LanguageManager_js__WEBPACK_IMPORTED_MODULE_8__.LanguageManager('language-selector');\n    this.cameraSectionManager = deps.cameraSectionManager || new _managers_CameraSectionManager_js__WEBPACK_IMPORTED_MODULE_9__.CameraSectionManager();\n    this.viewManager.setCameraManager(this.cameraSectionManager);\n    this.profileManager = deps.profileManager || new _managers_ProfileManager_js__WEBPACK_IMPORTED_MODULE_10__.ProfileManager(this.sqliteDataManager);\n    this.visualEffectsManager = deps.visualEffectsManager || new _managers_VisualEffectsManager_js__WEBPACK_IMPORTED_MODULE_2__.VisualEffectsManager(this, this.viewManager.controlsPanel);\n    const savedSequenceIndex = parseInt(_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_5__.StateManager.get('currentSequenceIndex'), 10) || 0;\n    this.ghostManager = deps.ghostManager || new _managers_GhostManager_js__WEBPACK_IMPORTED_MODULE_11__.GhostManager(savedSequenceIndex, this.profileManager, this);\n\n    // Create EventManager first (handles diary operations, persists posts, etc.).\n    this.eventManager = deps.eventManager || new _managers_EventManager_js__WEBPACK_IMPORTED_MODULE_12__.EventManager(this.databaseManager, this.languageManager, this.ghostManager, this.visualEffectsManager);\n    this.eventManager.viewManager = this.viewManager;\n    this.ghostManager.eventManager = this.eventManager;\n\n    // Then create GameEventManager (wraps EventManager, loads event classes, etc.).\n    this.gameEventManager = deps.gameEventManager || new _managers_GameEventManager_js__WEBPACK_IMPORTED_MODULE_14__.GameEventManager(this.eventManager, this, this.languageManager);\n\n    // Now pass GameEventManager into QuestManager (so activateEvent is available).\n    this.questManager = deps.questManager || new _managers_QuestManager_js__WEBPACK_IMPORTED_MODULE_13__.QuestManager(this.eventManager, this.gameEventManager, this);\n    this.showProfileModal = deps.showProfileModal || new _managers_ShowProfileModal_js__WEBPACK_IMPORTED_MODULE_15__.ShowProfileModal(this);\n\n    // Initialize ChatManager for the \"support\" chat section using the wrapper.\n    this.chatManager = deps.chatManager || _managers_ChatManager_js__WEBPACK_IMPORTED_MODULE_16__.ChatManager.createChatManagerWrapper({\n      databaseManager: this.databaseManager,\n      languageManager: this.languageManager,\n      sectionKey: 'support'\n    });\n\n    // Begin application initialization.\n    this.init();\n  }\n\n  /**\n   * Loads previously saved application state.\n   */\n  loadAppState() {\n    const savedGhostId = _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_5__.StateManager.get('currentGhostId');\n    if (savedGhostId) {\n      this.ghostManager.setCurrentGhost(parseInt(savedGhostId));\n    } else {\n      this.ghostManager.setCurrentGhost(1);\n    }\n  }\n\n  /**\n   * Initializes the application.\n   * Among other tasks, this method launches the support chat section.\n   */\n  async init() {\n    await this.databaseManager.initDatabasePromise;\n    console.log(\"Database initialization complete.\");\n    this.loadAppState();\n\n    // Preload AI model before any camera usage\n    await this.cameraSectionManager.preloadModel();\n    await this.questManager.syncQuestState();\n    this.questManager.restoreAllActiveQuests();\n\n    // If the camera was marked as open before reload, restore the button state,\n    // but do NOT reopen the camera or call getUserMedia automatically.\n    if (_managers_StateManager_js__WEBPACK_IMPORTED_MODULE_5__.StateManager.isCameraOpen()) {\n      this.viewManager.setCameraButtonActive(true);\n      console.log(\"Camera button active state restored based on saved state.\");\n    }\n    this.viewManager.showToggleCameraButton();\n    this.viewManager.createTopCameraControls();\n\n    // Initialize the chat section for \"support\"\n    await this.chatManager.init();\n    // Schedule support chat conversation to start after 5 seconds.\n    this.chatManager.scheduleConversationStartIfInactive(5000);\n\n    // If a profile exists, switch to main screen (and only then re-call updateDiaryDisplay).\n    // IMPORTANT: Pass `this` as the third param so `ViewManager` can reference your main app instance.\n    if (await this.profileManager.isProfileSaved()) {\n      const profile = await this.profileManager.getProfile();\n      console.log(\"Profile found:\", profile);\n      await this.viewManager.switchScreen('main-screen', 'main-buttons', this);\n      this.viewManager.showToggleCameraButton();\n\n      // Read state from previous save\n      const postButtonDisabled = _managers_StateManager_js__WEBPACK_IMPORTED_MODULE_5__.StateManager.get(\"postButtonDisabled\") === \"true\";\n      this.viewManager.setPostButtonEnabled(!postButtonDisabled);\n      this.viewManager.updateProfileDisplay(profile);\n      this.selfieData = profile.selfie;\n\n      // Render only the latest posts (lazy mode)\n      await this.viewManager.loadLatestDiaryPosts();\n    } else {\n      console.log(\"Profile not found, showing landing screen.\");\n\n      // ALSO pass `this` here. Without it, `app` will be undefined in `ViewManager`.\n      await this.viewManager.switchScreen('landing-screen', 'landing-buttons', this);\n    }\n\n    // In src/App.js, at the very end of init():\n    const preloader = document.getElementById('preloader');\n    if (preloader) {\n      preloader.style.display = 'none';\n      console.log(\"[App] Preloader hidden after AI model preload and app init.\");\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/App.js?");

/***/ }),

/***/ "./src/config/paths.js":
/*!*****************************!*\
  !*** ./src/config/paths.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASSETS_PATH: () => (/* binding */ ASSETS_PATH),\n/* harmony export */   BASE_PATH: () => (/* binding */ BASE_PATH),\n/* harmony export */   COCO_SSD_MODEL: () => (/* binding */ COCO_SSD_MODEL),\n/* harmony export */   COCO_SSD_URL: () => (/* binding */ COCO_SSD_URL),\n/* harmony export */   SQL_WASM_URL: () => (/* binding */ SQL_WASM_URL),\n/* harmony export */   TFJS_URL: () => (/* binding */ TFJS_URL)\n/* harmony export */ });\n// src/config/paths.js\nconst BASE_PATH = window.location.hostname.includes(\"github.io\") ? \"/testerer-deploy.github.io\" : \"\";\nconst ASSETS_PATH = `${BASE_PATH}/assets`;\nconst SQL_WASM_URL = `${ASSETS_PATH}/libs/db/sql-wasm.js`;\nconst TFJS_URL = `${ASSETS_PATH}/libs/tf.min.js`;\nconst COCO_SSD_URL = `${ASSETS_PATH}/libs/coco-ssd.min.js`;\nconst COCO_SSD_MODEL = `${ASSETS_PATH}/models/coco-ssd/model.json`;\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/config/paths.js?");

/***/ }),

/***/ "./src/config/stateKeys.js":
/*!*********************************!*\
  !*** ./src/config/stateKeys.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// src/config/stateKeys.js\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  CURRENT_SEQUENCE_INDEX: 'currentSequenceIndex',\n  POST_BUTTON_DISABLED: 'postButtonDisabled',\n  CAMERA_BUTTON_ACTIVE: 'cameraButtonActive',\n  CAMERA_OPEN: 'cameraOpen',\n  ACTIVE_QUEST_KEY: 'activeQuestKey',\n  MIRROR_QUEST_READY: 'mirrorQuestReady',\n  WELCOME_DONE: 'welcomeDone',\n  REPEATING_QUEST_STATE: 'quest_state_repeating_quest',\n  GAME_FINALIZED: 'gameFinalized'\n});\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/config/stateKeys.js?");

/***/ }),

/***/ "./src/locales/chatLocales_en.js":
/*!***************************************!*\
  !*** ./src/locales/chatLocales_en.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst chatLocales_en = {\n  // Initial greeting from the chat bot\n  \"greeting\": \"Hello! How may I assist you today?\",\n  // Prompt for the user to choose an option\n  \"response_prompt\": \"Please choose one of the following options:\",\n  // Answer options for the initial dialogue\n  \"option_1\": \"Tell me more about this.\",\n  \"option_2\": \"I don't understand.\",\n  \"option_3\": \"Ignore.\",\n  // Additional option variants (if needed)\n  \"option_1_1\": \"Could you elaborate further?\",\n  \"option_1_2\": \"I'd like more details.\",\n  \"option_2_1\": \"Please explain further.\",\n  // User and spirit messages in subsequent dialogues\n  \"user_reply_1\": \"I have a question regarding the service.\",\n  \"spirit_response_1\": \"Certainly, let me explain.\",\n  \"user_reply_2\": \"I'm still not clear on this.\",\n  \"spirit_response_2\": \"Allow me to provide additional information.\",\n  \"user_reply_3\": \"Thank you for the clarification.\",\n  \"spirit_response_3\": \"You're welcome.\",\n  // End-of-conversation message\n  \"end_of_conversation\": \"Thank you for chatting!\",\n  // Conversation section name for support chat\n  \"chat_support\": \"Support Chat\"\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (chatLocales_en);\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/locales/chatLocales_en.js?");

/***/ }),

/***/ "./src/locales/chatLocales_ru.js":
/*!***************************************!*\
  !*** ./src/locales/chatLocales_ru.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst chatLocales_ru = {\n  // Initial greeting from the chat bot\n  \"greeting\": \"Здравствуйте! Чем могу помочь?\",\n  // Prompt for the user to choose an option\n  \"response_prompt\": \"Пожалуйста, выберите один из вариантов:\",\n  // Answer options for the initial dialogue\n  \"option_1\": \"Расскажите подробнее.\",\n  \"option_2\": \"Я не понимаю.\",\n  \"option_3\": \"Игнорировать.\",\n  // Additional option variants (if needed)\n  \"option_1_1\": \"Можете рассказать подробнее?\",\n  \"option_1_2\": \"Нужны дополнительные детали.\",\n  \"option_2_1\": \"Пожалуйста, объясните подробнее.\",\n  // User and spirit messages in subsequent dialogues\n  \"user_reply_1\": \"У меня есть вопрос по услуге.\",\n  \"spirit_response_1\": \"Конечно, разрешите объяснить.\",\n  \"user_reply_2\": \"Я все еще не понимаю.\",\n  \"spirit_response_2\": \"Позвольте предоставить дополнительную информацию.\",\n  \"user_reply_3\": \"Спасибо за разъяснение.\",\n  \"spirit_response_3\": \"Пожалуйста.\",\n  // End-of-conversation message\n  \"end_of_conversation\": \"Спасибо за беседу!\",\n  // Conversation section name for support chat\n  \"chat_support\": \"Служба поддержки\"\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (chatLocales_ru);\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/locales/chatLocales_ru.js?");

/***/ }),

/***/ "./src/locales/chatLocales_uk.js":
/*!***************************************!*\
  !*** ./src/locales/chatLocales_uk.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst chatLocales_uk = {\n  // Initial greeting from the chat bot\n  \"greeting\": \"Вітаємо! Чим можу допомогти?\",\n  // Prompt for the user to choose an option\n  \"response_prompt\": \"Будь ласка, оберіть один із варіантів:\",\n  // Answer options for the initial dialogue\n  \"option_1\": \"Розкажіть докладніше.\",\n  \"option_2\": \"Я не розумію.\",\n  \"option_3\": \"Ігнорувати.\",\n  // Additional option variants (if needed)\n  \"option_1_1\": \"Будь ласка, розкажіть детальніше.\",\n  \"option_1_2\": \"Мені потрібні додаткові подробиці.\",\n  \"option_2_1\": \"Поясніть, будь ласка, детальніше.\",\n  // User and spirit messages in subsequent dialogues\n  \"user_reply_1\": \"У мене є питання щодо послуги.\",\n  \"spirit_response_1\": \"Звичайно, дозвольте пояснити.\",\n  \"user_reply_2\": \"Я все ще не розумію.\",\n  \"spirit_response_2\": \"Дозвольте надати додаткову інформацію.\",\n  \"user_reply_3\": \"Дякую за роз'яснення.\",\n  \"spirit_response_3\": \"Будь ласка.\",\n  // End-of-conversation message\n  \"end_of_conversation\": \"Дякуємо за розмову!\",\n  // Conversation section name for support chat\n  \"chat_support\": \"Підтримка\"\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (chatLocales_uk);\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/locales/chatLocales_uk.js?");

/***/ }),

/***/ "./src/locales/locales.js":
/*!********************************!*\
  !*** ./src/locales/locales.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst locales = {\n  \"en\": {\n    \"welcome\": \"Welcome!\",\n    \"post_repeating_event\": \"Отлично, ты справился с предыдущим заданием! Вот тебе новое.\",\n    \"enter_name\": \"Enter your name:\",\n    \"select_gender\": \"Select your gender:\",\n    \"male\": \"Male\",\n    \"female\": \"Female\",\n    \"other\": \"Other\",\n    \"next\": \"Next\",\n    \"take_selfie\": \"Take a Selfie\",\n    \"capture\": \"Capture\",\n    \"complete\": \"Complete\",\n    \"diary\": \"Your Diary\",\n    \"empty_diary\": \"No entries yet...\",\n    \"select_language\": \"Select Language\",\n    \"reset\": \"Reset Data\",\n    \"export\": \"Export Profile\",\n    \"import_profile\": \"Import Profile\",\n    \"import\": \"Import\",\n    \"answer\": \"Answer\",\n    \"ignore\": \"Ignore\",\n    \"open_camera\": \"Open Camera\",\n    \"open_diary\": \"Open Diary\",\n    \"mirror_quest\": \"They are asking me to come to the mirror...\",\n    \"ignored_call\": \"I didn't answer, I don't know who it was. Hm.... Text. “З”. What would that mean...\",\n    \"what_was_it\": \"What was that?\"\n  },\n  \"ru\": {\n    \"welcome\": \"Добро пожаловать!\",\n    \"post_repeating_event\": \"Отлично, ты справился с предыдущим заданием! Вот тебе новое.\",\n    \"enter_name\": \"Введите ваше имя:\",\n    \"select_gender\": \"Выберите ваш пол:\",\n    \"male\": \"Мужской\",\n    \"female\": \"Женский\",\n    \"other\": \"Другой\",\n    \"next\": \"Далее\",\n    \"take_selfie\": \"Сделайте селфи\",\n    \"capture\": \"Сделать фото\",\n    \"complete\": \"Завершить\",\n    \"diary\": \"Ваш дневник\",\n    \"empty_diary\": \"Записей пока нет...\",\n    \"select_language\": \"Выберите язык\",\n    \"reset\": \"Сбросить данные\",\n    \"export\": \"Экспорт профиля\",\n    \"import_profile\": \"Импорт профиля\",\n    \"import\": \"Импорт\",\n    \"answer\": \"Ответить\",\n    \"ignore\": \"Игнорировать\",\n    \"open_camera\": \"Открыть камеру\",\n    \"open_diary\": \"Открыть дневник\",\n    \"mirror_quest\": \"Они просят подойти меня к зеркалу.\",\n    \"ignored_call\": \"Я не ответил(а), я не знаю, кто это. Хм.... Смс. \\\"З\\\". Что бы это значило...\",\n    \"what_was_it\": \"Что это было?\"\n  },\n  \"uk\": {\n    \"welcome\": \"Ласкаво просимо!\",\n    \"post_repeating_event\": \"Отлично, ты справился с предыдущим заданием! Вот тебе новое.\",\n    \"enter_name\": \"Введіть ваше ім'я:\",\n    \"select_gender\": \"Оберіть вашу стать:\",\n    \"male\": \"Чоловіча\",\n    \"female\": \"Жіноча\",\n    \"other\": \"Інша\",\n    \"next\": \"Далі\",\n    \"take_selfie\": \"Зробіть селфі\",\n    \"capture\": \"Зробити фото\",\n    \"complete\": \"Завершити\",\n    \"diary\": \"Ваш щоденник\",\n    \"empty_diary\": \"Записів поки немає...\",\n    \"select_language\": \"Оберіть мову\",\n    \"reset\": \"Скинути дані\",\n    \"export\": \"Експорт профілю\",\n    \"import_profile\": \"Імпорт профілю\",\n    \"import\": \"Імпорт\",\n    \"answer\": \"Відповісти\",\n    \"ignore\": \"Ігнорувати\",\n    \"open_camera\": \"Відкрити камеру\",\n    \"open_diary\": \"Відкрити щоденник\",\n    \"mirror_quest\": \"Вони просять підійти мене до дзеркала.\",\n    \"ignored_call\": \"Я не відповів(ла), я не знаю, хто це. Хм.... Смс. «З». Що б це означало...\",\n    \"what_was_it\": \"What was that?\"\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locales);\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/locales/locales.js?");

/***/ }),

/***/ "./src/managers/ApartmentPlanManager.js":
/*!**********************************************!*\
  !*** ./src/managers/ApartmentPlanManager.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApartmentPlanManager: () => (/* binding */ ApartmentPlanManager)\n/* harmony export */ });\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n/* harmony import */ var _StateManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateManager.js */ \"./src/managers/StateManager.js\");\n\n\nclass ApartmentPlanManager {\n  /**\n   * Constructor for ApartmentPlanManager.\n   * @param {string} containerId - ID of the container where the apartment plan will be displayed.\n   * @param {DatabaseManager} dbManager - Manager for database persistence.\n   * @param {App} appInstance - Reference to the main application instance.\n   */\n  constructor(containerId, dbManager, appInstance) {\n    this.app = appInstance; // Reference to main app (for UI delegation)\n    this.container = document.getElementById(containerId);\n    this.dbManager = dbManager;\n\n    // Array of room objects for the current floor.\n    // Each room has properties: { floor, startRow, startCol, endRow, endCol, type }\n    this.rooms = [];\n\n    // Current floor.\n    this.currentFloor = 1;\n\n    // Flags for cell selection.\n    this.isSelecting = false;\n    this.startCell = null;\n    this.endCell = null;\n\n    // Grid dimensions (16×16 cells).\n    this.gridRows = 16;\n    this.gridCols = 16;\n\n    // Create grid and bind events.\n    this.createGrid();\n    this.attachEvents();\n\n    // Load plan data for the current floor after DB initialization.\n    this.dbManager.initDatabasePromise.then(() => {\n      this.loadFromDB();\n    });\n\n    // Bind event listener for the \"Next\" button on the apartment plan screen.\n    const nextBtn = document.getElementById(\"apartment-plan-next-btn\");\n    if (nextBtn) {\n      nextBtn.addEventListener(\"click\", () => {\n        // Optionally disable the button to prevent double-clicks.\n        nextBtn.disabled = true;\n        // Delegate transition to the selfie screen via ViewManager.\n        this.app.viewManager.goToSelfieScreen(this.app);\n      });\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(\"Apartment plan Next button not found during initialization.\", \"ApartmentPlanManager\");\n    }\n  }\n\n  /**\n   * createGrid – Creates a grid container for the apartment plan.\n   */\n  createGrid() {\n    this.gridContainer = document.createElement('div');\n    this.gridContainer.style.display = \"grid\";\n    this.gridContainer.style.gridTemplateColumns = `repeat(${this.gridCols}, 50px)`;\n    this.gridContainer.style.gridAutoRows = \"50px\";\n    this.gridContainer.style.gap = \"1px\";\n    this.container.innerHTML = \"\";\n    this.container.appendChild(this.gridContainer);\n    this.initGrid();\n  }\n\n  /**\n   * initGrid – Initializes the grid by creating cells.\n   */\n  initGrid() {\n    this.gridContainer.innerHTML = \"\";\n    for (let r = 0; r < this.gridRows; r++) {\n      for (let c = 0; c < this.gridCols; c++) {\n        const cell = document.createElement(\"div\");\n        cell.dataset.row = r;\n        cell.dataset.col = c;\n        cell.style.width = \"50px\";\n        cell.style.height = \"50px\";\n        cell.style.border = \"1px solid #ccc\";\n        cell.style.textAlign = \"center\";\n        cell.style.verticalAlign = \"middle\";\n        cell.style.cursor = \"pointer\";\n        this.gridContainer.appendChild(cell);\n      }\n    }\n  }\n\n  /**\n   * attachEvents – Binds mouse and touch event handlers for cell selection.\n   */\n  attachEvents() {\n    this.gridContainer.addEventListener(\"mousedown\", e => this.startSelection(e));\n    this.gridContainer.addEventListener(\"mousemove\", e => this.updateSelection(e));\n    document.addEventListener(\"mouseup\", e => this.finishSelection(e));\n    this.gridContainer.addEventListener(\"touchstart\", e => this.handleTouchStart(e));\n    this.gridContainer.addEventListener(\"touchmove\", e => this.handleTouchMove(e));\n    this.gridContainer.addEventListener(\"touchend\", e => this.handleTouchEnd(e));\n  }\n  handleTouchStart(e) {\n    e.preventDefault();\n    const touch = e.touches[0];\n    const target = document.elementFromPoint(touch.clientX, touch.clientY);\n    if (target && target.tagName === \"DIV\") {\n      this.startSelection({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n        target\n      });\n    }\n  }\n  handleTouchMove(e) {\n    e.preventDefault();\n    const touch = e.touches[0];\n    const target = document.elementFromPoint(touch.clientX, touch.clientY);\n    if (target && target.tagName === \"DIV\") {\n      this.updateSelection({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n        target\n      });\n    }\n  }\n  handleTouchEnd(e) {\n    e.preventDefault();\n    this.finishSelection(e);\n  }\n\n  /**\n   * startSelection – Begins cell selection.\n   */\n  startSelection(e) {\n    if (e.target.tagName === \"DIV\") {\n      this.isSelecting = true;\n      const row = parseInt(e.target.dataset.row);\n      const col = parseInt(e.target.dataset.col);\n      this.startCell = {\n        row,\n        col\n      };\n      this.endCell = {\n        row,\n        col\n      };\n      this.highlightSelection();\n    }\n  }\n\n  /**\n   * updateSelection – Updates cell selection as the pointer moves.\n   */\n  updateSelection(e) {\n    if (this.isSelecting && e.target.tagName === \"DIV\") {\n      const row = parseInt(e.target.dataset.row);\n      const col = parseInt(e.target.dataset.col);\n      this.endCell = {\n        row,\n        col\n      };\n      this.highlightSelection();\n    }\n  }\n\n  /**\n   * finishSelection – Completes cell selection and shows the location type modal.\n   */\n  finishSelection(e) {\n    // Ignore events inside modal overlay.\n    if (e.target.closest('#location-type-modal-overlay')) return;\n    if (this.isSelecting) {\n      this.isSelecting = false;\n      if (!this.startCell || !this.endCell) {\n        this.startCell = {\n          row: 0,\n          col: 0\n        };\n        this.endCell = {\n          row: this.gridRows - 1,\n          col: this.gridCols - 1\n        };\n      }\n      // Delegate modal display to ViewManager.\n      this.app.viewManager.showLocationTypeModal(selectedType => {\n        // Confirm callback: save location type and add room.\n        if (this.app && this.app.profileManager) {\n          this.app.profileManager.saveLocationType(selectedType);\n        }\n        const room = {\n          floor: this.currentFloor,\n          startRow: Math.min(this.startCell.row, this.endCell.row),\n          startCol: Math.min(this.startCell.col, this.endCell.col),\n          endRow: Math.max(this.startCell.row, this.endCell.row),\n          endCol: Math.max(this.startCell.col, this.endCell.col),\n          type: selectedType\n        };\n        this.rooms.push(room);\n        this.saveToDB();\n        this.renderRooms();\n        // Enable the \"Next\" button on the apartment plan screen.\n        if (this.app && this.app.viewManager && typeof this.app.viewManager.setApartmentPlanNextButtonEnabled === 'function') {\n          this.app.viewManager.setApartmentPlanNextButtonEnabled(true);\n        }\n      }, () => {\n        // Cancel callback: use default type \"Other\".\n        console.log(\"No location selected, default type 'Other' chosen.\");\n        if (this.app && this.app.profileManager) {\n          this.app.profileManager.saveLocationType(\"Other\");\n        }\n        const room = {\n          floor: this.currentFloor,\n          startRow: Math.min(this.startCell.row, this.endCell.row),\n          startCol: Math.min(this.startCell.col, this.endCell.col),\n          endRow: Math.max(this.startCell.row, this.endCell.row),\n          endCol: Math.max(this.startCell.col, this.endCell.col),\n          type: \"Other\"\n        };\n        this.rooms.push(room);\n        this.saveToDB();\n        this.renderRooms();\n        if (this.app && this.app.viewManager && typeof this.app.viewManager.setApartmentPlanNextButtonEnabled === 'function') {\n          this.app.viewManager.setApartmentPlanNextButtonEnabled(true);\n        }\n      });\n    }\n  }\n\n  /**\n   * highlightSelection – Visually highlights the selected area in the grid.\n   */\n  highlightSelection() {\n    Array.from(this.gridContainer.children).forEach(cell => {\n      cell.style.backgroundColor = \"\";\n    });\n    if (!this.startCell || !this.endCell) return;\n    const startRow = Math.min(this.startCell.row, this.endCell.row);\n    const endRow = Math.max(this.startCell.row, this.endCell.row);\n    const startCol = Math.min(this.startCell.col, this.endCell.col);\n    const endCol = Math.max(this.startCell.col, this.endCell.col);\n    for (let r = startRow; r <= endRow; r++) {\n      for (let c = startCol; c <= endCol; c++) {\n        const cell = this.gridContainer.querySelector(`div[data-row='${r}'][data-col='${c}']`);\n        if (cell) cell.style.backgroundColor = \"rgba(255, 0, 0, 0.3)\";\n      }\n    }\n  }\n\n  /**\n   * renderRooms – Recreates the grid and highlights cells corresponding to saved rooms for the current floor.\n   */\n  renderRooms() {\n    this.initGrid();\n    this.rooms.forEach(room => {\n      if (room.floor === this.currentFloor) {\n        for (let r = room.startRow; r <= room.endRow; r++) {\n          for (let c = room.startCol; c <= room.endCol; c++) {\n            const cell = this.gridContainer.querySelector(`div[data-row='${r}'][data-col='${c}']`);\n            if (cell) cell.style.backgroundColor = \"rgba(0, 150, 255, 0.5)\";\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * saveToDB – Saves the apartment plan (rooms) for the current floor to the database.\n   */\n  saveToDB() {\n    const currentRooms = this.rooms.filter(room => room.floor === this.currentFloor);\n    console.log(\"Saving rooms to DB: \", currentRooms);\n    this.dbManager.addApartmentRooms(this.currentFloor, currentRooms);\n  }\n\n  /**\n   * loadFromDB – Loads the apartment plan data for the current floor from the database.\n   */\n  loadFromDB() {\n    console.log(\"Loading data for floor: \", this.currentFloor);\n    this.dbManager.getApartmentPlan(this.currentFloor, rooms => {\n      if (!rooms || rooms.length === 0) {\n        console.log(`No rooms found for floor ${this.currentFloor}, using default.`);\n      } else {\n        console.log(`Rooms found for floor ${this.currentFloor}: `, rooms);\n      }\n      this.rooms = rooms;\n      this.renderRooms();\n    });\n  }\n\n  /**\n   * nextFloor – Switches to the next floor and loads its data.\n   */\n  nextFloor() {\n    console.log(\"Switching to next floor\");\n    this.currentFloor++;\n    this.loadFromDB();\n  }\n\n  /**\n   * prevFloor – Switches to the previous floor if possible.\n   */\n  prevFloor() {\n    if (this.currentFloor > 1) {\n      console.log(\"Switching to previous floor\");\n      this.currentFloor--;\n      this.loadFromDB();\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/ApartmentPlanManager.js?");

/***/ }),

/***/ "./src/managers/CameraSectionManager.js":
/*!**********************************************!*\
  !*** ./src/managers/CameraSectionManager.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSectionManager: () => (/* binding */ CameraSectionManager)\n/* harmony export */ });\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n/* harmony import */ var _config_paths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/paths.js */ \"./src/config/paths.js\");\n// CameraSectionManager.js\n\n\nclass CameraSectionManager {\n  /**\n   * Constructor for CameraSectionManager.\n   * Initializes:\n   * - videoElement: Created dynamically on the first call to attachTo().\n   * - stream: Stores the MediaStream obtained from getUserMedia.\n   * - onVideoReady: Callback invoked when the video stream is ready (after loadedmetadata event).\n   * - onCameraClosed: Callback invoked after the camera is stopped.\n   */\n  constructor() {\n    this.videoElement = null;\n    this.stream = null;\n    this.onVideoReady = null;\n    this.onCameraClosed = null;\n\n    // New properties for extended functionality\n    this.isDetecting = false;\n    this.aiDetectionTimer = null;\n    this.aiModel = null;\n    this.aiDetectionInterval = 5000; // 5 seconds default\n    this.currentDetectionConfig = null; // To be generated for repeating quests\n\n    this.recordingStartTime = null;\n    this.recordingTimerId = null;\n\n    // Persistent detection frame element\n    this.detectionFrame = null;\n\n    // Reset detection frame when repeating quest completes\n    document.addEventListener('questCompleted', e => {\n      if (e.detail === 'repeating_quest') {\n        this.resetDetectionFrame();\n      }\n    });\n  }\n\n  /**\n   * preloadModel – Preloads the COCO-SSD model so that detection can start immediately later.\n   * Stores the loading promise to avoid double-loading.\n   */\n  async preloadModel() {\n    if (!this.modelPromise) {\n      console.log(\"[CameraSectionManager] Preloading AI model...\");\n      this.modelPromise = cocoSsd.load({\n        modelUrl: _config_paths_js__WEBPACK_IMPORTED_MODULE_1__.COCO_SSD_MODEL\n      });\n    }\n    try {\n      this.aiModel = await this.modelPromise;\n      console.log(\"[CameraSectionManager] AI model preloaded successfully.\");\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(error, \"CameraSectionManager.preloadModel\");\n    }\n  }\n\n  /**\n   * attachTo(containerId, options)\n   * Attaches the video element to the specified container.\n   * Creates the video element if it doesn't exist, applies style options,\n   * and clears the container before appending.\n   *\n   * @param {string} containerId - The ID of the container.\n   * @param {Object} [options={}] - CSS style properties for the video element.\n   */\n  attachTo(containerId, options = {}) {\n    const container = document.getElementById(containerId);\n    if (!container) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(`Container with id \"${containerId}\" not found!`, \"attachTo\");\n      return;\n    }\n    if (!this.videoElement) {\n      this.videoElement = document.createElement('video');\n      this.videoElement.autoplay = true;\n      this.videoElement.playsInline = true;\n      // Ensure global id for referencing in AR.js\n      this.videoElement.id = \"global-camera-video\";\n    } else if (this.videoElement.parentNode) {\n      this.videoElement.parentNode.removeChild(this.videoElement);\n    }\n    for (const prop in options) {\n      this.videoElement.style[prop] = options[prop];\n    }\n    container.innerHTML = \"\";\n    container.appendChild(this.videoElement);\n  }\n\n  /**\n   * startCamera – Starts the camera by requesting access via getUserMedia.\n   * If already running, logs a message and does nothing.\n   * Upon success, sets the video element's source to the stream.\n   * Once the video metadata is loaded, calls onVideoReady (if defined)\n   * and dispatches the custom \"cameraReady\" event.\n   */\n  async startCamera() {\n    if (this.stream) {\n      console.log(\"Camera already started\");\n      return;\n    }\n    try {\n      // Automatically attach video element if not created yet.\n      if (!this.videoElement) {\n        this.attachTo(\"global-camera\", {\n          width: \"100%\",\n          height: \"100%\",\n          filter: \"grayscale(100%)\"\n        });\n        console.log(\"Video element was not created; auto-attached to 'global-camera'.\");\n      }\n      const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);\n      const constraints = {\n        video: {\n          facingMode: isMobile ? \"environment\" : \"user\"\n        }\n      };\n      console.log(`Starting camera with facing mode: ${constraints.video.facingMode}`);\n      this.stream = await navigator.mediaDevices.getUserMedia(constraints);\n      if (!this.videoElement) {\n        _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(\"Video element not created!\", \"startCamera\");\n        return;\n      }\n      this.videoElement.srcObject = this.stream;\n\n      // Если метаданные уже загружены (быстрый F5), запускаем сразу\n      if (this.videoElement.readyState >= 2) {\n        console.log(\"Video metadata already ready; dispatching cameraReady immediately\");\n        if (typeof this.onVideoReady === \"function\") {\n          this.onVideoReady();\n        }\n        document.dispatchEvent(new CustomEvent(\"cameraReady\"));\n        // Create persistent detection frame once video is ready\n        this.createDetectionFrame();\n      } else {\n        // Иначе ждём обычный loadedmetadata\n        this.videoElement.addEventListener(\"loadedmetadata\", () => {\n          console.log(\"loadedmetadata: Video stream is ready\");\n          if (typeof this.onVideoReady === \"function\") {\n            this.onVideoReady();\n          }\n          document.dispatchEvent(new CustomEvent(\"cameraReady\"));\n          // Create persistent detection frame once video is ready\n          this.createDetectionFrame();\n        }, {\n          once: true\n        });\n      }\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(error, \"startCamera\");\n    }\n  }\n\n  /**\n   * stopCamera – Stops the current camera stream.\n   * Iterates over all tracks in the stream and stops them.\n   * Resets the stream property to null and calls onCameraClosed (if defined).\n   */\n  stopCamera() {\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n      this.stream = null;\n      if (typeof this.onCameraClosed === \"function\") {\n        this.onCameraClosed();\n      }\n    }\n  }\n\n  // ---------------- Extended Methods ----------------\n\n  /**\n   * createDetectionFrame – Creates a full-screen white border that pulses.\n   */\n  createDetectionFrame() {\n    // Inject pulsing keyframes once\n    if (!document.getElementById('detection-frame-style')) {\n      const style = document.createElement('style');\n      style.id = 'detection-frame-style';\n      style.textContent = `\n  @keyframes detectionPulse {\n    0%   { transform: scale(1);   opacity: 0.8; }\n    50%  { transform: scale(1.02);opacity: 1;   }\n    100% { transform: scale(1);   opacity: 0.8; }\n  }`;\n      document.head.appendChild(style);\n    }\n    this.detectionFrame = document.createElement('div');\n    Object.assign(this.detectionFrame.style, {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      width: '100%',\n      height: '100%',\n      border: '3px solid #fff',\n      boxSizing: 'border-box',\n      pointerEvents: 'none',\n      animation: 'detectionPulse 2s infinite'\n    });\n    document.body.appendChild(this.detectionFrame);\n    console.log('Detection frame initialized and pulsing.');\n  }\n\n  /**\n   * updateDetectionFrame – Shrinks the frame to match detected object's bbox.\n   * @param {Array<number>} bbox – [x, y, width, height]\n   */\n  updateDetectionFrame(bbox) {\n    const [x, y, w, h] = bbox;\n    this.detectionFrame.style.transition = 'all 0.3s ease-out';\n    this.detectionFrame.style.left = `${x}px`;\n    this.detectionFrame.style.top = `${y}px`;\n    this.detectionFrame.style.width = `${w}px`;\n    this.detectionFrame.style.height = `${h}px`;\n    // Stop pulsing while focused on object\n    this.detectionFrame.style.animation = '';\n    console.log(`Detection frame moved to bbox: ${bbox}`);\n  }\n\n  /**\n   * resetDetectionFrame – Returns the frame back to full-screen and re-enables pulsing.\n   */\n  resetDetectionFrame() {\n    this.detectionFrame.style.transition = 'all 0.5s ease-out';\n    this.detectionFrame.style.left = '0';\n    this.detectionFrame.style.top = '0';\n    this.detectionFrame.style.width = '100%';\n    this.detectionFrame.style.height = '100%';\n    this.detectionFrame.style.animation = 'detectionPulse 2s infinite';\n    console.log('Detection frame reset to full-screen and pulsing.');\n  }\n\n  /**\n   * startARMode\n   * Activates AR mode by inserting an AR.js scene that uses the same video stream.\n   */\n  startARMode() {\n    // Use the global video element id for AR.js reference\n    if (!this.videoElement || !this.stream) {\n      console.warn(\"Camera is not active. AR mode cannot be started.\");\n      return;\n    }\n    // Create AR scene markup with reference to the video element id\n    const arMarkup = `\n      <a-scene embedded arjs=\"sourceType: video; videoElement: #${this.videoElement.id}\">\n        <a-marker preset=\"hiro\">\n          <a-box position=\"0 0.5 0\" material=\"color: red;\"></a-box>\n        </a-marker>\n        <a-camera-static></a-camera-static>\n      </a-scene>\n    `;\n    // Insert AR scene into DOM (for example, at the end of the body)\n    document.body.insertAdjacentHTML('beforeend', arMarkup);\n    console.log(\"AR mode activated.\");\n  }\n\n  /**\n   * stopARMode\n   * Deactivates AR mode by removing the AR.js scene from the DOM.\n   */\n  stopARMode() {\n    const arScene = document.querySelector('a-scene[arjs]');\n    if (arScene) {\n      arScene.remove();\n      console.log(\"AR mode deactivated.\");\n    }\n  }\n\n  /**\n   * applyFilter\n   * Applies a CSS filter to the video element.\n   * @param {string} filterType - 'nightVision', 'blackWhite' or '' for none.\n   */\n  applyFilter(filterType) {\n    if (!this.videoElement) return;\n    if (filterType === 'nightVision') {\n      this.videoElement.style.filter = 'brightness(150%) contrast(120%) sepia(100%) hue-rotate(90deg)';\n    } else if (filterType === 'blackWhite') {\n      this.videoElement.style.filter = 'grayscale(100%)';\n    } else {\n      this.videoElement.style.filter = '';\n    }\n    console.log(`Filter applied: ${filterType}`);\n  }\n\n  /**\n   * startRecordingTimer\n   * Starts a timer (via UI overlay managed externally) for recording duration.\n   */\n  startRecordingTimer() {\n    this.recordingStartTime = Date.now();\n    // Here we assume that the UI overlay for timer is created by ViewManager.\n    // In case it is not, you can create a temporary element.\n    const timerElem = document.getElementById(\"recording-timer\");\n    if (timerElem) {\n      timerElem.style.display = \"block\";\n      this.recordingTimerId = setInterval(() => {\n        const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);\n        timerElem.innerText = `Recording: ${elapsed} sec`;\n      }, 1000);\n    }\n  }\n\n  /**\n   * stopRecordingTimer\n   * Stops the recording timer and hides the UI overlay.\n   */\n  stopRecordingTimer() {\n    clearInterval(this.recordingTimerId);\n    const timerElem = document.getElementById(\"recording-timer\");\n    if (timerElem) {\n      timerElem.style.display = \"none\";\n    }\n  }\n\n  /**\n   * updateBatteryStatus\n   * Retrieves battery status using the Battery API and displays it in a UI overlay.\n   */\n  async updateBatteryStatus() {\n    try {\n      const battery = await navigator.getBattery();\n      const batteryElem = document.getElementById(\"battery-status\");\n      const update = () => {\n        if (batteryElem) {\n          batteryElem.innerText = `Battery: ${Math.floor(battery.level * 100)}%`;\n        }\n      };\n      update();\n      battery.addEventListener('levelchange', update);\n      if (batteryElem) {\n        batteryElem.style.display = \"block\";\n      }\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(error, \"updateBatteryStatus\");\n    }\n  }\n\n  /**\n   * startAIDetection\n   * Loads the COCO-SSD model if necessary and begins detection loop.\n   * Stores only the `target` property from config for quest logic.\n   * @param {{ target?: string }} config\n   */\n  async startAIDetection(config = {}) {\n    this.currentDetectionConfig = {\n      target: config.target || null\n    };\n    this.isDetecting = true;\n    console.log(`[CameraSectionManager] startAIDetection(): target = \"${this.currentDetectionConfig.target}\"`);\n    if (!this.aiModel) {\n      console.log(\"[CameraSectionManager] Waiting for preloaded model…\");\n      await this.modelPromise; // если вы уже сделали preloadModel\n      if (!this.aiModel) {\n        console.error(\"[CameraSectionManager] Model failed to preload\");\n        return;\n      }\n    }\n    this.runAIDetection();\n  }\n\n  /**\n   * runAIDetection\n   * Performs object detection on the current video frame and processes predictions.\n   */\n  async runAIDetection() {\n    if (!this.isDetecting) {\n      return;\n    }\n    if (!this.videoElement || this.videoElement.readyState < 2) {\n      // video not ready yet; try again shortly\n      this.aiDetectionTimer = setTimeout(() => this.runAIDetection(), this.aiDetectionInterval);\n      return;\n    }\n    try {\n      const predictions = await this.aiModel.detect(this.videoElement);\n      console.log(\"[CameraSectionManager] predictions:\", predictions);\n      this.handleAIPredictions(predictions);\n    } catch (error) {\n      console.error(\"[CameraSectionManager] Error during detect():\", error);\n    }\n    this.aiDetectionTimer = setTimeout(() => this.runAIDetection(), this.aiDetectionInterval);\n  }\n\n  /**\n   * handleAIPredictions\n   * Filters predictions by the current target and confidence,\n   * draws a frame and dispatches `objectDetected` when found.\n   * @param {Array<{class: string, score: number, bbox: number[]}>} predictions\n   */\n  handleAIPredictions(predictions) {\n    const target = this.currentDetectionConfig?.target;\n    console.log(`[CameraSectionManager] handleAIPredictions(): looking for \"${target}\"`);\n    if (!target) return;\n    for (const pred of predictions) {\n      // Only process high-confidence hits for the current target\n      if (pred.score > 0.6 && pred.class === target) {\n        console.log(`[CameraSectionManager] MATCH for \"${target}\" (score=${pred.score.toFixed(3)})`, pred.bbox);\n        this.animateCornerFrame(pred.bbox);\n        // Notify quest logic that the target was found\n        document.dispatchEvent(new CustomEvent(\"objectDetected\", {\n          detail: target\n        }));\n      }\n    }\n  }\n\n  /**\n   * animateCornerFrame – Shrinks the persistent frame to bbox instead of creating a new one.\n   */\n  animateCornerFrame(bbox) {\n    if (!this.detectionFrame) return;\n    this.updateDetectionFrame(bbox);\n  }\n\n  /**\n   * stopAIDetection\n   * Stops the AI detection loop.\n   */\n  stopAIDetection() {\n    this.isDetecting = false;\n    if (this.aiDetectionTimer) {\n      clearTimeout(this.aiDetectionTimer);\n      this.aiDetectionTimer = null;\n    }\n    console.log(\"[CameraSectionManager] AI detection stopped.\");\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/CameraSectionManager.js?");

/***/ }),

/***/ "./src/managers/ChatManager.js":
/*!*************************************!*\
  !*** ./src/managers/ChatManager.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatManager: () => (/* binding */ ChatManager)\n/* harmony export */ });\n/* harmony import */ var _config_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/paths.js */ \"./src/config/paths.js\");\n/* harmony import */ var _utils_TemplateEngine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/TemplateEngine.js */ \"./src/utils/TemplateEngine.js\");\n/* harmony import */ var _utils_SpiritBoardUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/SpiritBoardUtils.js */ \"./src/utils/SpiritBoardUtils.js\");\n/* harmony import */ var _StateManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StateManager.js */ \"./src/managers/StateManager.js\");\n\n\n\n\nclass ChatManager {\n  /**\n   * @param {Object} options - Configuration options for the chat.\n   *  - templateUrl: URL to fetch the chat template fragment (default: dynamic base path + '/src/templates/chat_template.html')\n   *  - mode: 'full' (default) for full chat, or 'board-only' for displaying only the spirit board.\n   *  - basePath: (optional) override for the base path.\n   *  - databaseManager: (optional) instance of DatabaseManager to load chat messages.\n   *  - languageManager: (optional) instance of LanguageManager for locale integration.\n   *  - sectionKey: (optional) unique identifier for the chat section.\n   */\n  constructor(options = {}) {\n    this.templateUrl = options.templateUrl || `${_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.BASE_PATH}/src/templates/chat_template.html`;\n    this.mode = options.mode || 'full';\n    this.container = null; // DOM element for the chat section\n    this.databaseManager = options.databaseManager || null;\n    // Optional language manager for localized strings.\n    this.languageManager = options.languageManager || null;\n    // Optional unique key to identify a chat section.\n    this.sectionKey = options.sectionKey || null;\n    // We'll store the scenario manager here if needed.\n    this.scenarioManager = null;\n  }\n\n  /**\n   * Static method to create a ChatManager instance with default options merged with any provided overrides.\n   *\n   * @param {Object} options - Custom options to override default values.\n   * @returns {ChatManager} A new instance of ChatManager.\n   */\n  static createChatManagerWrapper(options = {}) {\n    const defaultOptions = {\n      templateUrl: `${_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.BASE_PATH}/src/templates/chat_template.html`,\n      mode: 'full'\n    };\n    return new ChatManager({\n      ...defaultOptions,\n      ...options\n    });\n  }\n\n  /**\n   * Returns the full state key by combining the section key (if provided) with the base key.\n   *\n   * @param {string} baseKey - The base key string (e.g. 'chat_started').\n   * @returns {string} The composite state key.\n   */\n  getStateKey(baseKey) {\n    return this.sectionKey ? `${this.sectionKey}_${baseKey}` : baseKey;\n  }\n\n  /**\n   * Helper method to fetch a localized string by key.\n   * If a languageManager is provided and contains the key, it returns the localized value.\n   * Otherwise, returns the defaultValue.\n   *\n   * @param {string} key - The localization key.\n   * @param {string} defaultValue - The fallback value if no localization is found.\n   * @returns {string} Localized string.\n   */\n  getLocalizedString(key, defaultValue) {\n    if (this.languageManager && this.languageManager.locales && typeof this.languageManager.getLanguage === 'function') {\n      const lang = this.languageManager.getLanguage();\n      if (this.languageManager.locales[lang] && this.languageManager.locales[lang][key]) {\n        return this.languageManager.locales[lang][key];\n      }\n    }\n    return defaultValue;\n  }\n\n  /**\n   * Initializes the ChatManager by fetching the chat template fragment,\n   * rendering it using the TemplateEngine with initial data (loading messages from DB if available),\n   * and inserting it into the chat section in index.html.\n   * Also initializes the conversation if not marked as completed.\n   *\n   * @returns {Promise<void>}\n   */\n  async init() {\n    try {\n      // Fetch the chat template fragment.\n      const response = await fetch(this.templateUrl);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch template from ${this.templateUrl}`);\n      }\n      const templateText = await response.text();\n\n      // Load saved messages from the DatabaseManager.\n      let messagesStr = \"\";\n      if (this.databaseManager) {\n        const chatMessages = this.databaseManager.getChatMessages();\n        if (chatMessages && chatMessages.length > 0) {\n          messagesStr = chatMessages.map(msg => `<div class=\"chat-message ${msg.sender}\" style=\"margin-bottom: 0.5rem; padding: 0.5rem; border-radius: 4px; max-width: 80%; word-wrap: break-word;\">${msg.message}</div>`).join(\"\");\n        }\n      }\n\n      // Get localized string for the spirit board content.\n      const localizedSpiritBoardContent = this.getLocalizedString('spirit_board', 'Spirit Board');\n\n      // Render the template.\n      const data = {\n        messages: messagesStr,\n        spiritBoardContent: localizedSpiritBoardContent,\n        options: '' // Initially no dialogue options.\n      };\n      const renderedHTML = _utils_TemplateEngine_js__WEBPACK_IMPORTED_MODULE_1__.TemplateEngine.render(templateText, data);\n\n      // Insert rendered HTML into chat container.\n      this.container = document.getElementById('chat-section');\n      if (!this.container) {\n        throw new Error('Chat section container (id=\"chat-section\") not found in index.html');\n      }\n      this.container.innerHTML = renderedHTML;\n      this.container.style.display = 'none';\n\n      // If mode is 'board-only', hide the options container.\n      if (this.mode === 'board-only') {\n        const optionsEl = this.container.querySelector('#chat-options');\n        if (optionsEl) {\n          optionsEl.style.display = 'none';\n        }\n      }\n      console.log('ChatManager initialized.');\n\n      // --- Resume conversation only if it was started and not completed,\n      // and only if no messages are currently shown (to avoid duplicate append) ---\n      if (!this.isConversationActive()) {\n        try {\n          const module = await __webpack_require__.e(/*! import() */ \"src_managers_ChatScenarioManager_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./ChatScenarioManager.js */ \"./src/managers/ChatScenarioManager.js\"));\n          this.scenarioManager = new module.ChatScenarioManager(this, null);\n          await this.scenarioManager.init();\n        } catch (e) {\n          console.error(\"Failed to resume ChatScenarioManager:\", e);\n        }\n      } else {\n        console.log(\"Conversation already active; skipping dialogue load to prevent duplicates.\");\n      }\n    } catch (error) {\n      console.error('Error initializing ChatManager:', error);\n    }\n  }\n\n  /**\n   * Returns true if a conversation is already active,\n   * i.e. the chat has been started and there are messages in the chat.\n   *\n   * @returns {boolean}\n   */\n  isConversationActive() {\n    const conversationStarted = _StateManager_js__WEBPACK_IMPORTED_MODULE_3__.StateManager.get(this.getStateKey('chat_started')) === 'true';\n    const messagesEl = this.container && this.container.querySelector('#chat-messages');\n    const hasMessages = messagesEl && messagesEl.children.length > 0;\n    return conversationStarted && hasMessages;\n  }\n\n  /**\n   * Shows the chat section.\n   */\n  show() {\n    if (this.container) {\n      this.container.style.display = 'block';\n      console.log('ChatManager is now visible.');\n    }\n  }\n\n  /**\n   * Hides the chat section.\n   */\n  hide() {\n    if (this.container) {\n      this.container.style.display = 'none';\n      console.log('ChatManager is now hidden.');\n    }\n  }\n\n  /**\n   * Sends an initial localized message to the chat.\n   *\n   * @param {string} localizedText - The text to send.\n   */\n  sendInitialMessage(localizedText) {\n    if (!this.container) {\n      console.error('ChatManager is not initialized.');\n      return;\n    }\n    const messagesEl = this.container.querySelector('#chat-messages');\n    if (messagesEl) {\n      const messageHTML = `<div class=\"chat-message spirit\" style=\"margin-bottom: 0.5rem; padding: 0.5rem; border-radius: 4px; max-width: 80%; word-wrap: break-word;\">${localizedText}</div>`;\n      messagesEl.innerHTML += messageHTML;\n      console.log('Initial message sent:', localizedText);\n    }\n  }\n\n  /**\n   * Saves a chat message using the DatabaseManager.\n   * @param {Object} msg - An object with properties: sender and text.\n   */\n  async saveMessage(msg) {\n    if (this.databaseManager && typeof this.databaseManager.addChatMessage === 'function') {\n      await this.databaseManager.addChatMessage(msg.sender, msg.text);\n      console.log(`Message saved: [${msg.sender}] ${msg.text}`);\n    }\n  }\n\n  /**\n   * Loads a dialogue configuration and updates the chat content.\n   *\n   * The expected dialogueConfig format:\n   * {\n   *   messages: [\n   *     { sender: 'spirit'|'user', text: '...', animateOnBoard: true|false },\n   *     ...\n   *   ],\n   *   options: [\n   *     { text: 'Option 1', onSelect: function },\n   *     ...\n   *   ]\n   * }\n   *\n   * @param {Object} dialogueConfig - The dialogue configuration object.\n   */\n  async loadDialogue(dialogueConfig) {\n    if (!this.container) {\n      console.error('ChatManager is not initialized.');\n      return;\n    }\n    let messagesHTML = '';\n    for (const msg of dialogueConfig.messages) {\n      // Get localized message text if available.\n      const localizedMsg = this.getLocalizedString(msg.text, msg.text);\n      messagesHTML += `<div class=\"chat-message ${msg.sender}\" style=\"margin-bottom: 0.5rem; padding: 0.5rem; border-radius: 4px; max-width: 80%; word-wrap: break-word;\">${localizedMsg}</div>`;\n      if (msg.animateOnBoard) {\n        const boardEl = this.container.querySelector('#spirit-board');\n        if (boardEl) {\n          (0,_utils_SpiritBoardUtils_js__WEBPACK_IMPORTED_MODULE_2__.animateText)(boardEl, localizedMsg);\n        }\n      }\n      await this.saveMessage({\n        sender: msg.sender,\n        text: localizedMsg\n      });\n    }\n    const messagesEl = this.container.querySelector('#chat-messages');\n    if (messagesEl) {\n      // Append new messages (history is preserved).\n      messagesEl.innerHTML += messagesHTML;\n    }\n\n    // Update dialogue options using the new method.\n    this.updateDialogueOptions(dialogueConfig.options);\n    const boardEl = this.container.querySelector('#spirit-board');\n    if (boardEl) {\n      boardEl.innerHTML = '';\n    }\n    console.log('Dialogue loaded in ChatManager.');\n  }\n\n  /**\n   * Updates the dialogue options block with the given options array.\n   * This method re-renders the options block with localized option texts\n   * and attaches click event listeners for each option.\n   *\n   * @param {Array} options - Array of dialogue option objects.\n   */\n  updateDialogueOptions(options) {\n    const optionsEl = this.container.querySelector('#chat-options');\n    if (optionsEl) {\n      let optionsHTML = '';\n      if (options && options.length > 0) {\n        options.forEach((option, index) => {\n          // Get localized option text if available.\n          const localizedOptionText = this.getLocalizedString(option.text, option.text);\n          optionsHTML += `<button class=\"button is-link dialogue-option\" style=\"margin-bottom: 0.5rem;\">${localizedOptionText}</button>`;\n        });\n      }\n      // Set maxHeight if there are many options.\n      if (options && options.length > 3) {\n        optionsEl.style.maxHeight = '200px';\n        optionsEl.style.overflowY = 'auto';\n      } else {\n        optionsEl.style.maxHeight = '';\n        optionsEl.style.overflowY = '';\n      }\n      // Replace options to show current choices.\n      optionsEl.innerHTML = optionsHTML;\n\n      // Attach click event listeners to each option.\n      const optionButtons = optionsEl.querySelectorAll('.dialogue-option');\n      optionButtons.forEach((btn, index) => {\n        btn.addEventListener('click', () => {\n          if (this.scenarioManager && typeof this.scenarioManager.advanceDialogue === 'function') {\n            this.scenarioManager.advanceDialogue(index);\n          } else {\n            const option = options[index];\n            console.log(`Option selected: ${option.text}`);\n          }\n        });\n      });\n      console.log('Dialogue options updated in ChatManager.');\n    } else {\n      console.error('Options container not found in ChatManager.');\n    }\n  }\n\n  /**\n   * Sets the display mode for the chat.\n   *\n   * @param {string} mode - 'full' for full chat, or 'board-only' for only the spirit board.\n   */\n  setMode(mode) {\n    this.mode = mode;\n    if (this.container) {\n      const optionsEl = this.container.querySelector('#chat-options');\n      if (mode === 'board-only' && optionsEl) {\n        optionsEl.style.display = 'none';\n      } else if (optionsEl) {\n        optionsEl.style.display = 'block';\n      }\n    }\n    console.log(`ChatManager mode set to: ${mode}`);\n  }\n\n  /**\n   * Resets the current conversation by clearing saved state and reinitializing the dialogue.\n   * This allows for independent conversation sessions without restarting the entire chat.\n   */\n  async restartConversation() {\n    // Mark conversation as started.\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_3__.StateManager.set(this.getStateKey('chat_started'), 'true');\n    // Clear conversation state in StateManager.\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_3__.StateManager.remove(this.getStateKey('chat_conversation_completed'));\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_3__.StateManager.remove(this.getStateKey('chat_currentDialogueIndex'));\n\n    // Clear chat messages container to prevent duplicate messages.\n    if (this.container) {\n      const messagesEl = this.container.querySelector('#chat-messages');\n      if (messagesEl) {\n        messagesEl.innerHTML = '';\n      }\n    }\n\n    // Reinitialize the scenario manager to start the dialogue from the beginning.\n    try {\n      const module = await __webpack_require__.e(/*! import() */ \"src_managers_ChatScenarioManager_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./ChatScenarioManager.js */ \"./src/managers/ChatScenarioManager.js\"));\n      this.scenarioManager = new module.ChatScenarioManager(this, null);\n      await this.scenarioManager.init();\n      console.log('Conversation restarted for section:', this.sectionKey || '(global)');\n    } catch (e) {\n      console.error(\"Failed to restart conversation:\", e);\n    }\n  }\n\n  /**\n   * Schedules a conversation restart after a specified delay.\n   * Automatically checks if a conversation is already active and aborts restart if so.\n   *\n   * @param {number} delay - Delay in milliseconds before restarting the conversation (default: 5000 ms).\n   */\n  scheduleConversationStartIfInactive(delay = 5000) {\n    setTimeout(() => {\n      if (!this.isConversationActive()) {\n        this.restartConversation();\n      } else {\n        console.log('Conversation is already active; restart aborted.');\n      }\n    }, delay);\n    console.log(`Conversation restart scheduled in ${delay} ms.`);\n  }\n\n  /**\n   * Clears the chat state.\n   * If a sectionKey is provided as an argument, clears only that section.\n   * Otherwise, clears the global chat state.\n   *\n   * @param {string} [sectionKey] - Optional section key to clear.\n   */\n  clearChat(sectionKey) {\n    const prefix = sectionKey ? `${sectionKey}_` : '';\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_3__.StateManager.remove(`${prefix}chat_started`);\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_3__.StateManager.remove(`${prefix}chat_currentDialogueIndex`);\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_3__.StateManager.remove(`${prefix}chat_conversation_completed`);\n    console.log(`Chat cleared for section: ${sectionKey || 'global'}`);\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/ChatManager.js?");

/***/ }),

/***/ "./src/managers/DatabaseManager.js":
/*!*****************************************!*\
  !*** ./src/managers/DatabaseManager.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DatabaseManager: () => (/* binding */ DatabaseManager)\n/* harmony export */ });\n/* harmony import */ var _SQLiteDataManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SQLiteDataManager.js */ \"./src/managers/SQLiteDataManager.js\");\n/* harmony import */ var _config_paths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/paths.js */ \"./src/config/paths.js\");\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n\n\n\n\n/**\n * DatabaseManager\n *\n * Responsible for managing the SQL database which stores:\n * - Diary entries\n * - Apartment plans\n * - Quest progress\n * - Ghost states\n * - Events\n * - Quests\n * - Chat messages (new)\n *\n * It uses SQLiteDataManager for persistence (IndexedDB) and ensures that\n * entries (such as diary entries) are stored in a way that the event key checks\n * (via isEventLogged) work correctly.\n */\nclass DatabaseManager {\n  /**\n   * Constructor for DatabaseManager.\n   * @param {SQLiteDataManager} dataManager - Instance for persistence operations.\n   */\n  constructor(dataManager) {\n    this.dataManager = dataManager; // Reference to the DataManager\n    // The SQL.js database instance will be stored here.\n    this.db = null;\n    // A Promise that resolves after the database has been initialized.\n    this.initDatabasePromise = this.initDatabase();\n  }\n\n  /**\n   * initDatabase – Asynchronously initializes the database.\n   * Restores the database from persistence if available;\n   * otherwise creates a new database instance and sets up the required tables.\n   * Tables: diary, apartment_plan, quest_progress, ghosts, events, quests.\n   */\n  async initDatabase() {\n    try {\n      // Load SQL.js, providing a locateFile function to find necessary files.\n      const SQL = await initSqlJs({\n        locateFile: file => `${_config_paths_js__WEBPACK_IMPORTED_MODULE_1__.BASE_PATH}/assets/libs/db/${file}`\n      });\n\n      // Restore database from IndexedDB if saved, otherwise create a new instance.\n      this.db = await this.dataManager.initDatabase(SQL);\n      console.log(\"📖 Database initialized!\");\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(error, \"DatabaseManager.initDatabase\");\n    }\n  }\n\n  /**\n   * saveDatabase – Exports the database to a base64 string and persists it via the DataManager.\n   */\n  async saveDatabase() {\n    if (!this.db) return;\n    const binaryData = this.db.export();\n    let binaryStr = \"\";\n    for (let i = 0; i < binaryData.length; i++) {\n      binaryStr += String.fromCharCode(binaryData[i]);\n    }\n    const base64 = btoa(binaryStr);\n    await this.dataManager.saveDatabase(base64);\n    console.log(\"Database saved (persisted) successfully.\");\n  }\n\n  /**\n   * addDiaryEntry – Adds a new entry to the diary table.\n   * The entry is stored as a JSON string containing an \"entry\" property and a \"postClass\" property.\n   * This format ensures that isEventLogged (which checks the \"entry\" field) works correctly.\n   *\n   * @param {string} entry - The text of the entry (usually a key or message).\n   */\n  async addDiaryEntry(entry) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"addDiaryEntry\");\n      return;\n    }\n    const timestamp = new Date().toISOString();\n    this.db.run(\"INSERT INTO diary (entry, timestamp) VALUES (?, ?)\", [entry, timestamp]);\n    console.log(\"✅ Entry added:\", entry);\n    await this.saveDatabase();\n  }\n\n  /**\n   * getDiaryEntries – Returns an array of diary entries sorted by descending timestamp.\n   * Each entry is parsed from JSON, so that the \"entry\" property can be used for comparisons.\n   *\n   * @returns {Array} Array of entry objects: { id, entry, postClass, timestamp }.\n   */\n  getDiaryEntries() {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"getDiaryEntries\");\n      return [];\n    }\n    const result = this.db.exec(\"SELECT * FROM diary ORDER BY timestamp DESC\");\n    if (result.length > 0) {\n      return result[0].values.map(row => {\n        let parsed;\n        try {\n          parsed = JSON.parse(row[1]);\n        } catch (e) {\n          // Fallback: if parsing fails, assume a plain entry.\n          parsed = {\n            entry: row[1],\n            postClass: \"user-post\"\n          };\n          _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(e, \"getDiaryEntries JSON.parse\");\n        }\n        return {\n          id: row[0],\n          ...parsed,\n          timestamp: row[2]\n        };\n      });\n    }\n    return [];\n  }\n\n  /**\n   * addQuestProgress – Adds a quest progress record to the quest_progress table.\n   *\n   * @param {string} questKey - The key of the quest.\n   * @param {string} status - The status of the quest.\n   */\n  addQuestProgress(questKey, status) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"addQuestProgress\");\n      return;\n    }\n    this.db.run(\"INSERT INTO quest_progress (quest_key, status) VALUES (?, ?)\", [questKey, status]);\n    console.log(`✅ Quest progress added: ${questKey} - ${status}`);\n    this.saveDatabase();\n  }\n\n  /**\n   * getQuestProgress – Returns an array of progress records for the specified quest.\n   *\n   * @param {string} questKey - The key of the quest.\n   * @returns {Array} Array of progress objects: { id, quest_key, status }.\n   */\n  getQuestProgress(questKey) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"getQuestProgress\");\n      return null;\n    }\n    const result = this.db.exec(\"SELECT * FROM quest_progress WHERE quest_key = ?\", [questKey]);\n    if (result.length > 0) {\n      return result[0].values.map(row => ({\n        id: row[0],\n        quest_key: row[1],\n        status: row[2]\n      }));\n    }\n    return [];\n  }\n\n  /**\n   * addApartmentRooms – Saves the apartment plan data for the specified floor.\n   *\n   * @param {number} floor - The floor number.\n   * @param {Array} rooms - An array of room objects.\n   */\n  addApartmentRooms(floor, rooms) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"addApartmentRooms\");\n      return;\n    }\n    const roomData = JSON.stringify(rooms);\n    this.db.run(\"DELETE FROM apartment_plan WHERE floor_number = ?\", [floor]);\n    this.db.run(\"INSERT INTO apartment_plan (floor_number, room_data) VALUES (?, ?)\", [floor, roomData]);\n    console.log(`✅ Apartment plan for floor ${floor} saved.`);\n    this.saveDatabase();\n  }\n\n  /**\n   * getApartmentPlan – Returns the apartment plan data for the specified floor.\n   *\n   * @param {number} floor - The floor number.\n   * @param {function} callback - Callback function receiving the plan data array.\n   */\n  getApartmentPlan(floor, callback) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"getApartmentPlan\");\n      callback([]);\n      return;\n    }\n    const result = this.db.exec(\"SELECT room_data FROM apartment_plan WHERE floor_number = ? ORDER BY id\", [floor]);\n    if (result.length > 0) {\n      const rooms = result[0].values.map(row => {\n        try {\n          return JSON.parse(row[0]);\n        } catch (e) {\n          _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(e, \"getApartmentPlan JSON.parse\");\n          return row[0];\n        }\n      });\n      callback(rooms);\n    } else {\n      callback([]);\n    }\n  }\n\n  // ===== Methods for ghosts, events, and quests =====\n\n  /**\n   * saveGhostState – Saves or updates the ghost state in the ghosts table.\n   *\n   * @param {Object} ghost - Ghost object containing id (optional), name, status, progress.\n   */\n  saveGhostState(ghost) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"saveGhostState\");\n      return;\n    }\n    this.db.run(`INSERT OR REPLACE INTO ghosts (id, name, status, progress)\n       VALUES ((SELECT id FROM ghosts WHERE id = ?), ?, ?, ?)`, [ghost.id || null, ghost.name, ghost.status || \"\", ghost.progress || 0]);\n    console.log(\"✅ Ghost state saved:\", ghost);\n    this.saveDatabase();\n  }\n\n  /**\n   * getGhostState – Retrieves the ghost state by ghost id.\n   *\n   * @param {number} ghostId - The ID of the ghost.\n   * @returns {Object|null} The ghost object or null if not found.\n   */\n  getGhostState(ghostId) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"getGhostState\");\n      return null;\n    }\n    const result = this.db.exec(\"SELECT * FROM ghosts WHERE id = ?\", [ghostId]);\n    if (result.length > 0) {\n      const row = result[0].values[0];\n      return {\n        id: row[0],\n        name: row[1],\n        status: row[2],\n        progress: row[3]\n      };\n    }\n    return null;\n  }\n\n  /**\n   * saveEvent – Saves an event record in the events table.\n   *\n   * @param {Object} eventData - Object with properties: event_key, event_text, timestamp, completed (0 or 1).\n   */\n  saveEvent(eventData) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"saveEvent\");\n      return;\n    }\n    this.db.run(`INSERT INTO events (event_key, event_text, timestamp, completed)\n       VALUES (?, ?, ?, ?)`, [eventData.event_key, eventData.event_text, eventData.timestamp, eventData.completed ? 1 : 0]);\n    console.log(\"✅ Event saved:\", eventData);\n    this.saveDatabase();\n  }\n\n  /**\n   * getEvents – Retrieves all event records from the events table.\n   *\n   * @returns {Array} An array of event objects.\n   */\n  getEvents() {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"getEvents\");\n      return [];\n    }\n    const result = this.db.exec(\"SELECT * FROM events ORDER BY timestamp DESC\");\n    if (result.length > 0) {\n      return result[0].values.map(row => ({\n        id: row[0],\n        event_key: row[1],\n        event_text: row[2],\n        timestamp: row[3],\n        completed: row[4] === 1\n      }));\n    }\n    return [];\n  }\n\n  /**\n   * saveQuestRecord – Saves or updates a quest record in the quests table.\n   *\n   * @param {Object} questData - Object with properties: quest_key, status, current_stage, total_stages.\n   */\n  saveQuestRecord(questData) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"saveQuestRecord\");\n      return;\n    }\n    this.db.run(`INSERT OR REPLACE INTO quests (id, quest_key, status, current_stage, total_stages)\n       VALUES ((SELECT id FROM quests WHERE quest_key = ?), ?, ?, ?, ?)`, [questData.quest_key, questData.quest_key, questData.status, questData.current_stage, questData.total_stages]);\n    console.log(\"✅ Quest record saved:\", questData);\n    this.saveDatabase();\n  }\n\n  /**\n   * getQuestRecord – Retrieves a quest record by quest key.\n   *\n   * @param {string} questKey - The key of the quest.\n   * @returns {Object|null} The quest record or null if not found.\n   */\n  getQuestRecord(questKey) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"getQuestRecord\");\n      return null;\n    }\n    const result = this.db.exec(\"SELECT * FROM quests WHERE quest_key = ?\", [questKey]);\n    if (result.length > 0) {\n      const row = result[0].values[0];\n      return {\n        id: row[0],\n        quest_key: row[1],\n        status: row[2],\n        current_stage: row[3],\n        total_stages: row[4]\n      };\n    }\n    return null;\n  }\n\n  // ===== New Methods for Chat Integration =====\n\n  /**\n   * addChatMessage – Inserts a new chat message record into the chat_messages table.\n   *\n   * @param {string} sender - The sender of the message (e.g., 'user' or 'spirit').\n   * @param {string} message - The chat message text.\n   * @param {string} [timestamp] - Optional timestamp; if not provided, current ISO string is used.\n   */\n  addChatMessage(sender, message, timestamp = new Date().toISOString()) {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"addChatMessage\");\n      return;\n    }\n    this.db.run(\"INSERT INTO chat_messages (sender, message, timestamp) VALUES (?, ?, ?)\", [sender, message, timestamp]);\n    console.log(`✅ Chat message added: [${sender}] ${message}`);\n    this.saveDatabase();\n  }\n\n  /**\n   * getChatMessages – Retrieves all chat message records from the chat_messages table.\n   *\n   * @returns {Array} Array of chat message objects: { id, sender, message, timestamp }.\n   */\n  getChatMessages() {\n    if (!this.db) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Database not initialized!\", \"getChatMessages\");\n      return [];\n    }\n    const result = this.db.exec(\"SELECT * FROM chat_messages ORDER BY timestamp ASC\");\n    if (result.length > 0) {\n      return result[0].values.map(row => ({\n        id: row[0],\n        sender: row[1],\n        message: row[2],\n        timestamp: row[3]\n      }));\n    }\n    return [];\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/DatabaseManager.js?");

/***/ }),

/***/ "./src/managers/ErrorManager.js":
/*!**************************************!*\
  !*** ./src/managers/ErrorManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorManager: () => (/* binding */ ErrorManager)\n/* harmony export */ });\n/* harmony import */ var _NotificationManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NotificationManager.js */ \"./src/managers/NotificationManager.js\");\n\n\n/**\n * ErrorManager\n *\n * Centralized module for logging errors and displaying error notifications.\n * All errors in the application should be handled using logError and showError.\n */\nclass ErrorManager {\n  /**\n   * Logs an error with optional contextual information.\n   *\n   * @param {any} error - The error object or message.\n   * @param {string} [context] - Optional context indicating where the error occurred.\n   */\n  static logError(error, context = \"\") {\n    console.error(`Error${context ? \" in \" + context : \"\"}:`, error);\n  }\n\n  /**\n   * Displays an error notification to the user.\n   * Uses NotificationManager to show the error message.\n   *\n   * @param {string} message - The error message to display.\n   */\n  static showError(message) {\n    const notificationManager = new _NotificationManager_js__WEBPACK_IMPORTED_MODULE_0__.NotificationManager();\n    notificationManager.showNotification(message);\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/ErrorManager.js?");

/***/ }),

/***/ "./src/managers/EventManager.js":
/*!**************************************!*\
  !*** ./src/managers/EventManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventManager: () => (/* binding */ EventManager)\n/* harmony export */ });\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n\n\n/**\n * EventManager\n * Responsible for handling diary (log) operations and recording system events.\n * - Adds diary entries (both user and ghost posts).\n * - Delegates the diary UI update to ViewManager.\n * - Can trigger short events (e.g., ghost quests) if needed.\n *\n * NOTE: The sequential linking of events is managed by GhostManager.\n */\nclass EventManager {\n  /**\n   * @param {DatabaseManager} databaseManager - Instance of the database manager.\n   * @param {LanguageManager} languageManager - Localization manager.\n   * @param {GhostManager} ghostManager - Manager handling ghost-related operations.\n   * @param {VisualEffectsManager} visualEffectsManager - Manager handling visual effects.\n   *\n   * Note: The viewManager reference is expected to be set externally (e.g. in App.js).\n   */\n  constructor(databaseManager, languageManager, ghostManager, visualEffectsManager) {\n    this.databaseManager = databaseManager;\n    this.languageManager = languageManager;\n    this.ghostManager = ghostManager;\n    this.visualEffectsManager = visualEffectsManager;\n    // viewManager is assigned externally after instantiation.\n  }\n\n  /**\n   * isEventLogged\n   * Checks whether an entry with the given event key has already been logged.\n   * This method compares the stored entry key with the provided key.\n   *\n   * @param {string} eventKey - The event key to check.\n   * @returns {boolean} True if the event is already logged, otherwise false.\n   */\n  isEventLogged(eventKey) {\n    const entries = this.databaseManager.getDiaryEntries();\n    // Compare the stored entry key with the provided key.\n    return entries.some(entry => entry.entry === eventKey);\n  }\n\n  /**\n   * addDiaryEntry\n   * Adds an entry to the diary. It constructs an object with the entry text and post type,\n   * serializes it as JSON, and saves it to the database. If the entry represents a system event\n   * (e.g., from a ghost), it is additionally saved to the events table.\n   *\n   * After saving, it delegates the UI update (diary rendering) to the ViewManager.\n   * Then, it calls the centralized visual effects method to animate the newly added entry.\n   *\n   * @param {string} entry - The text of the diary entry.\n   * @param {boolean} [isPostFromGhost=false] - Flag to mark the entry as a ghost post.\n   */\n  async addDiaryEntry(entry, isPostFromGhost = false) {\n    // Determine post class based on the source.\n    const postClass = isPostFromGhost ? \"ghost-post\" : \"user-post\";\n    const entryData = {\n      entry,\n      postClass\n    };\n    const serializedEntry = JSON.stringify(entryData);\n\n    // Save the diary entry to the database.\n    await this.databaseManager.addDiaryEntry(serializedEntry);\n\n    // If this is a system event (ghost post), also record it in the events table.\n    if (isPostFromGhost) {\n      const eventData = {\n        event_key: entry,\n        event_text: entry,\n        timestamp: new Date().toISOString(),\n        completed: 0\n      };\n      this.databaseManager.saveEvent(eventData);\n    }\n\n    // Delegate UI update of the diary to the ViewManager.\n    if (this.viewManager?.addSingleDiaryPost) {\n      this.viewManager.addSingleDiaryPost({\n        text: entry,\n        // original message\n        img: entry.startsWith(\"data:image\") ? entry : \"\",\n        // best‑effort\n        timestamp: new Date().toLocaleString(),\n        postClass\n      });\n    } else {\n      this.updateDiaryDisplay();\n    }\n\n    // After updating the diary display, apply visual effects to newly added diary entries.\n    // It is expected that the rendered diary entries have the attribute data-animate-on-board=\"true\"\n    // if they need to be animated.\n    if (this.viewManager && this.visualEffectsManager && this.viewManager.diaryContainer) {\n      const newEntries = this.viewManager.diaryContainer.querySelectorAll('[data-animate-on-board=\"true\"]');\n      this.visualEffectsManager.applyEffectsToNewElements(newEntries);\n    }\n  }\n\n  /**\n   * updateDiaryDisplay\n   * Retrieves diary entries from the database and instructs the ViewManager\n   * to render them. Uses the current language from the LanguageManager.\n   */\n  updateDiaryDisplay() {\n    if (this.viewManager && typeof this.viewManager.renderDiary === 'function') {\n      const entries = this.databaseManager.getDiaryEntries();\n      const currentLanguage = this.languageManager.getLanguage();\n      // Delegate rendering of the diary entries to the ViewManager.\n      this.viewManager.renderDiary(entries, currentLanguage, this.visualEffectsManager);\n    } else {\n      // Log and display an error if the viewManager is not available.\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(\"ViewManager is not available. Cannot update diary display.\", \"updateDiaryDisplay\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.showError(\"Unable to update diary display.\");\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/EventManager.js?");

/***/ }),

/***/ "./src/managers/GameEventManager.js":
/*!******************************************!*\
  !*** ./src/managers/GameEventManager.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameEventManager: () => (/* binding */ GameEventManager)\n/* harmony export */ });\n/* harmony import */ var _StateManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n/* harmony import */ var _utils_GameEntityLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/GameEntityLoader.js */ \"./src/utils/GameEntityLoader.js\");\n// File: src/managers/GameEventManager.js\n\n\n\n\n\n/**\n * GameEventManager class\n * \n * Manages one-time game events. It loads event definitions dynamically from\n * a unified JSON configuration. The configuration (including event class names,\n * dependencies and keys) is defined entirely in the config file.\n *\n * NOTE: Sequential linking of events and quests is now handled by GhostManager and QuestManager.\n */\nclass GameEventManager {\n  /**\n   * @param {EventManager} eventManager - Manager for diary/event operations.\n   * @param {App} appInstance - The main application instance.\n   * @param {LanguageManager} languageManager - Localization manager.\n   */\n  constructor(eventManager, appInstance, languageManager) {\n    this.eventManager = eventManager;\n    this.app = appInstance;\n    this.languageManager = languageManager;\n    this.events = [];\n\n    // Load the unified configuration and instantiate only those events\n    // whose keys appear in the \"sequence\" array.\n    (0,_utils_GameEntityLoader_js__WEBPACK_IMPORTED_MODULE_2__.loadGameEntitiesConfig)().then(async config => {\n      // Build a Set of all eventKeys that are part of the sequence\n      const sequenceKeys = new Set(config.sequence.map(triad => triad.eventKey));\n\n      // Build a lookup from eventKey to its corresponding config object\n      const eventConfigByKey = {};\n      for (const ev of config.events) {\n        eventConfigByKey[ev.key] = ev;\n      }\n\n      // For each eventKey in the sequence, create one instance\n      for (const eventKey of sequenceKeys) {\n        const eventCfg = eventConfigByKey[eventKey];\n        if (!eventCfg) {\n          _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`No event configuration found for key \"${eventKey}\" in sequence.`, \"GameEventManager\");\n          continue;\n        }\n\n        // Build params for constructor: [eventManager, app, config, languageManager]\n        const params = [this.eventManager, this.app, eventCfg, this.languageManager];\n        try {\n          // Dynamically import the triad bundle for this eventKey via alias \"triads\"\n          const module = await __webpack_require__(\"./build/triads lazy recursive ^\\\\.\\\\/triad\\\\-.*$\")(`./triad-${eventKey}`);\n          const EventClass = module[eventCfg.className];\n          if (!EventClass) {\n            _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`Event class \"${eventCfg.className}\" is not exported from triads/triad-${eventKey}.js.`, \"GameEventManager\");\n            continue;\n          }\n          // Pass config object as third argument\n          const instance = new EventClass(...params);\n          this.events.push(instance);\n        } catch (error) {\n          _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`Failed to import triad for event \"${eventKey}\": ${error.message}`, \"GameEventManager\");\n        }\n      }\n      console.log(\"Game events loaded from sequence:\", this.events.map(e => e.key));\n    }).catch(error => {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(error, \"GameEventManager.loadConfig\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.showError(\"Failed to load game events configuration\");\n    });\n  }\n\n  /**\n   * Activates an event by its key.\n   * @param {string} key - The event key.\n   */\n  async activateEvent(key) {\n    let event = this.events.find(e => e.key === key);\n    // Fallback for dynamic keys (e.g. \"post_repeating_event_stage_X\")\n    if (!event && key.startsWith(\"post_repeating_event\")) {\n      event = this.events.find(e => e.key === \"post_repeating_event\");\n    }\n    if (event) {\n      await event.activate(key);\n      console.log(`Event '${key}' activated.`);\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`Event \"${key}\" not found`, \"GameEventManager.activateEvent\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.showError(`Cannot activate event \"${key}\"`);\n    }\n  }\n\n  /**\n   * Automatically launches the welcome event (after 5 seconds) post-registration,\n   * if the \"welcomeDone\" flag is not set.\n   */\n  async autoLaunchWelcomeEvent() {\n    if (_StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.get(_StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.KEYS.WELCOME_DONE) === \"true\") {\n      console.log(\"Welcome event already completed; auto-launch skipped.\");\n      return;\n    }\n    console.log(\"Auto-launching welcome event in 5 seconds...\");\n    setTimeout(async () => {\n      await this.activateEvent(\"welcome\");\n    }, 5000);\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/GameEventManager.js?");

/***/ }),

/***/ "./src/managers/GhostManager.js":
/*!**************************************!*\
  !*** ./src/managers/GhostManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GhostManager: () => (/* binding */ GhostManager)\n/* harmony export */ });\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n/* harmony import */ var _StateManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _utils_GameEntityLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/GameEntityLoader.js */ \"./src/utils/GameEntityLoader.js\");\n/* harmony import */ var _utils_SequenceManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/SequenceManager.js */ \"./src/utils/SequenceManager.js\");\n// File: src/managers/GhostManager.js\n\n\n\n\n\n\n/**\n * GhostManager class\n * \n * Manages the list of ghosts and their state. Responsibilities include:\n * - Maintaining the active ghost and tracking its phenomenon (quest step) progress.\n * - Saving ghost state via DatabaseManager.\n * - Triggering events (e.g., final event) via GameEventManager.\n *\n * NEW CHANGES:\n * - The event–quest sequence is now loaded from a unified JSON configuration.\n * - The active quest key is stored persistently using StateManager.\n * - A unified method 'canStartQuest' is provided to check if a quest can start:\n *    1. A non-finished quest record does not exist.\n *    2. There is no active quest registered in the StateManager.\n *    3. The quest key matches the expected next quest in the sequence.\n * - Auto-launch of the first event (e.g., \"welcome\") is performed if registration is complete.\n * - Dynamic update of the Post button state added via updatePostButtonState():\n *    the button is enabled only if no quest is active.\n * - **New:** On starting a quest the camera button is set to active,\n *   and upon quest completion the active state (class) is removed.\n */\nclass GhostManager {\n  /**\n   * @param {number} currentSequenceIndex - Starting index for the event–quest sequence (from StateManager).\n   * @param {ProfileManager} profileManager - Manager for saving ghost progress.\n   * @param {App} app - The main application instance.\n   */\n  constructor(currentSequenceIndex, profileManager, app) {\n    // Set initial sequence index (will be updated after loading config).\n    this.currentSequenceIndex = currentSequenceIndex;\n    this.profileManager = profileManager;\n    this.app = app;\n\n    // In-memory flag for the active quest key (persisted in StateManager).\n    this.activeQuestKey = _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.getActiveQuestKey();\n    this.questActive = !!this.activeQuestKey; // true if an active quest key is stored.\n\n    // eventManager will be assigned externally (see App.js).\n    this.eventManager = null;\n\n    // Initialize ghost list with only the default ghost.\n    this.ghosts = [];\n    this.setupGhosts();\n\n    // Set the active ghost (default ID = 1).\n    this.currentGhostId = 1;\n    // Current phenomenon (quest step) index for the active ghost.\n    this.currentPhenomenonIndex = 0;\n    const currentGhost = this.getCurrentGhost();\n    console.log(`Current active ghost: ${currentGhost ? currentGhost.name : 'not found'}`);\n\n    // Load the unified configuration and initialize the sequence manager from the \"sequence\" section.\n    (0,_utils_GameEntityLoader_js__WEBPACK_IMPORTED_MODULE_2__.loadGameEntitiesConfig)().then(config => {\n      this.sequenceManager = new _utils_SequenceManager_js__WEBPACK_IMPORTED_MODULE_3__.SequenceManager(config.sequence);\n      const savedIndex = parseInt(_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.get(_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.CURRENT_SEQUENCE_INDEX), 10) || 0;\n      this.sequenceManager.currentIndex = savedIndex;\n      console.log(`Sequence configuration loaded. Current index: ${this.sequenceManager.currentIndex}`);\n\n      // Auto-launch the first event if registration is complete and the welcome event has not been executed.\n      if (_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.get(\"registrationCompleted\") === \"true\" && _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.get(\"welcomeDone\") !== \"true\") {\n        const firstEntry = this.sequenceManager.getCurrentEntry();\n        if (firstEntry) {\n          console.log(`Auto-launching initial event: ${firstEntry.eventKey}`);\n          this.eventManager.activateEvent(firstEntry.eventKey);\n          // Save the active quest key using the universal mechanism.\n          this.activeQuestKey = firstEntry.questKey;\n          _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(\"activeQuestKey\", this.activeQuestKey);\n        }\n      }\n    }).catch(error => {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(error, \"GhostManager.loadConfig\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.showError(\"Failed to load game configuration\");\n    });\n\n    // Subscribe to global events for completions.\n    document.addEventListener(\"gameEventCompleted\", e => {\n      this.onEventCompleted(e.detail);\n    });\n    document.addEventListener(\"questCompleted\", e => {\n      this.onQuestCompleted(e.detail);\n    });\n  }\n\n  /**\n   * Generates the list of ghosts.\n   * CURRENT CHANGE: Only the default ghost is created.\n   */\n  setupGhosts() {\n    const defaultGhost = {\n      id: 1,\n      name: \"ghost 1\",\n      // Default ghost name.\n      phenomenaCount: 3,\n      // Fixed number of phenomena (quest steps).\n      isFinished: false\n    };\n    this.ghosts = [defaultGhost];\n  }\n\n  /**\n   * Returns the active ghost based on currentGhostId.\n   * @returns {object|undefined} The ghost object, or undefined if not found.\n   */\n  getCurrentGhost() {\n    return this.ghosts.find(g => g.id === this.currentGhostId);\n  }\n\n  /**\n   * Sets the active ghost by its ID and saves its state.\n   * @param {number} ghostId - The ID of the ghost to activate.\n   */\n  async setCurrentGhost(ghostId) {\n    this.currentGhostId = ghostId;\n    const ghost = this.getCurrentGhost();\n    if (ghost) {\n      console.log(`Ghost ${ghost.name} activated.`);\n      await this.app.databaseManager.saveGhostState(ghost);\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(`Ghost with ID=${ghostId} not found!`, \"setCurrentGhost\");\n    }\n  }\n\n  /**\n   * Marks the current ghost as finished and saves its state.\n   */\n  async finishCurrentGhost() {\n    const ghost = this.getCurrentGhost();\n    if (ghost) {\n      ghost.isFinished = true;\n      console.log(`Ghost ${ghost.name} finished.`);\n      await this.app.databaseManager.saveGhostState(ghost);\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(\"Cannot finish ghost: ghost not found.\", \"finishCurrentGhost\");\n    }\n  }\n\n  /**\n   * Checks if the current ghost is finished.\n   * @returns {boolean} True if finished; otherwise, false.\n   */\n  isCurrentGhostFinished() {\n    const ghost = this.getCurrentGhost();\n    return ghost ? ghost.isFinished : false;\n  }\n\n  /**\n   * Initiates the next phenomenon (quest step) for the current ghost.\n   * Adds a diary entry and updates progress. If all steps are complete, triggers the final event.\n   */\n  async triggerNextPhenomenon() {\n    const ghost = this.getCurrentGhost();\n    if (!ghost) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(\"No ghost found to trigger phenomenon.\", \"triggerNextPhenomenon\");\n      return;\n    }\n    if (ghost.isFinished) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(`Ghost \"${ghost.name}\" is already finished; phenomena unavailable.`, \"triggerNextPhenomenon\");\n      return;\n    }\n    if (this.currentPhenomenonIndex < ghost.phenomenaCount) {\n      const phenomenonNumber = this.currentPhenomenonIndex + 1;\n      const phenomenonEntry = `${ghost.name}: Phenomenon ${phenomenonNumber} - Approach the mirror`;\n      await this.eventManager.addDiaryEntry(phenomenonEntry);\n      console.log(`Triggered phenomenon for ${ghost.name}: ${phenomenonEntry}`);\n      this.currentPhenomenonIndex++;\n      await this.profileManager.saveGhostProgress({\n        ghostId: this.currentGhostId,\n        phenomenonIndex: this.currentPhenomenonIndex\n      });\n      if (this.currentPhenomenonIndex === ghost.phenomenaCount) {\n        const finalEntry = `${ghost.name}: Final phenomenon – ghost finished!`;\n        await this.eventManager.addDiaryEntry(finalEntry);\n        console.log(finalEntry);\n        console.log(`Triggering final event for ghost \"${ghost.name}\"...`);\n        await this.app.gameEventManager.activateEvent(\"ghost_final_event\");\n      }\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(`All phenomena for ghost ${ghost.name} have been completed (index=${this.currentPhenomenonIndex}).`, \"triggerNextPhenomenon\");\n    }\n  }\n\n  /**\n   * Resets the ghost chain: sets active ghost to default, resets phenomenon index,\n   * clears ghost progress, and updates the database.\n   */\n  async resetGhostChain() {\n    this.currentGhostId = 1;\n    this.currentPhenomenonIndex = 0;\n    await this.profileManager.resetGhostProgress();\n    console.log(\"Ghost chain has been reset.\");\n    const ghost = this.getCurrentGhost();\n    if (ghost) {\n      ghost.isFinished = false;\n      await this.app.databaseManager.saveGhostState(ghost);\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(\"Failed to reset ghost chain: default ghost not found.\", \"resetGhostChain\");\n    }\n  }\n\n  // --------------- New API: Sequential Event and Quest Management ---------------\n\n  /**\n   * Checks if the provided quest key matches the expected quest from the sequence configuration.\n   * @param {string} questKey - The quest key to check.\n   * @returns {boolean} True if it matches; otherwise, false.\n   */\n  isNextInSequence(questKey) {\n    return this.sequenceManager ? this.sequenceManager.isNextQuest(questKey) : false;\n  }\n\n  /**\n   * Checks if the provided event key matches the expected event from the sequence configuration.\n   * @param {string} eventKey - The event key to check.\n   * @returns {boolean} True if it matches; otherwise, false.\n   */\n  isNextEvent(eventKey) {\n    return this.sequenceManager ? this.sequenceManager.isNextEvent(eventKey) : false;\n  }\n\n  /**\n   * Determines if a quest can be started.\n   * Checks that there is no active unfinished record in the database, no active quest in the StateManager,\n   * and that the quest key is the next expected in the sequence.\n   * @param {string} questKey - The quest key to start.\n   * @returns {boolean} True if the quest can be launched; false otherwise.\n   */\n  canStartQuest(questKey) {\n    // 1) Check for an existing unfinished quest record.\n    const record = this.app.databaseManager.getQuestRecord(questKey);\n    if (record && record.status !== \"finished\") {\n      console.warn(`Quest \"${questKey}\" is already active with status \"${record.status}\".`);\n      return false;\n    }\n    // 2) Check if an active quest is already recorded.\n    const activeQuestKey = _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.getActiveQuestKey();\n    // Block if an active quest exists and it does not match the quest we're trying to start.\n    if (activeQuestKey && activeQuestKey !== questKey) {\n      console.warn(`Another quest \"${activeQuestKey}\" is already active, cannot start quest \"${questKey}\".`);\n      return false;\n    }\n    // 3) Check if this quest is the next expected in the sequence.\n    if (!this.isNextInSequence(questKey)) {\n      console.error(`Quest \"${questKey}\" is not the next expected quest in the sequence.`);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Starts a quest after verifying eligibility using the unified check.\n   * @param {string} questKey - The quest key to start.\n   */\n  async startQuest(questKey) {\n    if (!this.canStartQuest(questKey)) {\n      console.error(`Cannot start quest with key: ${questKey}. Unified check failed.`);\n      return;\n    }\n    console.log(`GhostManager: Starting quest with key: ${questKey}`);\n    await this.app.questManager.activateQuest(questKey);\n    // Update the active quest key universally.\n    this.activeQuestKey = questKey;\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.setActiveQuestKey(questKey);\n    await this.app.questManager.syncQuestState();\n    // When a quest starts, mark the camera button as active.\n    this.app.viewManager.setCameraButtonActive(true);\n  }\n\n  /**\n   * Starts an event.\n   * @param {string} eventKey - The event key to start.\n   * @param {boolean} [isFollowup=false] - If true, bypasses the sequence check.\n   */\n  async startEvent(eventKey, isFollowup = false) {\n    if (!isFollowup && !this.isNextEvent(eventKey)) {\n      console.error(`Event \"${eventKey}\" is not next in sequence.`);\n      return;\n    }\n    console.log(`GhostManager: Starting event with key: ${eventKey}`);\n    await this.app.gameEventManager.activateEvent(eventKey);\n  }\n\n  /**\n   * Updates the Post button state based on whether an active quest is present.\n   * If an active quest exists, the button is disabled; otherwise, it is enabled.\n   */\n  updatePostButtonState() {\n    // Получаем следующий элемент последовательности (или null)\n    const nextEntry = this.sequenceManager ? this.sequenceManager.getCurrentEntry() : null;\n    // Есть ли валидный questKey и можно ли его запустить?\n    const canStart = nextEntry ? this.canStartQuest(nextEntry.questKey) : false;\n    // Применяем к ViewManager\n    this.app.viewManager.setPostButtonEnabled(canStart);\n    console.log(`[GhostManager] Post button state updated: enabled=${canStart}`);\n  }\n\n  /**\n   * Handles the Post button click.\n   * Disables the button to prevent double-clicks, then either starts the next event\n   * directly (if there is no quest in this sequence entry) or starts the quest (if allowed).\n   */\n  async handlePostButtonClick() {\n    // Disable the Post button immediately to prevent double-clicks.\n    this.app.viewManager.setPostButtonEnabled(false);\n    const nextEntry = this.sequenceManager ? this.sequenceManager.getCurrentEntry() : null;\n    if (!nextEntry) {\n      console.warn(\"GhostManager: No next sequence entry found.\");\n      this.updatePostButtonState();\n      return;\n    }\n\n    // ----------------------------------------------------------\n    // Case 1: If this entry has no questKey (i.e., questKey === null),\n    // we activate the next event directly and do NOT advance the sequence index here,\n    // because onEventCompleted(...) will take care of incrementing exactly once.\n    if (nextEntry.questKey === null) {\n      if (nextEntry.nextEventKey) {\n        try {\n          console.log(`[GhostManager] No quest to start; activating event \"${nextEntry.nextEventKey}\" directly.`);\n          // Pass `true` to skip the normal sequence checks when starting the event\n          await this.startEvent(nextEntry.nextEventKey, true);\n        } catch (err) {\n          console.error(`[GhostManager] Failed to activate event \"${nextEntry.nextEventKey}\":`, err);\n        }\n      } else {\n        console.warn(\"[GhostManager] Both questKey and nextEventKey are null; nothing to activate.\");\n      }\n\n      // NOTE: We have removed the following manual increment() and StateManager.set():\n      // this.sequenceManager.increment();\n      // StateManager.set(StateManager.KEYS.CURRENT_SEQUENCE_INDEX, String(this.sequenceManager.currentIndex));\n      //\n      // By removing these lines, we ensure that the sequence index is incremented only once\n      // inside onEventCompleted(\"post_mirror_event\"), avoiding a double‐increment that\n      // would skip the repeating_quest stage.\n\n      // Update the Post button state for whatever is next.\n      this.updatePostButtonState();\n      return;\n    }\n\n    // ----------------------------------------------------------\n    // Case 2: Otherwise, attempt to start the quest if allowed.\n    console.log(`GhostManager: Handling Post button click. Next expected quest: \"${nextEntry.questKey}\".`);\n    if (!this.canStartQuest(nextEntry.questKey)) {\n      this.updatePostButtonState();\n      return;\n    }\n    await this.startQuest(nextEntry.questKey);\n    // After starting the quest, update the Post button state.\n    this.updatePostButtonState();\n  }\n\n  /**\n   * Handles the Post button click.\n   * Disables the button to prevent double-clicks, then either starts the next event\n   * directly (if there is no quest in this sequence entry) or starts the quest (if allowed).\n   */\n  async handlePostButtonClick() {\n    // Disable the Post button immediately to prevent double-clicks.\n    this.app.viewManager.setPostButtonEnabled(false);\n    const nextEntry = this.sequenceManager ? this.sequenceManager.getCurrentEntry() : null;\n    if (!nextEntry) {\n      console.warn(\"GhostManager: No next sequence entry found.\");\n      this.updatePostButtonState();\n      return;\n    }\n\n    // ----------------------------------------------------------\n    // Case 1: If this entry has no questKey (i.e., questKey === null),\n    // we activate the next event directly and do NOT advance the sequence index here,\n    // because onEventCompleted(...) will take care of incrementing exactly once.\n    if (nextEntry.questKey === null) {\n      if (nextEntry.nextEventKey) {\n        try {\n          console.log(`[GhostManager] No quest to start; activating event \"${nextEntry.nextEventKey}\" directly.`);\n          // Pass `true` to skip the normal sequence checks when starting the event\n          await this.startEvent(nextEntry.nextEventKey, true);\n        } catch (err) {\n          console.error(`[GhostManager] Failed to activate event \"${nextEntry.nextEventKey}\":`, err);\n        }\n      } else {\n        console.warn(\"[GhostManager] Both questKey and nextEventKey are null; nothing to activate.\");\n      }\n\n      // NOTE: We have removed the following manual increment() and StateManager.set():\n      // this.sequenceManager.increment();\n      // StateManager.set(StateManager.KEYS.CURRENT_SEQUENCE_INDEX, String(this.sequenceManager.currentIndex));\n      //\n      // By removing these lines, we ensure that the sequence index is incremented only once\n      // inside onEventCompleted(\"post_mirror_event\"), avoiding a double‐increment that\n      // would skip the repeating_quest stage.\n\n      // Update the Post button state for whatever is next.\n      this.updatePostButtonState();\n      return;\n    }\n\n    // ----------------------------------------------------------\n    // Case 2: Otherwise, attempt to start the quest if allowed.\n    console.log(`GhostManager: Handling Post button click. Next expected quest: \"${nextEntry.questKey}\".`);\n    if (!this.canStartQuest(nextEntry.questKey)) {\n      this.updatePostButtonState();\n      return;\n    }\n    await this.startQuest(nextEntry.questKey);\n    // After starting the quest, update the Post button state.\n    this.updatePostButtonState();\n  }\n\n  /**\n   * Called when a game event completes.\n   * Increments the sequence index if the completed event matches the expected nextEventKey.\n   * @param {string} eventKey - The key of the event that just completed.\n   */\n  onEventCompleted(eventKey) {\n    console.log(`GhostManager: Event completed with key: ${eventKey}`);\n    if (this.sequenceManager && this.sequenceManager.getCurrentEntry().nextEventKey === eventKey) {\n      // Only advance the sequence index here (once),\n      // ensuring that the next quest or event lines up correctly.\n      this.sequenceManager.increment();\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.CURRENT_SEQUENCE_INDEX, String(this.sequenceManager.currentIndex));\n      console.log(`GhostManager: Sequence index incremented to ${this.sequenceManager.currentIndex}`);\n    }\n  }\n\n  /**\n   * Called when a quest completes.\n   * For repeating quests, triggers a dynamic event for intermediate stages;\n   * if the quest is fully completed, uses the final event key from the configuration.\n   * For non-repeating quests, starts the next event as defined in the sequence.\n   * @param {string} questKey - The completed quest key.\n   */\n  async onQuestCompleted(questKey) {\n    console.log(`GhostManager: Quest completed with key: ${questKey}`);\n    // Clear the active quest key.\n    this.activeQuestKey = null;\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.setActiveQuestKey(null);\n\n    // Update the Post button state after quest completion.\n    this.updatePostButtonState();\n    // Deactivate the camera button since the quest is finished.\n    this.app.viewManager.setCameraButtonActive(false);\n    if (questKey === \"repeating_quest\") {\n      const repeatingQuest = this.app.questManager.quests.find(q => q.key === \"repeating_quest\");\n      const questStatus = repeatingQuest ? await repeatingQuest.getCurrentQuestStatus() : {\n        currentStage: 1,\n        totalStages: 1\n      };\n      console.log(\"Repeating quest status:\", questStatus);\n      if (questStatus.currentStage <= questStatus.totalStages) {\n        // Intermediate stage: dynamically generate the event key.\n        const dynamicEventKey = `post_repeating_event_stage_${questStatus.currentStage}`;\n        console.log(`Repeating quest stage completed. Triggering generated event: ${dynamicEventKey}`);\n        await this.startEvent(dynamicEventKey, true);\n        return;\n      } else {\n        // Quest has reached its final stage: use the final event key from config.\n        const currentEntry = this.sequenceManager ? this.sequenceManager.getCurrentEntry() : null;\n        if (currentEntry && currentEntry.nextEventKey) {\n          console.log(`Repeating quest fully completed. Now starting ghost event from config: ${currentEntry.nextEventKey}`);\n          await this.startEvent(currentEntry.nextEventKey, true);\n        } else {\n          console.warn(\"No final event configured for repeating quest completion. Unable to start final event.\");\n        }\n        this.sequenceManager.increment();\n        _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.CURRENT_SEQUENCE_INDEX, String(this.sequenceManager.currentIndex));\n        return;\n      }\n    }\n    const currentEntry = this.sequenceManager ? this.sequenceManager.getCurrentEntry() : null;\n    if (currentEntry && currentEntry.questKey === questKey && currentEntry.nextEventKey) {\n      console.log(`GhostManager: Quest completed. Now starting ghost event: ${currentEntry.nextEventKey}`);\n      await this.startEvent(currentEntry.nextEventKey, true);\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/GhostManager.js?");

/***/ }),

/***/ "./src/managers/LanguageManager.js":
/*!*****************************************!*\
  !*** ./src/managers/LanguageManager.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LanguageManager: () => (/* binding */ LanguageManager)\n/* harmony export */ });\n/* harmony import */ var _locales_locales_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../locales/locales.js */ \"./src/locales/locales.js\");\n/* harmony import */ var _locales_chatLocales_en_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../locales/chatLocales_en.js */ \"./src/locales/chatLocales_en.js\");\n/* harmony import */ var _locales_chatLocales_ru_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../locales/chatLocales_ru.js */ \"./src/locales/chatLocales_ru.js\");\n/* harmony import */ var _locales_chatLocales_uk_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../locales/chatLocales_uk.js */ \"./src/locales/chatLocales_uk.js\");\n// Import base locales and chat locales, then merge them\n\n\n\n\n\n// Merge base and chat locales for each language\nconst mergedLocales = {\n  en: {\n    ..._locales_locales_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].en,\n    ..._locales_chatLocales_en_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n  },\n  ru: {\n    ..._locales_locales_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ru,\n    ..._locales_chatLocales_ru_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n  },\n  uk: {\n    ..._locales_locales_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].uk,\n    ..._locales_chatLocales_uk_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n  }\n};\n\n/**\n * LanguageManager is responsible for managing localization in the application.\n * It loads the translation dictionaries (locales), listens for changes on the language selector,\n * and updates all page elements that have the data-i18n attribute.\n * This class also saves the selected language in localStorage to preserve the choice between sessions.\n */\nclass LanguageManager {\n  /**\n   * Constructor for LanguageManager.\n   * @param {string} selectorId - The ID of the <select> element used for language selection.\n   *\n   * During initialization:\n   * - The merged translation dictionary is loaded.\n   * - The current language is set from localStorage (or defaults to 'en').\n   * - The selector's value is updated, and applyLanguage() is called to update the UI.\n   * - A change event listener is added to the selector to handle language switching.\n   */\n  constructor(selectorId) {\n    // Use merged locales (base + chat)\n    this.locales = mergedLocales;\n\n    // Get the language selector element by its ID.\n    this.selector = document.getElementById(selectorId);\n    if (!this.selector) {\n      console.error(`Language selector with id \"${selectorId}\" not found.`);\n    }\n\n    // Set the current language from localStorage, defaulting to 'en'.\n    this.currentLanguage = localStorage.getItem('language') || 'en';\n\n    // Update the selector to reflect the current language.\n    if (this.selector) {\n      this.selector.value = this.currentLanguage;\n    }\n\n    // Apply the selected language to all elements with the data-i18n attribute.\n    this.applyLanguage();\n\n    // Add an event listener to update the language when the selector's value changes.\n    if (this.selector) {\n      this.selector.addEventListener('change', () => {\n        this.currentLanguage = this.selector.value;\n        localStorage.setItem('language', this.currentLanguage);\n        this.applyLanguage();\n      });\n    }\n  }\n\n  /**\n   * applyLanguage – Updates the text content of all elements with the data-i18n attribute\n   * based on the selected language.\n   *\n   * This method iterates over all elements with data-i18n, retrieves the translation key,\n   * and replaces the element's text content with the corresponding translation from the dictionary.\n   */\n  applyLanguage() {\n    document.querySelectorAll('[data-i18n]').forEach(el => {\n      const key = el.getAttribute('data-i18n');\n      // If a translation exists for the key in the current language, update the text.\n      if (this.locales[this.currentLanguage] && this.locales[this.currentLanguage][key]) {\n        el.textContent = this.locales[this.currentLanguage][key];\n      }\n    });\n  }\n\n  /**\n   * updateContainerLanguage – Updates the text content of all elements with the data-i18n attribute\n   * within a specific container. This is useful for dynamically inserted content.\n   *\n   * @param {HTMLElement} container - The container element in which to update localized text.\n   */\n  updateContainerLanguage(container) {\n    if (!container) return;\n    container.querySelectorAll('[data-i18n]').forEach(el => {\n      const key = el.getAttribute('data-i18n');\n      if (this.locales[this.currentLanguage] && this.locales[this.currentLanguage][key]) {\n        el.textContent = this.locales[this.currentLanguage][key];\n      }\n    });\n  }\n\n  /**\n   * Optional method: startObservingContainer\n   * Sets up a MutationObserver on a given container to automatically update any newly\n   * added elements with the data-i18n attribute.\n   *\n   * @param {HTMLElement} container - The container element to observe.\n   * @returns {MutationObserver} The observer instance (can be disconnected when no longer needed).\n   */\n  startObservingContainer(container) {\n    if (!container) return;\n    const observer = new MutationObserver(mutations => {\n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node.nodeType === Node.ELEMENT_NODE) {\n            // If the new node itself has data-i18n attribute, update it.\n            if (node.hasAttribute && node.hasAttribute('data-i18n')) {\n              const key = node.getAttribute('data-i18n');\n              if (this.locales[this.currentLanguage] && this.locales[this.currentLanguage][key]) {\n                node.textContent = this.locales[this.currentLanguage][key];\n              }\n            }\n            // Also update any descendant elements.\n            if (node.querySelectorAll) {\n              node.querySelectorAll('[data-i18n]').forEach(el => {\n                const key = el.getAttribute('data-i18n');\n                if (this.locales[this.currentLanguage] && this.locales[this.currentLanguage][key]) {\n                  el.textContent = this.locales[this.currentLanguage][key];\n                }\n              });\n            }\n          }\n        });\n      });\n    });\n    observer.observe(container, {\n      childList: true,\n      subtree: true\n    });\n    console.log(\"[LanguageManager] Started observing container for localization updates.\");\n    return observer;\n  }\n\n  /**\n   * getLanguage – Returns the currently selected language.\n   * @returns {string} The current language (e.g., 'en', 'ru', 'uk').\n   */\n  getLanguage() {\n    return this.currentLanguage;\n  }\n\n  /**\n   * translate – Returns the localized text for the given key.\n   *\n   * @param {string} key - The localization key.\n   * @param {string} [defaultValue=key] - The default value if no translation is found.\n   * @returns {string} The localized text.\n   */\n  translate(key, defaultValue = key) {\n    if (this.locales[this.currentLanguage] && this.locales[this.currentLanguage][key]) {\n      return this.locales[this.currentLanguage][key];\n    }\n    return defaultValue;\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/LanguageManager.js?");

/***/ }),

/***/ "./src/managers/NotificationManager.js":
/*!*********************************************!*\
  !*** ./src/managers/NotificationManager.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NotificationManager: () => (/* binding */ NotificationManager)\n/* harmony export */ });\nclass NotificationManager {\n  showNotification(message) {\n    if (!(\"Notification\" in window)) {\n      console.warn(\"⚠️ Notifications are not supported in this browser.\");\n      return;\n    }\n    if (Notification.permission === \"granted\") {\n      new Notification(message);\n    } else if (Notification.permission !== \"denied\") {\n      Notification.requestPermission().then(permission => {\n        if (permission === \"granted\") {\n          new Notification(message);\n        }\n      });\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/NotificationManager.js?");

/***/ }),

/***/ "./src/managers/ProfileManager.js":
/*!****************************************!*\
  !*** ./src/managers/ProfileManager.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProfileManager: () => (/* binding */ ProfileManager)\n/* harmony export */ });\n/* harmony import */ var _StateManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n\n\nclass ProfileManager {\n  /**\n   * Constructor for ProfileManager.\n   * @param {SQLiteDataManager} dataManager - An instance of the DataManager responsible for profile persistence.\n   */\n  constructor(dataManager) {\n    // Save a reference to the DataManager for profile and related data persistence.\n    this.dataManager = dataManager;\n  }\n\n  /**\n   * isProfileSaved – Asynchronously checks if a profile is saved via the DataManager.\n   * @returns {Promise<boolean>} Resolves to true if a profile exists, otherwise false.\n   */\n  async isProfileSaved() {\n    const profile = await this.dataManager.getProfile();\n    return !!profile;\n  }\n\n  /**\n   * getProfile – Asynchronously retrieves the profile from the DataManager.\n   * @returns {Promise<Object|null>} Resolves to the profile object or null if not found.\n   */\n  async getProfile() {\n    return await this.dataManager.getProfile();\n  }\n\n  /**\n   * saveProfile – Asynchronously saves the given profile object via the DataManager.\n   *\n   * IMPORTANT: Registration data (name, gender, language, selfie, etc.) should be \n   * integrated into the profile object. Do not store additional transient keys.\n   *\n   * @param {Object} profile - The profile object (should include registration fields).\n   * @returns {Promise<void>}\n   */\n  async saveProfile(profile) {\n    await this.dataManager.saveProfile(profile);\n  }\n\n  /**\n   * resetProfile – Resets the profile and all related data.\n   * Calls the DataManager to remove profile data along with ghost and quest progress,\n   * and clears all transient state keys from localStorage (except for the language key).\n   * Also resets the SQL database stored in IndexedDB.\n   * After reset, the service worker cache is cleared and the page is reloaded.\n   */\n  resetProfile() {\n    Promise.all([this.dataManager.resetProfile(),\n    // Deletes the 'profile' key.\n    this.dataManager.resetDatabase() // Deletes the SQL database saved under 'sqlite', fully clearing tables.\n    ]).then(() => {\n      // Clear all keys from localStorage except the language-related key.\n      const preserveKeys = [\"language\"]; // Adjust this array if language key is stored under a different name.\n      for (let i = localStorage.length - 1; i >= 0; i--) {\n        const key = localStorage.key(i);\n        if (!preserveKeys.includes(key)) {\n          localStorage.removeItem(key);\n        }\n      }\n\n      // NEW: Tell the Service Worker to skip waiting and clear caches\n      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\n        // ask the new SW to activate immediately\n        navigator.serviceWorker.controller.postMessage({\n          type: 'SKIP_WAITING'\n        });\n        // clear all caches so that clients navigates and picks up the new version\n        navigator.serviceWorker.controller.postMessage({\n          action: 'CLEAR_CACHE'\n        });\n        console.log(\"Service Worker skipWaiting and CLEAR_CACHE messages sent.\");\n      }\n      // Reload will be handled by the SW via controllerchange → clients.navigate()\n    }).catch(err => {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(err, \"resetProfile\");\n    });\n  }\n\n  /**\n   * exportProfileData – Exports the profile along with diary entries, apartment plan,\n   * quest progress, and chat messages to a JSON file.\n   * @param {Object} databaseManager - The database manager for retrieving diary, quest, and chat data.\n   * @param {Object} apartmentPlanManager - The apartment plan manager.\n   */\n  exportProfileData(databaseManager, apartmentPlanManager) {\n    this.getProfile().then(profile => {\n      if (!profile) {\n        alert(\"No profile found to export.\");\n        return;\n      }\n      // Filter profile to include only essential registration fields.\n      const filteredProfile = {\n        name: profile.name,\n        gender: profile.gender,\n        language: profile.language,\n        selfie: profile.selfie\n      };\n\n      // Retrieve diary entries.\n      const diaryEntries = databaseManager.getDiaryEntries();\n      // Retrieve chat messages.\n      const chatMessages = databaseManager.getChatMessages();\n      // Retrieve apartment plan data if available.\n      const apartmentPlanData = apartmentPlanManager ? apartmentPlanManager.rooms : [];\n\n      // Retrieve quest progress data from the database.\n      let questProgressData = [];\n      const result = databaseManager.db.exec(\"SELECT * FROM quest_progress ORDER BY id DESC\");\n      if (result.length > 0) {\n        questProgressData = result[0].values.map(row => ({\n          id: row[0],\n          quest_key: row[1],\n          status: row[2]\n        }));\n      }\n\n      // Form the export object including chat messages.\n      const exportData = {\n        profile: filteredProfile,\n        diary: diaryEntries,\n        apartment: apartmentPlanData,\n        quests: questProgressData,\n        chat: chatMessages\n      };\n\n      // Create a Blob from the JSON string.\n      const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n        type: 'application/json'\n      });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = 'profile.json';\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    });\n  }\n\n  /**\n   * importProfileData – Imports profile data from the selected JSON file.\n   * After import, updates the profile, diary, apartment plan, quest progress, and chat messages, then reloads the page.\n   * @param {File} file - The file containing the profile data.\n   * @param {Object} databaseManager - The database manager.\n   * @param {Object} apartmentPlanManager - The apartment plan manager.\n   */\n  importProfileData(file, databaseManager, apartmentPlanManager) {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const importedData = JSON.parse(e.target.result);\n        // Validate essential profile fields.\n        if (!importedData.profile || !importedData.profile.name || !importedData.profile.gender || !importedData.profile.selfie || !importedData.profile.language) {\n          alert(\"Invalid profile file. Required profile fields are missing.\");\n          return;\n        }\n        // Save the profile via DataManager.\n        this.saveProfile(importedData.profile);\n\n        // Import diary entries.\n        if (importedData.diary && Array.isArray(importedData.diary)) {\n          importedData.diary.forEach(entry => {\n            if (entry.entry && entry.timestamp) {\n              databaseManager.db.run(\"INSERT INTO diary (entry, timestamp) VALUES (?, ?)\", [entry.entry, entry.timestamp]);\n            }\n          });\n          databaseManager.saveDatabase();\n        }\n\n        // Import apartment plan data, if available.\n        if (importedData.apartment && Array.isArray(importedData.apartment)) {\n          if (apartmentPlanManager) {\n            apartmentPlanManager.rooms = importedData.apartment;\n            apartmentPlanManager.renderRooms();\n          }\n        }\n\n        // Import quest progress.\n        if (importedData.quests && Array.isArray(importedData.quests)) {\n          importedData.quests.forEach(progress => {\n            if (progress.quest_key && progress.status) {\n              databaseManager.addQuestProgress(progress.quest_key, progress.status);\n            }\n          });\n        }\n\n        // Import chat messages.\n        if (importedData.chat && Array.isArray(importedData.chat)) {\n          importedData.chat.forEach(msg => {\n            if (msg.sender && msg.message && msg.timestamp) {\n              databaseManager.db.run(\"INSERT INTO chat_messages (sender, message, timestamp) VALUES (?, ?, ?)\", [msg.sender, msg.message, msg.timestamp]);\n            }\n          });\n          databaseManager.saveDatabase();\n        }\n\n        // Clear transient state keys using StateManager.\n        _StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.remove(\"cameraButtonActive\");\n        _StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.remove(\"shootButtonActive\");\n        _StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.remove(\"quest_state_repeating_quest\");\n        alert(\"Profile imported successfully. Reloading page.\");\n        window.location.reload();\n      } catch (err) {\n        _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(err, \"importProfileData\");\n        alert(\"Error parsing the profile file.\");\n      }\n    };\n    reader.readAsText(file);\n  }\n\n  /**\n   * saveGhostProgress – Saves ghost progress data via the DataManager.\n   * @param {Object} progress - Progress data (e.g., { ghostId: number, phenomenonIndex: number }).\n   */\n  saveGhostProgress(progress) {\n    this.dataManager.saveGhostProgress(progress);\n  }\n\n  /**\n   * getGhostProgress – Retrieves the saved ghost progress via the DataManager.\n   * @returns {Object|null} The progress object or null if not set.\n   */\n  getGhostProgress() {\n    return this.dataManager.getGhostProgress();\n  }\n\n  /**\n   * resetGhostProgress – Resets ghost progress via the DataManager.\n   */\n  resetGhostProgress() {\n    this.dataManager.resetGhostProgress();\n  }\n\n  /**\n   * saveLocationType – Saves the user's selected location type via the DataManager.\n   * @param {string} locationType - The location type.\n   */\n  saveLocationType(locationType) {\n    this.dataManager.saveLocationType(locationType);\n  }\n\n  /**\n   * getLocationType – Retrieves the saved location type via the DataManager.\n   * @returns {string|null} The location type or null if not set.\n   */\n  getLocationType() {\n    return this.dataManager.getLocationType();\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/ProfileManager.js?");

/***/ }),

/***/ "./src/managers/QuestManager.js":
/*!**************************************!*\
  !*** ./src/managers/QuestManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuestManager: () => (/* binding */ QuestManager)\n/* harmony export */ });\n/* harmony import */ var _StateManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n/* harmony import */ var _utils_GameEntityLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/GameEntityLoader.js */ \"./src/utils/GameEntityLoader.js\");\n// File: src/managers/QuestManager.js\n\n\n\n\n\n/**\n * QuestManager class\n * \n * Responsible for managing quest activation, state updates, and UI restoration.\n * It loads quest definitions dynamically from a unified JSON configuration.\n */\nclass QuestManager {\n  /**\n   * @param {EventManager} eventManager     - The event manager handling diary entries.\n   * @param {GameEventManager} gameEventMgr - The game event manager for activating next events.\n   * @param {App} appInstance               - The main application instance.\n   */\n  constructor(eventManager, gameEventMgr, appInstance) {\n    this.eventManager = eventManager;\n    this.gameEventManager = gameEventMgr;\n    this.app = appInstance;\n    this.quests = [];\n\n    // Load the unified configuration and instantiate quests dynamically.\n    // Also prepare a mapping from questKey to its parent eventKey.\n    Promise.all([(0,_utils_GameEntityLoader_js__WEBPACK_IMPORTED_MODULE_2__.loadGameEntitiesConfig)(), (0,_utils_GameEntityLoader_js__WEBPACK_IMPORTED_MODULE_2__.getQuestKeyToEventKeyMap)()]).then(async ([config, questKeyToEventKey]) => {\n      // Build a Map of questKey → eventKey from configuration\n      this.questKeyToEventKey = questKeyToEventKey;\n\n      // Instantiate each quest class based on config\n      for (const questCfg of config.quests) {\n        // Build dependency mapping.\n        const dependencyMapping = {\n          eventManager: this.eventManager,\n          app: this.app\n        };\n        const params = questCfg.dependencies.map(dep => dependencyMapping[dep]);\n        // If quest-specific configuration exists, append it.\n        if (questCfg.config) {\n          params.push(questCfg.config);\n        }\n\n        // Determine which triad chunk this quest belongs to.\n        const eventKey = questKeyToEventKey[questCfg.key];\n        if (!eventKey) {\n          _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`Cannot find parent eventKey for quest \"${questCfg.key}\".`, \"QuestManager\");\n          continue;\n        }\n\n        // Dynamically import the triad bundle for that eventKey instead of individual quest file.\n        try {\n          // Import via alias \"triads\" so Webpack resolves build/triads/triad-<eventKey>.js\n          const module = await __webpack_require__(\"./build/triads lazy recursive ^\\\\.\\\\/triad\\\\-.*$\")(`./triad-${eventKey}`);\n          const QuestClass = module[questCfg.className];\n          if (!QuestClass) {\n            _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`Quest class \"${questCfg.className}\" is not exported from triads/triad-${eventKey}.js.`, \"QuestManager\");\n            continue;\n          }\n          const instance = new QuestClass(...params);\n          // Set the key as specified in the configuration.\n          instance.key = questCfg.key;\n          this.quests.push(instance);\n        } catch (error) {\n          _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`Failed to import triad for quest \"${questCfg.key}\": ${error.message}`, \"QuestManager\");\n        }\n      }\n      console.log(\"Quests loaded from configuration:\", this.quests.map(q => q.key));\n\n      // Register listener for questCompleted events\n      document.addEventListener(\"questCompleted\", async e => {\n        const completedQuestKey = e.detail; // e.g. \"mirror_quest\"\n        const nextEventKey = this.questKeyToEventKey[completedQuestKey];\n        if (!nextEventKey) {\n          _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`No next eventKey defined for quest \"${completedQuestKey}\".`, \"QuestManager\");\n          return;\n        }\n        try {\n          await this.gameEventManager.activateEvent(nextEventKey);\n        } catch (err) {\n          _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`Failed to activate event \"${nextEventKey}\" after quest \"${completedQuestKey}\": ${err.message}`, \"QuestManager\");\n        }\n      });\n    }).catch(error => {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(error, \"QuestManager.loadConfig\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.showError(\"Failed to load quests configuration\");\n    });\n    this.initCameraListeners();\n\n    // Restore UI state for the repeating quest if a saved state exists.\n    if (_StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.get(_StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.KEYS.REPEATING_QUEST_STATE)) {\n      console.log(\"[QuestManager] Detected saved state for repeating quest.\");\n      this.restoreRepeatingQuestUI();\n    }\n    if (this.app.viewManager && typeof this.app.viewManager.restoreCameraButtonState === 'function') {\n      this.app.viewManager.restoreCameraButtonState();\n    }\n    // *** Add restoration for the Shoot button ***\n    if (this.app.viewManager && typeof this.app.viewManager.restoreShootButtonState === 'function') {\n      this.app.viewManager.restoreShootButtonState();\n    }\n  }\n\n  /**\n   * Registers listeners for camera readiness and closure events.\n   */\n  initCameraListeners() {\n    const cameraManager = this.app.cameraSectionManager;\n    if (!cameraManager) return;\n    cameraManager.onVideoReady = async () => {\n      console.log(\"[QuestManager] onVideoReady signal received.\");\n      if (_StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.getActiveQuestKey() === \"repeating_quest\") {\n        const repeatingQuest = this.quests.find(q => q.key === \"repeating_quest\");\n        console.log(`[QuestManager] Detection target is \"${repeatingQuest.currentTarget}\"`);\n        const config = repeatingQuest.generateDetectionConfig();\n        await this.app.cameraSectionManager.startAIDetection(config);\n      }\n    };\n    cameraManager.onCameraClosed = () => {\n      console.log(\"[QuestManager] onCameraClosed signal received. Stopping detection.\");\n      this.app.cameraSectionManager.stopAIDetection();\n    };\n  }\n\n  /**\n   * Universal method to synchronize the state for a given quest.\n   * Uses the universal active quest key stored in StateManager.\n   * If the active quest key matches the provided questKey, the Post button is disabled;\n   * otherwise, the Post button is enabled.\n   * @param {string} questKey - The key of the quest to synchronize.\n   */\n  async syncQuestStateForQuest(questKey) {\n    // If the game is finalized, disable Post button.\n    if (_StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.get(_StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.KEYS.GAME_FINALIZED) === \"true\") {\n      if (this.app.viewManager && typeof this.app.viewManager.setPostButtonEnabled === 'function') {\n        this.app.viewManager.setPostButtonEnabled(false);\n      }\n      console.log(`[QuestManager.syncQuestStateForQuest] Game finalized; Post button disabled for quest \"${questKey}\".`);\n      return;\n    }\n    // Retrieve the universal active quest key.\n    const canPost = _StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.canPost();\n    this.app.viewManager.setPostButtonEnabled(canPost);\n    console.log(`[QuestManager] Post button ${canPost ? \"enabled\" : \"disabled\"} for quest \"${questKey}\".`);\n  }\n\n  /**\n   * Synchronizes the quest state for predefined quests.\n   */\n  async syncQuestState() {\n    for (const quest of this.quests) {\n      await this.syncQuestStateForQuest(quest.key);\n    }\n  }\n\n  /**\n   * Finds a quest by its key and activates it.\n   * If the key is null or undefined, logs a warning and does nothing.\n   * After activation, updates the universal active quest key.\n   * @param {string} key - The quest key.\n   */\n  async activateQuest(key) {\n    // If key is null or undefined, skip activation\n    if (!key) {\n      console.warn(\"QuestManager.activateQuest called with null/undefined key; skipping.\");\n      return;\n    }\n    const quest = this.quests.find(q => q.key === key);\n    if (!quest) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`Quest \"${key}\" not found`, \"QuestManager.activateQuest\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.showError(`Cannot activate quest \"${key}\"`);\n      return;\n    }\n    console.log(`[QuestManager] Activating quest: ${key}`);\n    await quest.activate();\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_0__.StateManager.setActiveQuestKey(key);\n    await this.syncQuestState();\n  }\n\n  /**\n   * Finalizes a quest by calling its finish() method and updates the UI.\n   * @param {string} key - The quest key.\n   */\n  async checkQuest(key) {\n    const quest = this.quests.find(q => q.key === key);\n    if (!quest) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(`Quest \"${key}\" not found`, \"QuestManager.checkQuest\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.showError(`Cannot finish quest \"${key}\"`);\n      return;\n    }\n    console.log(`[QuestManager] Finishing quest: ${key}`);\n    await quest.finish();\n    await this.syncQuestState();\n  }\n\n  /**\n   * Saves the quest progress to the database.\n   * @param {string} questKey - The quest key.\n   * @param {number} currentStage - The current stage.\n   * @param {number} totalStages - The total number of stages.\n   * @param {string} status - The quest status.\n   */\n  async updateQuestProgress(questKey, currentStage, totalStages, status) {\n    const questData = {\n      quest_key: questKey,\n      current_stage: currentStage,\n      total_stages: totalStages,\n      status\n    };\n    await this.app.databaseManager.saveQuestRecord(questData);\n    console.log(\"[QuestManager] Quest progress updated:\", questData);\n  }\n\n  /**\n   * Restores the UI for the repeating quest.\n   */\n  restoreRepeatingQuestUI() {\n    const repeatingQuest = this.quests.find(q => q.key === \"repeating_quest\");\n    if (repeatingQuest && typeof repeatingQuest.restoreUI === \"function\") {\n      console.log(\"[QuestManager] Restoring repeating quest UI...\");\n      repeatingQuest.restoreUI();\n    }\n  }\n\n  /**\n   * Re-initializes UI for all active quests.\n   * For each quest, if a corresponding database record exists with active status,\n   * the quest's restoreUI method is called to reinitialize its UI.\n   */\n  restoreAllActiveQuests() {\n    console.log(\"[QuestManager] Attempting to restore UI for all active quests...\");\n    this.quests.forEach(quest => {\n      const record = this.app.databaseManager.getQuestRecord(quest.key);\n      if (record && (record.status === \"active\" || record.status === \"finished\" && quest.currentStage <= quest.totalStages) && !quest.finished) {\n        console.log(`[QuestManager] Found active quest \"${quest.key}\". Restoring UI...`);\n        if (typeof quest.restoreUI === \"function\") {\n          quest.restoreUI();\n        } else {\n          console.log(`[QuestManager] Quest \"${quest.key}\" does not implement restoreUI().`);\n        }\n      }\n    });\n    // Update the Post button state after UI restoration\n    if (this.app.ghostManager && typeof this.app.ghostManager.updatePostButtonState === 'function') {\n      this.app.ghostManager.updatePostButtonState();\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/QuestManager.js?");

/***/ }),

/***/ "./src/managers/SQLiteDataManager.js":
/*!*******************************************!*\
  !*** ./src/managers/SQLiteDataManager.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SQLiteDataManager: () => (/* binding */ SQLiteDataManager)\n/* harmony export */ });\nclass SQLiteDataManager {\n  /**\n   * Constructor for SQLiteDataManager.\n   * @param {Object} options - Configuration options.\n   *   - dbName: Name of the IndexedDB database (default: 'sqliteDB').\n   *   - storeName: Name of the object store (default: 'dbStore').\n   *   - key: Key under which the database is stored (default: 'sqlite').\n   */\n  constructor(options = {}) {\n    this.dbName = options.dbName || 'sqliteDB';\n    this.storeName = options.storeName || 'dbStore';\n    this.key = options.key || 'sqlite';\n  }\n\n  /**\n   * openDB – Opens (or creates) the IndexedDB database.\n   * @returns {Promise<IDBDatabase>} Resolves with the opened database instance.\n   */\n  openDB() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n      request.onerror = event => {\n        console.error(\"Error opening IndexedDB:\", event.target.error);\n        reject(event.target.error);\n      };\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName);\n        }\n      };\n      request.onsuccess = event => {\n        resolve(event.target.result);\n      };\n    });\n  }\n\n  /**\n   * initDatabase – Initializes the SQL.js database.\n   * If saved database data is found in IndexedDB, restores it.\n   * Otherwise, creates a new database instance.\n   *\n   * After restoration or creation, migration queries are executed\n   * to ensure that all required tables (diary, apartment_plan, quest_progress,\n   * ghosts, events, quests, chat_messages) exist.\n   *\n   * @param {Object} SQL - The SQL.js module.\n   * @returns {Promise<SQL.Database>} Resolves to the SQL.js database instance.\n   */\n  async initDatabase(SQL) {\n    const savedDbBase64 = await this.loadDatabase();\n    let dbInstance;\n    if (savedDbBase64) {\n      // Restore database from saved base64 data.\n      const binaryStr = atob(savedDbBase64);\n      const binaryData = new Uint8Array(binaryStr.length);\n      for (let i = 0; i < binaryStr.length; i++) {\n        binaryData[i] = binaryStr.charCodeAt(i);\n      }\n      dbInstance = new SQL.Database(binaryData);\n      console.log(\"Database restored from IndexedDB.\");\n    } else {\n      // Create a new database instance.\n      dbInstance = new SQL.Database();\n      console.log(\"New database instance created.\");\n    }\n\n    // Run migration queries to ensure all required tables exist.\n    this.migrateDatabase(dbInstance);\n    if (!savedDbBase64) {\n      console.log(\"New database created and tables initialized.\");\n    } else {\n      console.log(\"Database migration complete.\");\n    }\n    return dbInstance;\n  }\n\n  /**\n   * migrateDatabase – Runs migration queries to update the database schema.\n   * Ensures that all required tables exist.\n   *\n   * @param {SQL.Database} dbInstance - The SQL.js database instance.\n   */\n  migrateDatabase(dbInstance) {\n    dbInstance.run(`\n      CREATE TABLE IF NOT EXISTS diary (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        entry TEXT,\n        timestamp TEXT\n      );\n      CREATE TABLE IF NOT EXISTS apartment_plan (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        floor_number INTEGER,\n        room_data TEXT\n      );\n      CREATE TABLE IF NOT EXISTS quest_progress (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        quest_key TEXT,\n        status TEXT\n      );\n      CREATE TABLE IF NOT EXISTS ghosts (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT,\n        status TEXT,\n        progress INTEGER\n      );\n      CREATE TABLE IF NOT EXISTS events (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        event_key TEXT,\n        event_text TEXT,\n        timestamp TEXT,\n        completed INTEGER\n      );\n      CREATE TABLE IF NOT EXISTS quests (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        quest_key TEXT,\n        status TEXT,\n        current_stage INTEGER,\n        total_stages INTEGER\n      );\n      CREATE TABLE IF NOT EXISTS chat_messages (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        sender TEXT,\n        message TEXT,\n        timestamp TEXT\n      );\n    `);\n  }\n\n  /**\n   * saveDatabase – Exports the database to a base64 string and persists it via IndexedDB.\n   *\n   * @param {string} base64Data - The base64-encoded database data.\n   * @returns {Promise<void>} Resolves when saving is complete.\n   */\n  async saveDatabase(base64Data) {\n    const db = await this.openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      transaction.oncomplete = () => {\n        console.log(\"Database saved successfully in IndexedDB.\");\n        resolve();\n      };\n      transaction.onerror = event => {\n        console.error(\"Transaction error during saveDatabase:\", event.target.error);\n        reject(event.target.error);\n      };\n      const store = transaction.objectStore(this.storeName);\n      const putRequest = store.put(base64Data, this.key);\n      putRequest.onerror = event => {\n        console.error(\"Error saving database data:\", event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * loadDatabase – Loads the database data from IndexedDB.\n   *\n   * @returns {Promise<string>} Resolves to the base64 string representing the database, or undefined if not found.\n   */\n  async loadDatabase() {\n    const db = await this.openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      transaction.onerror = event => {\n        console.error(\"Transaction error during loadDatabase:\", event.target.error);\n        reject(event.target.error);\n      };\n      const store = transaction.objectStore(this.storeName);\n      const getRequest = store.get(this.key);\n      getRequest.onsuccess = event => {\n        console.log(\"Database loaded successfully from IndexedDB.\");\n        resolve(event.target.result);\n      };\n      getRequest.onerror = event => {\n        console.error(\"Error loading database data:\", event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * resetDatabase – Deletes the saved SQL database data (base64 string) from IndexedDB.\n   *\n   * @returns {Promise<void>} Resolves when the database data is successfully deleted.\n   */\n  async resetDatabase() {\n    const db = await this.openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      transaction.oncomplete = () => {\n        console.log(\"SQL database reset successfully in IndexedDB.\");\n        resolve();\n      };\n      transaction.onerror = event => {\n        console.error(\"Transaction error during resetDatabase:\", event.target.error);\n        reject(event.target.error);\n      };\n      const store = transaction.objectStore(this.storeName);\n      const deleteRequest = store.delete(this.key);\n      deleteRequest.onerror = event => {\n        console.error(\"Error deleting SQL database data:\", event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * saveProfile – Saves the profile data to IndexedDB.\n   *\n   * @param {Object} profile - The profile object to be saved.\n   * @returns {Promise<void>}\n   */\n  async saveProfile(profile) {\n    const profileKey = 'profile';\n    const db = await this.openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      transaction.oncomplete = () => {\n        console.log(\"Profile saved successfully in IndexedDB.\");\n        resolve();\n      };\n      transaction.onerror = event => {\n        console.error(\"Transaction error during saveProfile:\", event.target.error);\n        reject(event.target.error);\n      };\n      const store = transaction.objectStore(this.storeName);\n      const putRequest = store.put(JSON.stringify(profile), profileKey);\n      putRequest.onerror = event => {\n        console.error(\"Error saving profile data:\", event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * getProfile – Loads the profile data from IndexedDB.\n   *\n   * @returns {Promise<Object|null>} Resolves to the profile object or null if not found.\n   */\n  async getProfile() {\n    const profileKey = 'profile';\n    const db = await this.openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      transaction.onerror = event => {\n        console.error(\"Transaction error during getProfile:\", event.target.error);\n        reject(event.target.error);\n      };\n      const store = transaction.objectStore(this.storeName);\n      const getRequest = store.get(profileKey);\n      getRequest.onsuccess = event => {\n        const result = event.target.result;\n        if (result) {\n          resolve(JSON.parse(result));\n        } else {\n          resolve(null);\n        }\n      };\n      getRequest.onerror = event => {\n        console.error(\"Error loading profile data:\", event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * resetProfile – Deletes the profile data from IndexedDB.\n   *\n   * @returns {Promise<void>} Resolves when the profile is successfully reset.\n   */\n  async resetProfile() {\n    const profileKey = 'profile';\n    const db = await this.openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      transaction.oncomplete = () => {\n        console.log(\"Profile reset successfully in IndexedDB.\");\n        resolve();\n      };\n      transaction.onerror = event => {\n        console.error(\"Transaction error during resetProfile:\", event.target.error);\n        reject(event.target.error);\n      };\n      const store = transaction.objectStore(this.storeName);\n      const deleteRequest = store.delete(profileKey);\n      deleteRequest.onerror = event => {\n        console.error(\"Error deleting profile:\", event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  // Additional methods for ghosts, events, quests can be added here:\n  // async saveGhostProgress(progress) { ... }\n  // async getGhostProgress() { ... }\n  // async saveLocationType(locationType) { ... }\n  // async getLocationType() { ... }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/SQLiteDataManager.js?");

/***/ }),

/***/ "./src/managers/ShowProfileModal.js":
/*!******************************************!*\
  !*** ./src/managers/ShowProfileModal.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShowProfileModal: () => (/* binding */ ShowProfileModal)\n/* harmony export */ });\n/**\n * Класс ShowProfileModal отвечает за отображение модального окна профиля,\n * где пользователь может редактировать данные своего профиля, включая селфи,\n * логин, просматривать план квартиры и видеть награды (прогресс призраков).\n */\nclass ShowProfileModal {\n  /**\n   * Конструктор класса.\n   * @param {App} appInstance - Ссылка на главный объект приложения для доступа ко всем менеджерам и данным.\n   */\n  constructor(appInstance) {\n    // Сохраняем ссылку на главный объект приложения.\n    this.app = appInstance;\n  }\n\n  /**\n   * Метод show – открывает модальное окно профиля.\n   * В этом окне отображается текущий профиль, позволяющее пользователю редактировать данные.\n   */\n  show() {\n    // Получаем текущий профиль через менеджер профиля.\n    const profile = this.app.profileManager.getProfile();\n    if (!profile) {\n      alert(\"Профиль не найден.\");\n      return;\n    }\n\n    // Создаем оверлей для модального окна с фиксированным позиционированием и затемненным фоном.\n    const modalOverlay = document.createElement(\"div\");\n    modalOverlay.id = \"profile-modal-overlay\";\n    Object.assign(modalOverlay.style, {\n      position: \"fixed\",\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      backgroundColor: \"rgba(0,0,0,0.5)\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      zIndex: \"2000\",\n      overflowY: \"auto\"\n    });\n\n    // Создаем контейнер модального окна.\n    const modal = document.createElement(\"div\");\n    modal.id = \"profile-modal\";\n    Object.assign(modal.style, {\n      backgroundColor: \"#fff\",\n      padding: \"20px\",\n      borderRadius: \"8px\",\n      width: \"90%\",\n      maxWidth: \"500px\",\n      maxHeight: \"90%\",\n      overflowY: \"auto\",\n      boxShadow: \"0 0 10px rgba(0,0,0,0.3)\"\n    });\n\n    // Заголовок модального окна.\n    const title = document.createElement(\"h2\");\n    title.textContent = \"Редактирование профиля\";\n    modal.appendChild(title);\n\n    // Блок для отображения аватара (селфи).\n    const avatarContainer = document.createElement(\"div\");\n    avatarContainer.style.textAlign = \"center\";\n\n    // Создаем элемент изображения для аватара.\n    const avatarImg = document.createElement(\"img\");\n    avatarImg.id = \"profile-modal-avatar\";\n    avatarImg.src = profile.selfie;\n    avatarImg.alt = \"Аватар\";\n    Object.assign(avatarImg.style, {\n      width: \"100px\",\n      height: \"100px\",\n      borderRadius: \"50%\"\n    });\n    avatarContainer.appendChild(avatarImg);\n\n    // Кнопка для обновления селфи.\n    const updateSelfieBtn = document.createElement(\"button\");\n    updateSelfieBtn.textContent = \"Обновить селфи\";\n    updateSelfieBtn.style.marginTop = \"10px\";\n    updateSelfieBtn.addEventListener(\"click\", () => {\n      // Открываем отдельное модальное окно для редактирования селфи.\n      this.showSelfieEditModal(newSelfieSrc => {\n        // После успешного захвата селфи обновляем аватар.\n        avatarImg.src = newSelfieSrc;\n      });\n    });\n    avatarContainer.appendChild(updateSelfieBtn);\n    modal.appendChild(avatarContainer);\n\n    // Поле для редактирования логина.\n    const loginLabel = document.createElement(\"label\");\n    loginLabel.textContent = \"Логин:\";\n    loginLabel.style.display = \"block\";\n    loginLabel.style.marginTop = \"15px\";\n    modal.appendChild(loginLabel);\n    const loginInput = document.createElement(\"input\");\n    loginInput.type = \"text\";\n    loginInput.value = profile.name;\n    loginInput.style.width = \"100%\";\n    loginInput.style.marginBottom = \"15px\";\n    modal.appendChild(loginInput);\n\n    // Блок для отображения плана квартиры.\n    const planContainer = document.createElement(\"div\");\n    planContainer.id = \"profile-plan-container\";\n    planContainer.style.border = \"1px solid #ccc\";\n    planContainer.style.padding = \"10px\";\n    planContainer.style.marginBottom = \"15px\";\n    // Если менеджер плана квартиры существует, пытаемся отобразить план.\n    if (this.app.apartmentPlanManager) {\n      // Если таблица еще не создана, пытаемся её создать.\n      if (!this.app.apartmentPlanManager.table) {\n        this.app.apartmentPlanManager.createTable();\n      }\n      // Если таблица успешно создана, клонируем ее для отображения.\n      if (this.app.apartmentPlanManager.table) {\n        const planClone = this.app.apartmentPlanManager.table.cloneNode(true);\n        planContainer.appendChild(planClone);\n        // Если существует несколько этажей, добавляем кнопки переключения этажей.\n        const floors = this.app.apartmentPlanManager.rooms.map(room => room.floor);\n        const uniqueFloors = [...new Set(floors)];\n        if (uniqueFloors.length > 1) {\n          const floorControls = document.createElement(\"div\");\n          floorControls.style.textAlign = \"center\";\n          floorControls.style.marginTop = \"10px\";\n          const prevFloorBtn = document.createElement(\"button\");\n          prevFloorBtn.textContent = \"Предыдущий этаж\";\n          prevFloorBtn.addEventListener(\"click\", () => {\n            this.app.apartmentPlanManager.prevFloor();\n            planContainer.innerHTML = \"\";\n            if (this.app.apartmentPlanManager.table) {\n              const newPlan = this.app.apartmentPlanManager.table.cloneNode(true);\n              planContainer.appendChild(newPlan);\n            } else {\n              planContainer.textContent = \"План квартиры отсутствует.\";\n            }\n          });\n          const nextFloorBtn = document.createElement(\"button\");\n          nextFloorBtn.textContent = \"Следующий этаж\";\n          nextFloorBtn.style.marginLeft = \"10px\";\n          nextFloorBtn.addEventListener(\"click\", () => {\n            this.app.apartmentPlanManager.nextFloor();\n            planContainer.innerHTML = \"\";\n            if (this.app.apartmentPlanManager.table) {\n              const newPlan = this.app.apartmentPlanManager.table.cloneNode(true);\n              planContainer.appendChild(newPlan);\n            } else {\n              planContainer.textContent = \"План квартиры отсутствует.\";\n            }\n          });\n          floorControls.appendChild(prevFloorBtn);\n          floorControls.appendChild(nextFloorBtn);\n          planContainer.appendChild(floorControls);\n        }\n      } else {\n        planContainer.textContent = \"План квартиры отсутствует.\";\n      }\n    } else {\n      planContainer.textContent = \"План квартиры отсутствует.\";\n    }\n    modal.appendChild(planContainer);\n\n    // Информационная надпись.\n    const note = document.createElement(\"p\");\n    note.textContent = \"Переехать и начать с чистого листа - это иногда помогает избавиться от привидений, но не всегда.\";\n    note.style.fontStyle = \"italic\";\n    modal.appendChild(note);\n\n    // Блок для отображения наград (прогресс призраков).\n    const rewardsContainer = document.createElement(\"div\");\n    rewardsContainer.id = \"ghost-rewards-container\";\n    Object.assign(rewardsContainer.style, {\n      display: \"flex\",\n      flexWrap: \"wrap\",\n      justifyContent: \"center\",\n      marginTop: \"20px\"\n    });\n    // Получаем список призраков из менеджера призраков.\n    const ghostList = this.app.ghostManager && this.app.ghostManager.ghosts || [];\n    ghostList.forEach(ghost => {\n      const ghostIcon = document.createElement(\"div\");\n      ghostIcon.className = \"ghost-icon\";\n      Object.assign(ghostIcon.style, {\n        width: \"60px\",\n        height: \"60px\",\n        borderRadius: \"50%\",\n        border: \"2px solid #ccc\",\n        margin: \"5px\",\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        fontSize: \"12px\",\n        fontWeight: \"bold\",\n        position: \"relative\"\n      });\n      // Получаем прогресс призрака из менеджера профиля.\n      const ghostProgress = this.app.profileManager.getGhostProgress();\n      if (ghostProgress && ghostProgress.ghostId === ghost.id) {\n        // Если призрак активен, отображаем текущий шаг и общее количество шагов.\n        ghostIcon.textContent = `${ghostProgress.phenomenonIndex}/${ghost.phenomenaCount}`;\n        ghostIcon.style.borderColor = \"#4caf50\"; // Зеленая рамка для активного призрака.\n      } else {\n        // Для остальных призраков отображаем имя с эффектом серой гаммы.\n        ghostIcon.textContent = ghost.name;\n        ghostIcon.style.filter = \"grayscale(100%)\";\n      }\n      rewardsContainer.appendChild(ghostIcon);\n    });\n    modal.appendChild(rewardsContainer);\n\n    // Контейнер для кнопок \"Отмена\" и \"Сохранить изменения\".\n    const btnContainer = document.createElement(\"div\");\n    btnContainer.style.textAlign = \"right\";\n    btnContainer.style.marginTop = \"20px\";\n\n    // Кнопка \"Отмена\" закрывает модальное окно.\n    const cancelBtn = document.createElement(\"button\");\n    cancelBtn.textContent = \"Отмена\";\n    cancelBtn.style.marginRight = \"10px\";\n    cancelBtn.addEventListener(\"click\", () => {\n      document.body.removeChild(modalOverlay);\n    });\n    btnContainer.appendChild(cancelBtn);\n\n    // Кнопка \"Сохранить изменения\" обновляет профиль с новыми данными и закрывает окно.\n    const saveBtn = document.createElement(\"button\");\n    saveBtn.textContent = \"Сохранить изменения\";\n    saveBtn.addEventListener(\"click\", () => {\n      // Обновляем профиль, объединяя старые данные с новыми (логин и селфи).\n      const updatedProfile = Object.assign({}, profile, {\n        name: loginInput.value,\n        selfie: avatarImg.src\n      });\n      this.app.profileManager.saveProfile(updatedProfile);\n      // Обновляем мини-профиль в основном интерфейсе.\n      this.app.profileNameElem.textContent = updatedProfile.name;\n      this.app.profilePhotoElem.src = updatedProfile.selfie;\n      document.body.removeChild(modalOverlay);\n    });\n    btnContainer.appendChild(saveBtn);\n    modal.appendChild(btnContainer);\n\n    // Добавляем контейнер модального окна в оверлей и помещаем его в body.\n    modalOverlay.appendChild(modal);\n    document.body.appendChild(modalOverlay);\n  }\n\n  /**\n   * Метод showSelfieEditModal – открывает отдельное модальное окно для редактирования селфи.\n   * После захвата нового селфи вызывается переданный колбэк для обновления аватара.\n   * @param {Function} onSelfieCaptured - функция, вызываемая с новым селфи (dataURL) после его захвата.\n   */\n  showSelfieEditModal(onSelfieCaptured) {\n    // Создаем оверлей для модального окна редактирования селфи.\n    const selfieOverlay = document.createElement(\"div\");\n    selfieOverlay.id = \"selfie-edit-overlay\";\n    Object.assign(selfieOverlay.style, {\n      position: \"fixed\",\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      backgroundColor: \"rgba(0,0,0,0.7)\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      zIndex: \"2100\",\n      overflowY: \"auto\"\n    });\n\n    // Контейнер для модального окна редактирования селфи.\n    const selfieModal = document.createElement(\"div\");\n    selfieModal.id = \"selfie-edit-modal\";\n    Object.assign(selfieModal.style, {\n      backgroundColor: \"#fff\",\n      padding: \"20px\",\n      borderRadius: \"8px\",\n      width: \"90%\",\n      maxWidth: \"400px\",\n      maxHeight: \"90%\",\n      overflowY: \"auto\",\n      boxShadow: \"0 0 10px rgba(0,0,0,0.3)\"\n    });\n\n    // Заголовок модального окна редактирования селфи.\n    const title = document.createElement(\"h3\");\n    title.textContent = \"Редактирование селфи\";\n    selfieModal.appendChild(title);\n\n    // Контейнер для видео, где будет отображаться видеопоток с камеры.\n    const videoContainer = document.createElement(\"div\");\n    videoContainer.id = \"selfie-video-container\";\n    Object.assign(videoContainer.style, {\n      width: \"100%\",\n      maxWidth: \"400px\",\n      margin: \"10px auto\"\n    });\n    selfieModal.appendChild(videoContainer);\n\n    // Прикрепляем видео к контейнеру с заданными опциями (например, с фильтром).\n    this.app.cameraSectionManager.attachTo(\"selfie-video-container\", {\n      width: \"100%\",\n      maxWidth: \"400px\",\n      filter: \"grayscale(100%)\"\n    });\n    // Запускаем камеру.\n    this.app.cameraSectionManager.startCamera();\n\n    // Кнопка для захвата селфи.\n    const captureBtn = document.createElement(\"button\");\n    captureBtn.textContent = \"Сделать селфи\";\n    captureBtn.style.display = \"block\";\n    captureBtn.style.margin = \"10px auto\";\n    captureBtn.addEventListener(\"click\", () => {\n      // Проверяем, активна ли камера.\n      if (!this.app.cameraSectionManager.videoElement || !this.app.cameraSectionManager.videoElement.srcObject) {\n        alert(\"Камера не включена.\");\n        return;\n      }\n      const video = this.app.cameraSectionManager.videoElement;\n      const canvas = document.createElement('canvas');\n      canvas.width = video.videoWidth || 640;\n      canvas.height = video.videoHeight || 480;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n      // Преобразуем изображение в оттенки серого.\n      const selfieData = window.ImageUtils ? window.ImageUtils.convertToGrayscale(canvas) : canvas.toDataURL();\n      // Останавливаем камеру.\n      this.app.cameraSectionManager.stopCamera();\n      // Закрываем окно редактирования селфи.\n      document.body.removeChild(selfieOverlay);\n      // Вызываем колбэк для обновления аватара.\n      if (onSelfieCaptured) onSelfieCaptured(selfieData);\n    });\n    selfieModal.appendChild(captureBtn);\n\n    // Кнопка для отмены редактирования селфи.\n    const cancelBtn = document.createElement(\"button\");\n    cancelBtn.textContent = \"Отмена\";\n    cancelBtn.style.display = \"block\";\n    cancelBtn.style.margin = \"10px auto\";\n    cancelBtn.addEventListener(\"click\", () => {\n      // Останавливаем камеру и закрываем окно редактирования селфи.\n      this.app.cameraSectionManager.stopCamera();\n      document.body.removeChild(selfieOverlay);\n    });\n    selfieModal.appendChild(cancelBtn);\n    selfieOverlay.appendChild(selfieModal);\n    document.body.appendChild(selfieOverlay);\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/ShowProfileModal.js?");

/***/ }),

/***/ "./src/managers/StateManager.js":
/*!**************************************!*\
  !*** ./src/managers/StateManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StateManager: () => (/* binding */ StateManager)\n/* harmony export */ });\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n/* harmony import */ var _config_stateKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/stateKeys.js */ \"./src/config/stateKeys.js\");\n\n\n\n/**\n * StateManager\n *\n * Centralized module for managing application state.\n * Provides static methods to get, set, and remove values from localStorage.\n * All parts of the application should use these methods to access or modify state.\n *\n * Note: Values are stored as strings, so for objects or arrays use JSON.stringify() before setting,\n * and JSON.parse() when retrieving.\n */\nclass StateManager {\n  // Load all state-keys from external JS module\n  static KEYS = _config_stateKeys_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n\n  /**\n   * Retrieves the value associated with the specified key from localStorage.\n   *\n   * @param {string} key - The key to retrieve.\n   * @returns {string|null} The stored value as a string, or null if not found or on error.\n   */\n  static get(key) {\n    try {\n      return localStorage.getItem(key);\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(`StateManager.get error for key \"${key}\": ${error}`, \"StateManager.get\");\n      return null;\n    }\n  }\n\n  /**\n   * Stores the given value in localStorage under the specified key.\n   *\n   * @param {string} key - The key under which to store the value.\n   * @param {string} value - The value to store (should be a string; use JSON.stringify() if needed).\n   */\n  static set(key, value) {\n    try {\n      localStorage.setItem(key, value);\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(`StateManager.set error for key \"${key}\": ${error}`, \"StateManager.set\");\n    }\n  }\n\n  /**\n   * Removes the item with the specified key from localStorage.\n   *\n   * @param {string} key - The key of the item to remove.\n   */\n  static remove(key) {\n    try {\n      localStorage.removeItem(key);\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_0__.ErrorManager.logError(`StateManager.remove error for key \"${key}\": ${error}`, \"StateManager.remove\");\n    }\n  }\n\n  /**\n   * Mark camera as open or closed.\n   * @param {boolean} isOpen\n   */\n  static setCameraOpen(isOpen) {\n    StateManager.set(StateManager.KEYS.CAMERA_OPEN, isOpen ? 'true' : 'false');\n  }\n\n  /**\n   * Check whether camera is currently open.\n   * @returns {boolean}\n   */\n  static isCameraOpen() {\n    return StateManager.get(StateManager.KEYS.CAMERA_OPEN) === 'true';\n  }\n\n  /**\n   * Store or clear the active quest key.\n   * @param {string|null} key\n   */\n  static setActiveQuestKey(key) {\n    if (key) {\n      StateManager.set(StateManager.KEYS.ACTIVE_QUEST_KEY, key);\n    } else {\n      StateManager.remove(StateManager.KEYS.ACTIVE_QUEST_KEY);\n    }\n  }\n\n  /**\n   * Retrieve the current active quest key, or null if none.\n   * @returns {string|null}\n   */\n  static getActiveQuestKey() {\n    return StateManager.get(StateManager.KEYS.ACTIVE_QUEST_KEY);\n  }\n\n  /**\n   * Return true if both the camera is open and a quest is active.\n   * @returns {boolean}\n   */\n  static canShoot() {\n    return this.get(StateManager.KEYS.CAMERA_BUTTON_ACTIVE) === \"true\" && !!this.getActiveQuestKey();\n  }\n\n  /**\n   * Return true if no quest is active (i.e. user may press Post).\n   * @returns {boolean}\n   */\n  static canPost() {\n    return !StateManager.getActiveQuestKey();\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/StateManager.js?");

/***/ }),

/***/ "./src/managers/ViewManager.js":
/*!*************************************!*\
  !*** ./src/managers/ViewManager.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ViewManager: () => (/* binding */ ViewManager)\n/* harmony export */ });\n/* harmony import */ var _config_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/paths.js */ \"./src/config/paths.js\");\n/* harmony import */ var _StateManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateManager.js */ \"./src/managers/StateManager.js\");\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n/* harmony import */ var _utils_ImageUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/ImageUtils.js */ \"./src/utils/ImageUtils.js\");\n/* harmony import */ var _ApartmentPlanManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ApartmentPlanManager.js */ \"./src/managers/ApartmentPlanManager.js\");\n/* harmony import */ var _utils_TemplateEngine_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/TemplateEngine.js */ \"./src/utils/TemplateEngine.js\");\n\n\n\n\n\n\n\n/**\n * ViewManager\n *\n * Central UI module responsible for:\n * - Switching screens.\n * - Managing button states.\n * - Updating profile display.\n * - Rendering the diary.\n * - Handling UI effects and notifications.\n *\n * All UI updates and DOM manipulations are centralized here.\n */\nclass ViewManager {\n  constructor(appInstance) {\n    this.app = appInstance;\n    // --- Cache static UI elements from index.html ---\n    this.loadingOlderPosts = false;\n    this.controlsPanel = document.getElementById(\"controls-panel\");\n    this.languageSelector = document.getElementById('language-selector');\n    this.globalCamera = document.getElementById(\"global-camera\");\n    this.postBtn = document.getElementById(\"post-btn\");\n    this.toggleCameraBtn = document.getElementById(\"toggle-camera\");\n    this.toggleDiaryBtn = document.getElementById(\"toggle-diary\");\n    this.resetDataBtn = document.getElementById(\"reset-data\");\n    this.exportProfileBtn = document.getElementById(\"export-profile-btn\");\n    this.updateBtn = document.getElementById(\"update-btn\");\n\n    // Initially, we assign the diaryContainer from the hidden placeholder\n    this.diaryContainer = document.getElementById(\"diary\");\n    this.cameraManager = null;\n    this.languageManager = null;\n\n    // Disable \"Post\" button initially.\n    if (this.postBtn) {\n      this.postBtn.disabled = true;\n      // Use universal flag storage; initial state is disabled.\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.POST_BUTTON_DISABLED, \"true\");\n      console.log(\"[ViewManager] Post button disabled on initialization.\");\n    }\n  }\n  setCameraManager(cameraManager) {\n    this.cameraManager = cameraManager;\n    console.log(\"[ViewManager] Camera manager set.\");\n  }\n  setLanguageManager(languageManager) {\n    this.languageManager = languageManager;\n  }\n  getRegistrationData() {\n    if (!this.nameInput || !this.genderSelect) {\n      return null;\n    }\n    return {\n      name: this.nameInput.value.trim(),\n      gender: this.genderSelect.value.trim(),\n      language: this.languageSelector ? this.languageSelector.value : 'en'\n    };\n  }\n  bindEvents(app) {\n    if (this.languageSelector) {\n      this.languageSelector.addEventListener('change', () => {\n        console.log(\"Language select changed:\", this.languageSelector.value);\n      });\n    }\n    if (this.toggleCameraBtn) {\n      this.toggleCameraBtn.addEventListener(\"click\", () => {\n        this.toggleCameraView(app);\n      });\n    }\n    if (this.toggleDiaryBtn) {\n      this.toggleDiaryBtn.addEventListener(\"click\", () => {\n        this.toggleCameraView(app);\n      });\n    }\n    if (this.resetDataBtn) {\n      this.resetDataBtn.addEventListener(\"click\", () => {\n        console.log(\"Reset Data button clicked.\");\n        app.profileManager.resetProfile();\n      });\n    }\n    if (this.exportProfileBtn) {\n      this.exportProfileBtn.addEventListener(\"click\", () => {\n        console.log(\"Export Profile button clicked.\");\n        this.exportProfile(app);\n      });\n    }\n    if (this.updateBtn) {\n      this.updateBtn.addEventListener(\"click\", () => {\n        console.log(\"Update button clicked.\");\n        this.clearCache();\n      });\n    }\n    const chatBtn = document.getElementById(\"chat-btn\");\n    if (chatBtn) {\n      chatBtn.addEventListener(\"click\", () => {\n        console.log(\"Chat button clicked. Triggering toggleChat().\");\n        this.toggleChat(app);\n      });\n    } else {\n      console.error(\"Chat button (id='chat-btn') not found in the DOM.\");\n    }\n\n    // >>> Add missing event listener for the Post button.\n    if (this.postBtn) {\n      this.postBtn.addEventListener(\"click\", () => {\n        console.log(\"Post button clicked. Delegating to ghostManager.handlePostButtonClick()...\");\n        app.ghostManager.handlePostButtonClick();\n      });\n    } else {\n      console.error(\"Post button (id='post-btn') not found in the DOM.\");\n    }\n  }\n\n  // ------------------ Dynamic Template Loading Methods ------------------\n\n  async loadTemplate(screenId, data = {}) {\n    const templateUrl = `${_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.BASE_PATH}/src/templates/${screenId}_template.html`;\n    try {\n      const response = await fetch(templateUrl);\n      if (!response.ok) {\n        throw new Error(`Failed to load template: ${templateUrl}`);\n      }\n      const templateText = await response.text();\n      const renderedHTML = _utils_TemplateEngine_js__WEBPACK_IMPORTED_MODULE_5__.TemplateEngine.render(templateText, data);\n      const container = document.getElementById(\"global-content\");\n      if (container) {\n        container.innerHTML += renderedHTML;\n        const newScreen = container.lastElementChild;\n        console.log(`[ViewManager] Loaded template for screen: ${screenId}`);\n        if (this.languageManager && typeof this.languageManager.updateContainerLanguage === 'function') {\n          this.languageManager.updateContainerLanguage(newScreen);\n        }\n        // APPLY VISUAL EFFECTS TO NEW ELEMENTS IN THE LOADED SCREEN\n        if (this.app && this.app.visualEffectsManager && typeof this.app.visualEffectsManager.applyEffectsToNewElements === 'function') {\n          const newElements = newScreen.querySelectorAll(\"[data-animate-on-board='true']\");\n          this.app.visualEffectsManager.applyEffectsToNewElements(newElements);\n        }\n        return newScreen;\n      } else {\n        throw new Error(\"Global content container (id='global-content') not found.\");\n      }\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(error, \"loadTemplate\");\n      return null;\n    }\n  }\n\n  /**\n   * switchScreen\n   * Switches the UI to the target screen. If the screen element does not exist,\n   * it dynamically loads the template from the templates folder.\n   * Also re-binds dynamic event handlers for newly loaded screens\n   * and toggles the global language selector (on landing only).\n   *\n   * @param {string} screenId - The id of the target screen.\n   * @param {string} buttonsGroupId - The id of the control button group to display.\n   * @param {App} [app] - The main application instance (if needed for event callbacks).\n   */\n  async switchScreen(screenId, buttonsGroupId, app) {\n    // Hide all sections\n    document.querySelectorAll('section').forEach(section => {\n      section.style.display = 'none';\n    });\n    let targetScreen = document.getElementById(screenId);\n    if (!targetScreen) {\n      // If not found, load the template dynamically.\n      targetScreen = await this.loadTemplate(screenId, {});\n      if (!targetScreen) {\n        console.error(`[ViewManager] Failed to load screen: ${screenId}`);\n        return;\n      }\n    }\n    targetScreen.style.display = 'block';\n    console.log(`[ViewManager] Switched to screen: ${screenId}`);\n\n    // APPLY VISUAL EFFECTS TO NEW ELEMENTS IN THE SWITCHED SCREEN\n    if (this.app && this.app.visualEffectsManager && typeof this.app.visualEffectsManager.applyEffectsToNewElements === 'function') {\n      const newElements = targetScreen.querySelectorAll(\"[data-animate-on-board='true']\");\n      this.app.visualEffectsManager.applyEffectsToNewElements(newElements);\n    }\n\n    // If main-screen, update diaryContainer to the newly loaded #diary\n    if (screenId === \"main-screen\") {\n      const diaryElem = targetScreen.querySelector('#diary');\n      if (diaryElem) {\n        this.diaryContainer = diaryElem;\n        console.log(\"[ViewManager] Updated diary container for main-screen.\");\n        await this.loadLatestDiaryPosts();\n        // подгружаем старые посты при приближении к низу страницы\n        window.addEventListener(\"scroll\", this.onScrollLoadOlder.bind(this), {\n          passive: true\n        });\n      }\n    }\n\n    // If landing-screen, bind the start-registration button\n    if (screenId === \"landing-screen\") {\n      const startRegistrationBtn = targetScreen.querySelector('#start-registration-btn');\n      if (startRegistrationBtn) {\n        startRegistrationBtn.addEventListener('click', () => {\n          this.switchScreen('registration-screen', 'registration-buttons', app);\n          console.log(\"[ViewManager] Start registration button clicked, switching to registration screen.\");\n        });\n      }\n    }\n\n    // If registration-screen, re-assign dynamic fields and event handlers\n    if (screenId === \"registration-screen\") {\n      this.nameInput = targetScreen.querySelector('#player-name');\n      this.genderSelect = targetScreen.querySelector('#player-gender');\n      this.nextStepBtn = targetScreen.querySelector('#next-step-btn');\n      const checkRegistrationValidity = () => {\n        const nameValid = this.nameInput && this.nameInput.value.trim().length > 0;\n        const genderValid = this.genderSelect && this.genderSelect.value !== \"\";\n        if (this.nextStepBtn) {\n          this.nextStepBtn.disabled = !(nameValid && genderValid);\n        }\n      };\n      if (this.nameInput) {\n        this.nameInput.addEventListener('input', () => {\n          console.log(\"Name input changed:\", this.nameInput.value);\n          checkRegistrationValidity();\n        });\n      }\n      if (this.genderSelect) {\n        this.genderSelect.addEventListener('change', () => {\n          console.log(\"Gender select changed:\", this.genderSelect.value);\n          checkRegistrationValidity();\n        });\n      }\n      if (this.nextStepBtn) {\n        this.nextStepBtn.addEventListener('click', async () => {\n          await this.goToApartmentPlanScreen(app);\n          console.log(\"[ViewManager] Registration next button clicked. Moving to apartment plan screen.\");\n        });\n      }\n    }\n\n    // If selfie-screen: the capture and complete buttons are static in index.html\n    if (screenId === \"selfie-screen\") {\n      const captureBtn = document.getElementById('capture-btn');\n      if (captureBtn) {\n        captureBtn.onclick = () => {\n          console.log(\"Capture button clicked. Capturing selfie...\");\n          this.captureSelfie(app);\n        };\n      } else {\n        console.error(\"Capture button (id='capture-btn') not found in the DOM.\");\n      }\n      const completeBtn = document.getElementById('complete-registration');\n      if (completeBtn) {\n        completeBtn.onclick = () => {\n          console.log(\"Complete registration button clicked.\");\n          this.completeRegistration(app);\n        };\n      } else {\n        console.error(\"Complete registration button (id='complete-registration') not found in the DOM.\");\n      }\n    }\n\n    // If apartment-plan-screen\n    if (screenId === \"apartment-plan-screen\" && app) {\n      const prevFloorBtn = document.getElementById(\"prev-floor-btn\");\n      if (prevFloorBtn) {\n        prevFloorBtn.addEventListener(\"click\", () => {\n          if (app.apartmentPlanManager) {\n            app.apartmentPlanManager.prevFloor();\n          }\n        });\n      }\n      const nextFloorBtn = document.getElementById(\"next-floor-btn\");\n      if (nextFloorBtn) {\n        nextFloorBtn.addEventListener(\"click\", () => {\n          if (app.apartmentPlanManager) {\n            app.apartmentPlanManager.nextFloor();\n          }\n        });\n      }\n      const planNextBtn = targetScreen.querySelector('#apartment-plan-next-btn');\n      if (planNextBtn) {\n        planNextBtn.addEventListener('click', () => {\n          console.log(\"Apartment Plan next button clicked. Going to selfie screen.\");\n          this.goToSelfieScreen(app);\n        });\n      }\n    }\n\n    // Hide all groups in the controls panel, then show the relevant group\n    document.querySelectorAll('#controls-panel > .buttons').forEach(group => {\n      group.style.display = 'none';\n      group.style.pointerEvents = 'none';\n    });\n    if (buttonsGroupId) {\n      const targetGroup = document.getElementById(buttonsGroupId);\n      if (targetGroup) {\n        targetGroup.style.display = 'flex';\n        targetGroup.style.pointerEvents = 'auto';\n        // On main-screen, hide toggle-diary and btn_shoot to avoid confusion\n        if (screenId === \"main-screen\") {\n          const td = targetGroup.querySelector(\"#toggle-diary\");\n          if (td) td.style.display = \"none\";\n          const shootBtn = targetGroup.querySelector(\"#btn_shoot\");\n          if (shootBtn) shootBtn.style.display = \"none\";\n        }\n        console.log(`[ViewManager] Controls panel updated for group: ${buttonsGroupId}`);\n      }\n    }\n\n    // Make the chat button visible\n    const chatContainer = document.getElementById(\"chat-button-container\");\n    if (chatContainer) {\n      chatContainer.style.display = 'flex';\n      chatContainer.style.pointerEvents = 'auto';\n      console.log(\"[ViewManager] Chat button container set to visible.\");\n    }\n\n    // Show/hide the global language container depending on the screen\n    const languageContainer = document.getElementById(\"language-container\");\n    if (languageContainer) {\n      if (screenId === \"landing-screen\") {\n        languageContainer.style.display = \"block\";\n      } else {\n        languageContainer.style.display = \"none\";\n      }\n    }\n  }\n  showToggleCameraButton() {\n    if (this.toggleCameraBtn) {\n      this.toggleCameraBtn.style.display = 'inline-block';\n      console.log(\"[ViewManager] Toggle Camera button shown.\");\n    }\n  }\n  updateProfileDisplay(profile) {\n    const profileNameElem = document.getElementById('profile-name');\n    const profilePhotoElem = document.getElementById('profile-photo');\n    if (profileNameElem) {\n      profileNameElem.textContent = profile.name;\n    }\n    if (profilePhotoElem) {\n      profilePhotoElem.src = profile.selfie;\n      profilePhotoElem.style.display = 'block';\n    }\n    console.log(\"[ViewManager] Profile display updated.\");\n  }\n  updateSelfiePreview(imageData) {\n    const selfiePreview = document.getElementById('selfie-thumbnail');\n    if (selfiePreview) {\n      selfiePreview.src = imageData;\n      selfiePreview.style.display = 'block';\n      console.log(\"[ViewManager] Selfie preview updated.\");\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Selfie preview element not found.\", \"updateSelfiePreview\");\n    }\n  }\n  enableCompleteButton() {\n    const completeBtn = document.getElementById('complete-registration');\n    if (completeBtn) {\n      completeBtn.disabled = false;\n      console.log(\"[ViewManager] Complete button enabled.\");\n    }\n  }\n  disableCompleteButton() {\n    const completeBtn = document.getElementById('complete-registration');\n    if (completeBtn) {\n      completeBtn.disabled = true;\n      console.log(\"[ViewManager] Complete button disabled.\");\n    }\n  }\n  getSelfieSource() {\n    const selfiePreview = document.getElementById('selfie-thumbnail');\n    return selfiePreview ? selfiePreview.src : \"\";\n  }\n  getImportFile() {\n    const importFileInput = document.getElementById('import-file');\n    if (importFileInput && importFileInput.files.length > 0) {\n      return importFileInput.files[0];\n    }\n    return null;\n  }\n  showGlobalCamera() {\n    if (this.globalCamera) {\n      this.globalCamera.style.display = 'block';\n      console.log(\"[ViewManager] Global camera displayed.\");\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Global camera element not found.\", \"showGlobalCamera\");\n    }\n  }\n  hideGlobalCamera() {\n    if (this.globalCamera) {\n      this.globalCamera.style.display = 'none';\n      console.log(\"[ViewManager] Global camera hidden.\");\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Global camera element not found.\", \"hideGlobalCamera\");\n    }\n  }\n  showDiaryView() {\n    const diary = document.getElementById(\"diary\");\n    if (diary && this.globalCamera) {\n      diary.style.display = \"block\";\n      this.globalCamera.style.display = \"none\";\n      if (this.toggleCameraBtn) this.toggleCameraBtn.style.display = 'inline-block';\n      if (this.toggleDiaryBtn) this.toggleDiaryBtn.style.display = \"none\";\n      const shootBtn = document.getElementById(\"btn_shoot\");\n      if (shootBtn) shootBtn.style.display = \"none\";\n      this.showPostButton();\n      console.log(\"[ViewManager] Switched to diary view.\");\n    }\n  }\n  showCameraView() {\n    const diary = document.getElementById(\"diary\");\n    if (diary && this.globalCamera) {\n      diary.style.display = \"none\";\n      this.globalCamera.style.display = \"flex\";\n      if (this.toggleCameraBtn) this.toggleCameraBtn.style.display = 'none';\n      if (this.toggleDiaryBtn) this.toggleDiaryBtn.style.display = 'inline-block';\n      this.hidePostButton();\n      const shootBtn = document.getElementById(\"btn_shoot\");\n      if (shootBtn) {\n        shootBtn.style.display = \"inline-block\";\n        console.log(\"[ViewManager] Shoot button shown for camera view; quest UI will manage its enabled state.\");\n      }\n      console.log(\"[ViewManager] Switched to camera view.\");\n    }\n  }\n  showPostButton() {\n    if (this.postBtn) {\n      this.postBtn.style.display = 'inline-block';\n      console.log(\"[ViewManager] Post button shown.\");\n    }\n  }\n  hidePostButton() {\n    if (this.postBtn) {\n      this.postBtn.style.display = 'none';\n      console.log(\"[ViewManager] Post button hidden.\");\n    }\n  }\n\n  /**\n   * setPostButtonEnabled\n   * Sets the Post button state.\n   * The passed parameter (isEnabled) is assumed to be pre-computed based on the universal quest state,\n   * such as the presence of an active quest key (\"activeQuestKey\").\n   */\n  setPostButtonEnabled(isEnabled) {\n    const postBtn = document.getElementById(\"post-btn\");\n    if (postBtn) {\n      const gameFinalized = _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.get(_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.GAME_FINALIZED) === \"true\";\n      if (gameFinalized) {\n        postBtn.disabled = true;\n        _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.POST_BUTTON_DISABLED, \"true\");\n        console.log(\"[ViewManager] Game finalized. Post button disabled.\");\n      } else {\n        postBtn.disabled = !isEnabled;\n        _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.POST_BUTTON_DISABLED, isEnabled ? \"false\" : \"true\");\n        console.log(`[ViewManager] Post button set to ${isEnabled ? \"enabled\" : \"disabled\"}.`);\n      }\n    }\n  }\n\n  /**\n   * setCameraButtonActive\n   * Sets the active state of the camera button.\n   */\n  setCameraButtonActive(isActive) {\n    const cameraBtn = document.getElementById(\"toggle-camera\");\n    if (cameraBtn) {\n      if (isActive) {\n        cameraBtn.classList.add(\"active\");\n      } else {\n        cameraBtn.classList.remove(\"active\");\n      }\n      // Optionally, you might remove the old fixed key and rely on universal state instead.\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(_StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.KEYS.CAMERA_BUTTON_ACTIVE, JSON.stringify(isActive));\n      console.log(`[ViewManager] Camera button active state set to ${isActive}.`);\n    }\n  }\n\n  /**\n   * restoreCameraButtonState\n   * Restores the camera button state based on the universal quest state (\"activeQuestKey\").\n   */\n  restoreCameraButtonState() {\n    const activeQuestKey = _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.getActiveQuestKey();\n    // If an active quest is present, assume camera button should be active.\n    const isActive = activeQuestKey ? true : false;\n    this.setCameraButtonActive(isActive);\n    console.log(\"[ViewManager] Camera button state restored using activeQuestKey:\", isActive);\n  }\n\n  /**\n   * setShootButtonActive\n   * Sets the active state of the Shoot button.\n   */\n  setShootButtonActive(isActive) {\n    const shootBtn = document.getElementById(\"btn_shoot\");\n    if (shootBtn) {\n      // disabled и pointerEvents в одном месте\n      shootBtn.disabled = !isActive;\n      shootBtn.style.pointerEvents = isActive ? \"auto\" : \"none\";\n      if (isActive) {\n        shootBtn.classList.add(\"active\");\n      } else {\n        shootBtn.classList.remove(\"active\");\n      }\n      console.log(`[ViewManager] Shoot button active state set to ${isActive}.`);\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Shoot button not found.\", \"setShootButtonActive\");\n    }\n  }\n\n  /**\n   * restoreShootButtonState\n   * Restores the Shoot button state based on the universal quest state (\"activeQuestKey\").\n   */\n  restoreShootButtonState() {\n    // Always start with Shoot disabled on page load.\n    this.setShootButtonActive(false);\n    console.log(\"[ViewManager] Shoot button state reset to disabled on restore.\");\n  }\n  setApartmentPlanNextButtonEnabled(isEnabled) {\n    const nextBtn = document.getElementById(\"apartment-plan-next-btn\");\n    if (nextBtn) {\n      nextBtn.disabled = !isEnabled;\n      console.log(`Apartment Plan Next button is now ${isEnabled ? \"enabled\" : \"disabled\"}.`);\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Apartment plan Next button not found.\", \"setApartmentPlanNextButtonEnabled\");\n    }\n  }\n  startMirrorQuestUI(options) {\n    const statusElem = document.getElementById(options.statusElementId);\n    if (statusElem) {\n      statusElem.style.display = \"block\";\n      statusElem.textContent = \"No match...\";\n      console.log(\"[ViewManager] Mirror quest UI started, status set to 'No match...'\");\n    }\n    const shootBtn = document.getElementById(options.shootButtonId);\n    if (shootBtn) {\n      shootBtn.style.display = \"inline-block\";\n      const initialActive = typeof options.initialActive !== 'undefined' ? options.initialActive : false;\n      this.setShootButtonActive(initialActive);\n      shootBtn.style.pointerEvents = initialActive ? \"auto\" : \"none\";\n      shootBtn.onclick = () => {\n        this.setShootButtonActive(false);\n        if (typeof options.onShoot === 'function') {\n          options.onShoot();\n        }\n      };\n      console.log(\"[ViewManager] Shoot button for mirror quest initialized.\");\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Shoot button not found in the DOM.\", \"startMirrorQuestUI\");\n    }\n  }\n  updateMirrorQuestStatus(success, statusElementId, shootButtonId) {\n    const statusElem = document.getElementById(statusElementId);\n    if (statusElem) {\n      statusElem.textContent = success ? \"You are in front of the mirror!\" : \"No match...\";\n    }\n    const shootBtn = document.getElementById(shootButtonId);\n    if (shootBtn) {\n      shootBtn.disabled = !success;\n      shootBtn.style.pointerEvents = success ? \"auto\" : \"none\";\n    }\n    console.log(`[ViewManager] Mirror quest status updated. Success: ${success}`);\n  }\n  stopMirrorQuestUI(statusElementId) {\n    const statusElem = document.getElementById(statusElementId);\n    if (statusElem) {\n      statusElem.style.display = \"none\";\n    }\n    this.setCameraButtonActive(false);\n    this.setShootButtonActive(false);\n    console.log(\"[ViewManager] Mirror quest UI stopped.\");\n  }\n\n  /**\n   * startRepeatingQuestUI\n   * Displays the current target item and stage, and enables the Shoot button.\n   * @param {{ statusElementId: string, shootButtonId: string, stage: number, totalStages: number, target?: string, onShoot: Function, quest?: Object }} options\n   */\n  startRepeatingQuestUI(options) {\n    const statusElem = document.getElementById(options.statusElementId);\n    if (statusElem) {\n      statusElem.style.display = 'block';\n      statusElem.textContent = `Stage ${options.stage} of ${options.totalStages}: find \"${options.quest.currentTarget}\"`;\n    }\n    const shootBtn = document.getElementById(options.shootButtonId);\n    if (shootBtn) {\n      shootBtn.style.display = 'inline-block';\n      // English comment: disable Shoot by default until AI confirms detection\n      this.setShootButtonActive(false);\n      shootBtn.style.pointerEvents = 'none';\n      shootBtn.onclick = () => {\n        // English comment: prevent click if quest already finished\n        if (options.quest && options.quest.finished) {\n          console.log(\"[ViewManager] Quest is finished; ignoring Shoot click.\");\n          return;\n        }\n        // English comment: turn off again to avoid double clicks\n        this.setShootButtonActive(false);\n        if (typeof options.onShoot === \"function\") {\n          options.onShoot();\n        }\n      };\n      console.log(\"[ViewManager] Shoot button for repeating quest initialized.\");\n    } else {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Shoot button not found in the DOM.\", \"startRepeatingQuestUI\");\n    }\n  }\n  disableShootButton(shootButtonId) {\n    const shootBtn = document.getElementById(shootButtonId);\n    if (shootBtn) {\n      shootBtn.disabled = true;\n      shootBtn.style.pointerEvents = \"none\";\n      console.log(\"[ViewManager] Shoot button disabled.\");\n    }\n  }\n  stopRepeatingQuestUI(statusElementId) {\n    const statusElem = document.getElementById(statusElementId);\n    if (statusElem) {\n      statusElem.style.display = \"none\";\n    }\n    this.setCameraButtonActive(false);\n    this.setShootButtonActive(false);\n    console.log(\"[ViewManager] Repeating quest UI stopped.\");\n  }\n  updateUIAfterQuestStage({\n    postEnabled,\n    cameraActive,\n    shootActive\n  }) {\n    if (typeof postEnabled === 'boolean') {\n      this.setPostButtonEnabled(postEnabled);\n    }\n    if (typeof cameraActive === 'boolean') {\n      this.setCameraButtonActive(cameraActive);\n    }\n    if (typeof shootActive === 'boolean') {\n      this.setShootButtonActive(shootActive);\n    }\n    console.log(\"[ViewManager] UI updated after quest stage:\", {\n      postEnabled,\n      cameraActive,\n      shootActive\n    });\n  }\n  createTopCameraControls() {\n    const existing = document.getElementById(\"top-camera-controls\");\n    if (existing) existing.remove();\n    const topControls = document.createElement(\"div\");\n    topControls.id = \"top-camera-controls\";\n    Object.assign(topControls.style, {\n      position: \"fixed\",\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      padding: \"10px\",\n      background: \"rgba(0, 0, 0, 0.5)\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      zIndex: \"2100\"\n    });\n    const arBtn = document.createElement(\"button\");\n    arBtn.className = \"button is-info\";\n    arBtn.innerText = \"AR Mode\";\n    arBtn.onclick = () => {\n      if (this.cameraManager) {\n        this.cameraManager.startARMode();\n      }\n    };\n    topControls.appendChild(arBtn);\n    const aiBtn = document.createElement(\"button\");\n    aiBtn.className = \"button is-primary\";\n    aiBtn.style.marginLeft = \"10px\";\n    aiBtn.innerText = \"Start AI Detection\";\n    aiBtn.onclick = () => {\n      if (this.cameraManager) {\n        this.cameraManager.startAIDetection();\n      }\n    };\n    topControls.appendChild(aiBtn);\n    const nightVisionBtn = document.createElement(\"button\");\n    nightVisionBtn.className = \"button is-warning\";\n    nightVisionBtn.style.marginLeft = \"10px\";\n    nightVisionBtn.innerText = \"Night Vision\";\n    nightVisionBtn.onclick = () => {\n      if (this.cameraManager) {\n        this.cameraManager.applyFilter('nightVision');\n      }\n    };\n    topControls.appendChild(nightVisionBtn);\n    const blackWhiteBtn = document.createElement(\"button\");\n    blackWhiteBtn.className = \"button is-warning\";\n    blackWhiteBtn.style.marginLeft = \"10px\";\n    blackWhiteBtn.innerText = \"Black & White\";\n    blackWhiteBtn.onclick = () => {\n      if (this.cameraManager) {\n        this.cameraManager.applyFilter('blackWhite');\n      }\n    };\n    topControls.appendChild(blackWhiteBtn);\n    const clearFilterBtn = document.createElement(\"button\");\n    clearFilterBtn.className = \"button\";\n    clearFilterBtn.style.marginLeft = \"10px\";\n    clearFilterBtn.innerText = \"Clear Filter\";\n    clearFilterBtn.onclick = () => {\n      if (this.cameraManager) {\n        this.cameraManager.applyFilter('');\n      }\n    };\n    topControls.appendChild(clearFilterBtn);\n    document.body.appendChild(topControls);\n    console.log(\"[ViewManager] Top camera controls created.\");\n  }\n  applyBackgroundTransition(color, duration) {\n    document.body.style.transition = `background ${duration}ms`;\n    document.body.style.background = color;\n    setTimeout(() => {\n      document.body.style.background = \"\";\n    }, duration);\n    console.log(`[ViewManager] Applied background transition with color ${color} for ${duration}ms.`);\n  }\n  showGhostAppearanceEffect(ghostId) {\n    const ghostEffect = document.createElement(\"div\");\n    Object.assign(ghostEffect.style, {\n      position: \"absolute\",\n      top: \"50%\",\n      left: \"50%\",\n      transform: \"translate(-50%, -50%)\",\n      width: \"200px\",\n      height: \"200px\",\n      background: `url('${_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.BASE_PATH}/assets/images/${ghostId}.png') no-repeat center center`,\n      backgroundSize: \"contain\",\n      opacity: \"0.7\",\n      transition: \"opacity 2s\"\n    });\n    document.body.appendChild(ghostEffect);\n    setTimeout(() => {\n      ghostEffect.style.opacity = \"0\";\n    }, 3000);\n    setTimeout(() => {\n      ghostEffect.remove();\n    }, 5000);\n    console.log(`[ViewManager] Ghost appearance effect triggered for ghost ${ghostId}.`);\n  }\n  showNotification(message) {\n    const notification = document.createElement(\"div\");\n    notification.textContent = message;\n    Object.assign(notification.style, {\n      position: \"fixed\",\n      bottom: \"20px\",\n      left: \"50%\",\n      transform: \"translateX(-50%)\",\n      backgroundColor: \"rgba(0,0,0,0.8)\",\n      color: \"white\",\n      padding: \"10px 20px\",\n      borderRadius: \"5px\",\n      zIndex: 10000,\n      opacity: \"0\",\n      transition: \"opacity 0.5s\"\n    });\n    document.body.appendChild(notification);\n    setTimeout(() => {\n      notification.style.opacity = \"1\";\n    }, 100);\n    setTimeout(() => {\n      notification.style.opacity = \"0\";\n      setTimeout(() => {\n        notification.remove();\n      }, 500);\n    }, 3000);\n    console.log(\"[ViewManager] Notification shown:\", message);\n  }\n  setControlsBlocked(shouldBlock) {\n    if (this.controlsPanel) {\n      this.controlsPanel.style.pointerEvents = shouldBlock ? \"none\" : \"auto\";\n      console.log(`[ViewManager] Controls ${shouldBlock ? \"blocked\" : \"unblocked\"}.`);\n    }\n  }\n  clearCache() {\n    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage({\n        action: 'CLEAR_CACHE'\n      });\n      console.log(\"Clear cache message sent to Service Worker.\");\n    } else {\n      console.warn(\"No active Service Worker controller found.\");\n    }\n  }\n\n  // ------------------ Modified goToApartmentPlanScreen ------------------\n  async goToApartmentPlanScreen(app) {\n    const regData = this.getRegistrationData();\n    if (!regData) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.showError(\"Registration data missing.\");\n      return;\n    }\n    _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set('regData', JSON.stringify(regData));\n    // Await the template loading so that the container is in the DOM.\n    await this.switchScreen('apartment-plan-screen', 'apartment-plan-buttons', app);\n    if (!app.apartmentPlanManager) {\n      app.apartmentPlanManager = new _ApartmentPlanManager_js__WEBPACK_IMPORTED_MODULE_4__.ApartmentPlanManager('apartment-plan-container', app.databaseManager, app);\n    }\n  }\n  // --------------------------------------------------------------------\n\n  goToSelfieScreen(app) {\n    this.switchScreen('selfie-screen', 'selfie-buttons', app);\n    this.showGlobalCamera();\n    if (app.cameraSectionManager) {\n      app.cameraSectionManager.startCamera();\n    }\n    this.disableCompleteButton();\n  }\n  captureSelfie(app) {\n    const video = app.cameraSectionManager.videoElement;\n    if (!video || !video.srcObject) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Camera is not active!\", \"captureSelfie\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.showError(\"Error: Camera is not active.\");\n      return;\n    }\n    if (video.readyState < 2) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(\"Camera is not ready yet.\", \"captureSelfie\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.showError(\"Please wait for the camera to load.\");\n      return;\n    }\n    try {\n      const canvas = document.createElement('canvas');\n      canvas.width = video.videoWidth || 640;\n      canvas.height = video.videoHeight || 480;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        throw new Error(\"Failed to get 2D drawing context.\");\n      }\n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n      const grayscaleData = _utils_ImageUtils_js__WEBPACK_IMPORTED_MODULE_3__.ImageUtils.convertToGrayscale(canvas);\n      this.updateSelfiePreview(grayscaleData);\n      this.enableCompleteButton();\n      app.selfieData = grayscaleData;\n      console.log(\"✅ Selfie captured successfully!\");\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.logError(error, \"captureSelfie\");\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.showError(\"Error capturing selfie! Please try again.\");\n    }\n  }\n  completeRegistration(app) {\n    const selfieSrc = this.getSelfieSource();\n    if (!selfieSrc || selfieSrc === \"\") {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.showError(\"Please capture your selfie before completing registration.\");\n      return;\n    }\n    const regDataStr = _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.get('regData');\n    if (!regDataStr) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.showError(\"Registration data missing.\");\n      return;\n    }\n    const regData = JSON.parse(regDataStr);\n    const profile = {\n      name: regData.name,\n      gender: regData.gender,\n      language: this.languageSelector ? this.languageSelector.value : 'en',\n      selfie: selfieSrc\n    };\n    app.profileManager.saveProfile(profile).then(() => {\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.set(\"registrationCompleted\", \"true\");\n      app.cameraSectionManager.stopCamera();\n      this.hideGlobalCamera();\n      this.switchScreen('main-screen', 'main-buttons', app);\n      this.showToggleCameraButton();\n      // Use universal activeQuestKey to determine Post button state.\n      const activeQuestKey = _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.getActiveQuestKey();\n      this.setPostButtonEnabled(Boolean(activeQuestKey));\n      app.profileManager.getProfile().then(profile => {\n        this.updateProfileDisplay(profile);\n        app.selfieData = profile.selfie;\n      });\n      app.gameEventManager.autoLaunchWelcomeEvent();\n    });\n  }\n\n  /**\n   * toggleCameraView\n   * Switches between camera view and diary view, and persists the camera-open state.\n   */\n  toggleCameraView(app) {\n    if (!app.isCameraOpen) {\n      this.showCameraView();\n      // Mark camera as open in memory and in persistent state\n      app.isCameraOpen = true;\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.setCameraOpen(true);\n      app.cameraSectionManager.startCamera();\n      console.log(\"Camera opened and state saved.\");\n    } else {\n      this.showDiaryView();\n      app.cameraSectionManager.stopCamera();\n      // Mark camera as closed in memory and in persistent state\n      app.isCameraOpen = false;\n      _StateManager_js__WEBPACK_IMPORTED_MODULE_1__.StateManager.setCameraOpen(false);\n      console.log(\"Camera closed and state saved.\");\n    }\n  }\n  exportProfile(app) {\n    app.profileManager.exportProfileData(app.databaseManager, app.apartmentPlanManager);\n  }\n  importProfile(app) {\n    const file = this.getImportFile();\n    if (!file) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_2__.ErrorManager.showError(\"Please select a profile file to import.\");\n      return;\n    }\n    app.profileManager.importProfileData(file, app.databaseManager, app.apartmentPlanManager);\n  }\n  toggleChat(app) {\n    if (app.chatManager && app.chatManager.container) {\n      if (app.chatManager.container.style.display === 'block') {\n        app.chatManager.hide();\n      } else {\n        app.chatManager.show();\n      }\n    } else {\n      console.error(\"ChatManager is not initialized or chat container not found.\");\n    }\n  }\n  showLocationTypeModal(onConfirm, onCancel) {\n    const modalOverlay = document.createElement(\"div\");\n    modalOverlay.id = \"location-type-modal-overlay\";\n    Object.assign(modalOverlay.style, {\n      position: \"fixed\",\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      backgroundColor: \"rgba(0,0,0,0.5)\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      zIndex: \"3000\"\n    });\n    const modal = document.createElement(\"div\");\n    modal.id = \"location-type-modal\";\n    Object.assign(modal.style, {\n      backgroundColor: \"#fff\",\n      padding: \"20px\",\n      borderRadius: \"8px\",\n      maxWidth: \"400px\",\n      width: \"90%\",\n      textAlign: \"center\"\n    });\n    const title = document.createElement(\"h3\");\n    title.textContent = \"Select location type\";\n    modal.appendChild(title);\n    const selectElem = document.createElement(\"select\");\n    const locationTypes = [\"Kitchen\", \"Bedroom\", \"Living Room\", \"Bathroom\", \"Corridor\", \"Other\", \"Entrance\", \"Office\", \"Library\", \"Kids Room\", \"Storage\", \"Garage\"];\n    locationTypes.forEach(type => {\n      const option = document.createElement(\"option\");\n      option.value = type;\n      option.textContent = type;\n      selectElem.appendChild(option);\n    });\n    selectElem.value = \"Other\";\n    selectElem.style.marginBottom = \"15px\";\n    selectElem.style.display = \"block\";\n    selectElem.style.width = \"100%\";\n    modal.appendChild(selectElem);\n    const btnContainer = document.createElement(\"div\");\n    btnContainer.style.marginTop = \"15px\";\n    const confirmBtn = document.createElement(\"button\");\n    confirmBtn.textContent = \"Confirm\";\n    confirmBtn.style.marginRight = \"10px\";\n    confirmBtn.addEventListener(\"click\", () => {\n      console.log(\"Confirm button clicked, selected type:\", selectElem.value);\n      const selectedType = selectElem.value;\n      if (onConfirm) onConfirm(selectedType);\n      setTimeout(() => {\n        modalOverlay.remove();\n      }, 50);\n    });\n    btnContainer.appendChild(confirmBtn);\n    const cancelBtn = document.createElement(\"button\");\n    cancelBtn.textContent = \"Cancel\";\n    cancelBtn.addEventListener(\"click\", () => {\n      console.log(\"Cancel button clicked.\");\n      if (onCancel) onCancel();\n      modalOverlay.remove();\n    });\n    btnContainer.appendChild(cancelBtn);\n    modal.appendChild(btnContainer);\n    modalOverlay.appendChild(modal);\n    document.body.appendChild(modalOverlay);\n  }\n\n  /**\n   * renderDiary\n   * Renders the diary entries from the database into the diary container.\n   * Now checks if entry text *contains* base64 data (`data:image`) anywhere;\n   * if found, we separate text + image and render them properly.\n   */\n  renderDiary(entries, currentLanguage, visualEffectsManager) {\n    if (!this.diaryContainer) {\n      console.error(\"Diary container not set. Cannot render diary entries.\");\n      return;\n    }\n    this.diaryContainer.innerHTML = \"\";\n    if (!entries || entries.length === 0) {\n      const emptyMessage = this.languageManager && this.languageManager.translate(\"no_diary_entries\", \"Diary is empty.\") || \"Diary is empty.\";\n      const emptyDiv = document.createElement(\"div\");\n      emptyDiv.className = \"diary-empty\";\n      emptyDiv.textContent = emptyMessage;\n      this.diaryContainer.appendChild(emptyDiv);\n      return;\n    }\n    entries.forEach(entry => {\n      let rendered;\n      if (entry.entry.includes(\"data:image\")) {\n        // Находим начало base64\n        const full = entry.entry;\n        const idx = full.indexOf(\"data:image\");\n        const textLines = full.slice(0, idx).trim();\n        const base64Line = full.slice(idx).trim();\n        const entryWithImageTemplate = `\n          <div class=\"diary-entry {{postClass}}\" data-animate-on-board=\"true\">\n            <p>{{text}}</p>\n            <img src=\"{{img}}\" alt=\"Diary Image\" data-animate-on-board=\"true\" />\n            <span class=\"diary-timestamp\">{{timestamp}}</span>\n          </div>\n        `;\n        rendered = _utils_TemplateEngine_js__WEBPACK_IMPORTED_MODULE_5__.TemplateEngine.render(entryWithImageTemplate, {\n          postClass: entry.postClass,\n          text: textLines,\n          img: base64Line,\n          timestamp: entry.timestamp\n        });\n      } else {\n        const diaryEntryTemplate = `\n          <div class=\"diary-entry {{postClass}}\" data-animate-on-board=\"true\">\n            <p>{{entry}}</p>\n            <span class=\"diary-timestamp\">{{timestamp}}</span>\n          </div>\n        `;\n        rendered = _utils_TemplateEngine_js__WEBPACK_IMPORTED_MODULE_5__.TemplateEngine.render(diaryEntryTemplate, {\n          postClass: entry.postClass,\n          entry: entry.entry,\n          timestamp: entry.timestamp\n        });\n      }\n      this.diaryContainer.innerHTML += rendered;\n    });\n    console.log(\"[ViewManager] Diary updated with \" + entries.length + \" entries.\");\n  }\n\n  /**\n   * Loads and renders the latest `limit` diary posts, newest first.\n   */\n  async loadLatestDiaryPosts(limit = 3) {\n    // Получаем все записи\n    const entries = await this.app.databaseManager.getDiaryEntries();\n    // Сортируем по timestamp: от новых к старым\n    entries.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n    // Берём первые `limit` самых свежих\n    const latest = entries.slice(0, limit);\n    // Рендерим\n    this.renderDiary(latest, this.app.languageManager.getLanguage(), this.app.visualEffectsManager);\n  }\n\n  /**\n   * Inserts a single diary post without re‑rendering the whole list.\n   * @param {Object} entryData { text, img, timestamp, postClass }\n   */\n  async addSingleDiaryPost(entryData) {\n    if (!this.diaryContainer) return;\n\n    // разбираем текст на до изображения и само изображение (если есть)\n    let textPart = entryData.text;\n    let imgSrc = \"\";\n    if (entryData.text.includes(\"data:image\")) {\n      const idx = entryData.text.indexOf(\"data:image\");\n      textPart = entryData.text.slice(0, idx).trim();\n      imgSrc = entryData.text.slice(idx).trim();\n    }\n\n    // строим тег <img> только если нашли base64\n    const imgTag = imgSrc ? `<img src=\"${imgSrc}\" alt=\"Diary image\" />` : \"\";\n\n    // абсолютный URL к шаблону\n    const templateUrl = `${_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.BASE_PATH}/src/templates/diaryentry_screen-template.html`;\n\n    // рендерим, подставляя разделённый текст и картинку\n    const html = await _utils_TemplateEngine_js__WEBPACK_IMPORTED_MODULE_5__.TemplateEngine.renderFile(templateUrl, {\n      postClass: entryData.postClass,\n      text: textPart,\n      imgTag,\n      timestamp: entryData.timestamp\n    });\n\n    // вставляем сверху\n    this.diaryContainer.insertAdjacentHTML(\"afterbegin\", html);\n\n    // запускаем анимацию печатания только для <p>\n    const p = this.diaryContainer.querySelector('.diary-entry:first-child p[data-animate-on-board=\"true\"]');\n    if (p && this.app.visualEffectsManager) {\n      this.app.visualEffectsManager.applyEffectsToNewElements([p]);\n    }\n  }\n  async loadEarlierDiaryPosts(step = 3) {\n    const displayed = this.diaryContainer.querySelectorAll('.diary-entry').length;\n    const allEntries = await this.app.databaseManager.getDiaryEntries();\n    // Сортируем от новых к старым\n    allEntries.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n    // Берём следующий кусок\n    const nextChunk = allEntries.slice(displayed, displayed + step);\n    const templateUrl = `${_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.BASE_PATH}/src/templates/diaryentry_screen-template.html`;\n    for (const entry of nextChunk) {\n      // разбираем текст и картинку\n      let text = entry.entry;\n      let imgTag = \"\";\n      if (text.includes(\"data:image\")) {\n        const idx = text.indexOf(\"data:image\");\n        const imgSrc = text.slice(idx).trim();\n        text = text.slice(0, idx).trim();\n        imgTag = `<img src=\"${imgSrc}\" alt=\"Diary image\" />`;\n      }\n      const html = await _utils_TemplateEngine_js__WEBPACK_IMPORTED_MODULE_5__.TemplateEngine.renderFile(templateUrl, {\n        postClass: entry.postClass,\n        text,\n        imgTag,\n        timestamp: entry.timestamp\n      });\n      this.diaryContainer.insertAdjacentHTML(\"beforeend\", html);\n    }\n  }\n\n  /**\n   * При скролле вниз подгружает ещё по 3 поста.\n   */\n  async onScrollLoadOlder() {\n    if (this.loadingOlderPosts) return;\n    const threshold = 150; // px до низа, чтобы сработало чуть раньше\n    if (window.innerHeight + window.scrollY >= document.documentElement.scrollHeight - threshold) {\n      this.loadingOlderPosts = true;\n      await this.loadEarlierDiaryPosts();\n      this.loadingOlderPosts = false;\n    }\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/ViewManager.js?");

/***/ }),

/***/ "./src/managers/VisualEffectsManager.js":
/*!**********************************************!*\
  !*** ./src/managers/VisualEffectsManager.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseEffect: () => (/* binding */ BaseEffect),\n/* harmony export */   TypewriterEffect: () => (/* binding */ TypewriterEffect),\n/* harmony export */   VisualEffectsManager: () => (/* binding */ VisualEffectsManager)\n/* harmony export */ });\n/* harmony import */ var _config_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/paths.js */ \"./src/config/paths.js\");\n/* harmony import */ var _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ErrorManager.js */ \"./src/managers/ErrorManager.js\");\n\n\n\n/**\n * VisualEffectsManager\n *\n * Manages visual effects (fades, animations, transitions) for the application.\n * It delegates UI updates to the ViewManager when available and uses ErrorManager\n * for error handling.\n *\n * @param {App} appInstance - Reference to the main application instance.\n * @param {HTMLElement} controlsPanel - The controls panel element used for blocking interactions.\n */\nclass VisualEffectsManager {\n  constructor(appInstance, controlsPanel) {\n    this.app = appInstance;\n    this.controlsPanel = controlsPanel;\n    // Default effect configuration (can be updated from external config)\n    this.effectConfig = {\n      userText: {\n        speed: 100\n      },\n      ghostText: {\n        speed: 100\n      }\n    };\n  }\n\n  /**\n   * playAudioWithStop\n   * Plays an audio file and stops it automatically after the specified delay.\n   *\n   * @param {string} audioSrc - Path to the audio file.\n   * @param {number} stopDelay - Time in milliseconds after which to stop playback.\n   * @returns {HTMLAudioElement|null} The audio object, or null if an error occurred.\n   */\n  playAudioWithStop(audioSrc, stopDelay) {\n    try {\n      const audio = new Audio(audioSrc);\n      audio.play();\n      if (stopDelay && stopDelay > 0) {\n        setTimeout(() => {\n          audio.pause();\n        }, stopDelay);\n      }\n      return audio;\n    } catch (error) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(error, \"playAudioWithStop\");\n      return null;\n    }\n  }\n\n  /**\n   * setControlsBlocked\n   * Blocks or unblocks user interaction with the controls.\n   * Delegates to the ViewManager if available.\n   *\n   * @param {boolean} shouldBlock - True to block controls, false to unblock.\n   */\n  setControlsBlocked(shouldBlock) {\n    // Do not block controls if the camera is open.\n    if (this.app.isCameraOpen) {\n      shouldBlock = false;\n    }\n    if (this.app.viewManager && typeof this.app.viewManager.setControlsBlocked === 'function') {\n      this.app.viewManager.setControlsBlocked(shouldBlock);\n    } else if (this.controlsPanel) {\n      try {\n        this.controlsPanel.style.pointerEvents = shouldBlock ? \"none\" : \"auto\";\n      } catch (error) {\n        _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(error, \"setControlsBlocked\");\n      }\n    }\n  }\n\n  /**\n   * animateHTMLText\n   * Animates HTML text by \"typing\" it into the target element.\n   *\n   * @param {HTMLElement} targetElem - The target element for text animation.\n   * @param {string} text - The text (including HTML tags) to animate.\n   * @param {number} speed - Typing speed in milliseconds.\n   * @param {HTMLAudioElement} [audioObj] - Optional audio object to play during animation.\n   * @param {Function} [callback] - Callback invoked after animation completes.\n   * @param {Function} [onChar] - Callback invoked after each character is inserted.\n   */\n  animateHTMLText(targetElem, text, speed, audioObj, callback, onChar) {\n    targetElem.innerHTML = \"\";\n    let pos = 0;\n    let currentHTML = \"\";\n    let isTag = false;\n    let tagBuffer = \"\";\n    const intervalId = setInterval(() => {\n      const char = text[pos];\n      if (!char) {\n        clearInterval(intervalId);\n        if (audioObj) audioObj.pause();\n        if (callback) callback();\n        return;\n      }\n      // If the character is a newline, insert a <br>\n      if (char === \"\\n\") {\n        currentHTML += \"<br>\";\n      } else {\n        // Check for HTML tags.\n        if (char === \"<\") {\n          isTag = true;\n        }\n        if (isTag) {\n          tagBuffer += char;\n          if (char === \">\") {\n            currentHTML += tagBuffer;\n            tagBuffer = \"\";\n            isTag = false;\n          }\n        } else {\n          currentHTML += char;\n        }\n      }\n      targetElem.innerHTML = currentHTML;\n      pos++;\n      if (typeof onChar === \"function\") {\n        onChar(targetElem, currentHTML);\n      }\n    }, speed);\n  }\n\n  /**\n   * triggerMirrorEffect\n   * Triggers the mirror effect by applying a background transition and playing a ringtone.\n   * Delegates the background transition to the ViewManager when available.\n   */\n  triggerMirrorEffect() {\n    if (!this.app.isCameraOpen) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(\"Mirror effect not triggered: camera is closed.\", \"triggerMirrorEffect\");\n      return;\n    }\n    if (this.app.viewManager && typeof this.app.viewManager.applyBackgroundTransition === 'function') {\n      // Delegate background transition to ViewManager.\n      this.app.viewManager.applyBackgroundTransition(\"black\", 1000);\n    } else {\n      try {\n        // Fallback: Direct DOM manipulation.\n        document.body.style.transition = \"background 1s\";\n        document.body.style.background = \"black\";\n        setTimeout(() => {\n          document.body.style.background = \"\";\n        }, 1000);\n      } catch (error) {\n        _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(error, \"triggerMirrorEffect - fallback\");\n      }\n    }\n    // Play the ringtone audio for 3 seconds.\n    this.playAudioWithStop(`${_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.ASSETS_PATH}/audio/phone_ringtone.mp3`, 3000);\n  }\n\n  /**\n   * triggerGhostAppearanceEffect\n   * Triggers the ghost appearance effect.\n   * Delegates display to ViewManager if available, otherwise uses a fallback.\n   *\n   * @param {string} ghostId - Identifier for the ghost effect image.\n   */\n  triggerGhostAppearanceEffect(ghostId) {\n    if (!this.app.isCameraOpen) {\n      _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(\"Ghost appearance effect not triggered: camera is closed.\", \"triggerGhostAppearanceEffect\");\n      return;\n    }\n    if (this.app.viewManager && typeof this.app.viewManager.showGhostAppearanceEffect === 'function') {\n      this.app.viewManager.showGhostAppearanceEffect(ghostId);\n    } else {\n      try {\n        // Fallback: Direct DOM manipulation.\n        const ghostEffect = document.createElement(\"div\");\n        Object.assign(ghostEffect.style, {\n          position: \"absolute\",\n          top: \"50%\",\n          left: \"50%\",\n          transform: \"translate(-50%, -50%)\",\n          width: \"200px\",\n          height: \"200px\",\n          background: `url('${_config_paths_js__WEBPACK_IMPORTED_MODULE_0__.ASSETS_PATH}/images/${ghostId}.png') no-repeat center center`,\n          backgroundSize: \"contain\",\n          opacity: \"0.7\",\n          transition: \"opacity 2s\"\n        });\n        document.body.appendChild(ghostEffect);\n        setTimeout(() => {\n          ghostEffect.style.opacity = \"0\";\n        }, 3000);\n        setTimeout(() => {\n          ghostEffect.remove();\n        }, 5000);\n      } catch (error) {\n        _ErrorManager_js__WEBPACK_IMPORTED_MODULE_1__.ErrorManager.logError(error, \"triggerGhostAppearanceEffect - fallback\");\n      }\n    }\n  }\n\n  /**\n   * triggerWhisperEffect\n   * Triggers the whisper effect by playing a whisper audio for 5 seconds.\n   */\n  triggerWhisperEffect() {\n    this.playAudioWithStop('${ASSETS_PATH}/audio/whisper.mp3', 5000);\n  }\n\n  /**\n   * triggerGhostTextEffect\n   * Triggers a ghost text effect by \"typing\" ghostly text into the target element.\n   * Blocks controls during the animation.\n   *\n   * @param {HTMLElement} targetElem - The target element for text animation.\n   * @param {string} text - The ghost text to animate.\n   * @param {Function} callback - Callback invoked after animation completes.\n   * @param {Object} [effectConfig] - Optional configuration for the effect (e.g. speed).\n   */\n  triggerGhostTextEffect(targetElem, text, callback, effectConfig) {\n    // Use provided configuration or default ghostText config.\n    const config = effectConfig || this.effectConfig.ghostText;\n\n    // Block controls.\n    this.setControlsBlocked(true);\n\n    // Play ghost sound.\n    const ghostSound = new Audio('../../../../assets/audio/ghost_effect.mp3');\n    ghostSound.play();\n    this.animateHTMLText(targetElem, text, config.speed, ghostSound, () => {\n      this.setControlsBlocked(false);\n      if (callback) callback();\n    });\n  }\n\n  /**\n   * triggerUserTextEffect\n   * Triggers a user text effect that simulates typing with a moving pencil icon.\n   * Blocks controls during the animation.\n   *\n   * @param {HTMLElement} targetElem - The target element for text animation.\n   * @param {string} text - The text to animate.\n   * @param {Function} callback - Callback invoked after animation completes.\n   * @param {Object} [effectConfig] - Optional configuration for the effect (e.g. speed).\n   */\n  triggerUserTextEffect(targetElem, text, callback, effectConfig) {\n    // Use provided configuration or default userText config.\n    const config = effectConfig || this.effectConfig.userText;\n\n    // Create a pencil icon.\n    const pencilIcon = document.createElement(\"img\");\n    pencilIcon.src = \"../../../../assets/images/pencil.png\";\n    pencilIcon.alt = \"Typing...\";\n    Object.assign(pencilIcon.style, {\n      width: \"24px\",\n      height: \"24px\",\n      position: \"absolute\"\n    });\n\n    // Insert the pencil icon into the parent element.\n    const parentElem = targetElem.parentElement;\n    parentElem.style.position = \"relative\";\n    parentElem.insertBefore(pencilIcon, targetElem);\n\n    // Block controls.\n    this.setControlsBlocked(true);\n\n    // Play typing sound.\n    const typeSound = new Audio('../../../../assets/audio/type_sound.mp3');\n    typeSound.loop = true;\n    typeSound.play();\n    const onChar = () => {\n      const dummySpan = document.createElement(\"span\");\n      dummySpan.innerHTML = \"&nbsp;\"; // For positioning.\n      targetElem.appendChild(dummySpan);\n      const rectDummy = dummySpan.getBoundingClientRect();\n      const rectParent = parentElem.getBoundingClientRect();\n      // Update pencil icon position.\n      pencilIcon.style.left = rectDummy.left - rectParent.left + \"px\";\n      pencilIcon.style.top = rectDummy.top - rectParent.top + \"px\";\n      dummySpan.remove();\n    };\n    this.animateHTMLText(targetElem, text, config.speed, typeSound, () => {\n      pencilIcon.remove();\n      this.setControlsBlocked(false);\n      if (callback) callback();\n    }, onChar);\n  }\n\n  /**\n   * slideUpPanel\n   * Animates the appearance of a panel by sliding it up from the bottom.\n   *\n   * @param {HTMLElement} panel - The panel element to animate.\n   * @param {number} duration - Animation duration in milliseconds.\n   * @param {string} soundPath - Path to the sound to play during the animation.\n   */\n  slideUpPanel(panel, duration = 1000, soundPath = 'assets/audio/panel_slide.mp3') {\n    if (!panel) return;\n    // Set initial state: slide the panel out of view (translateY(100%)) and transparent.\n    panel.style.transition = `transform ${duration}ms ease-out, opacity ${duration}ms ease-out`;\n    panel.style.transform = \"translateY(100%)\";\n    panel.style.opacity = \"0\";\n    // Force reflow.\n    panel.offsetHeight;\n    // Play slide-up sound.\n    this.playAudioWithStop(soundPath, duration);\n    // Animate panel into view.\n    panel.style.transform = \"translateY(0)\";\n    panel.style.opacity = \"1\";\n  }\n\n  /**\n   * showControlsPanelForUnregistered\n   * If the user is not registered (i.e. registrationCompleted flag is not \"true\"),\n   * animates the controls panel by sliding it up from the bottom with sound.\n   */\n  showControlsPanelForUnregistered() {\n    if (StateManager.get(\"registrationCompleted\") !== \"true\") {\n      this.slideUpPanel(this.controlsPanel, 1000, 'assets/audio/panel_slide.mp3');\n    }\n  }\n\n  /**\n   * applyEffectsToNewElements\n   * Applies visual effects to newly added DOM elements.\n   * It iterates over the provided elements, checks for a data-attribute \"data-animate-on-board\",\n   * and, depending on the \"data-animate-effect\" attribute (\"ghost\" or \"user\", default \"user\"),\n   * triggers the corresponding text effect. After animation, the marker is removed.\n   *\n   * @param {Array<HTMLElement>} newElements - Array or NodeList of newly added DOM elements.\n   */\n  applyEffectsToNewElements(newElements) {\n    // Ensure we always iterate over a concrete array\n    Array.from(newElements).forEach(elem => {\n      // Gather only <p data-animate-on-board=\"true\"> inside the element\n      const textTargets = elem.matches('p[data-animate-on-board=\"true\"]') ? [elem] : elem.querySelectorAll('p[data-animate-on-board=\"true\"]');\n      textTargets.forEach(p => {\n        const effectType = p.dataset.animateEffect || 'user';\n        const rawText = p.textContent;\n        p.textContent = '';\n        if (effectType === 'ghost') {\n          this.triggerGhostTextEffect(p, rawText, () => delete p.dataset.animateOnBoard);\n        } else {\n          this.triggerUserTextEffect(p, rawText, () => delete p.dataset.animateOnBoard);\n        }\n      });\n    });\n  }\n}\n\n/**\n * BaseEffect\n *\n * A base class for visual effects.\n * Subclasses should implement the applyEffect method.\n */\nclass BaseEffect {\n  /**\n   * @param {Object} config - Configuration object for the effect.\n   */\n  constructor(config) {\n    this.config = config;\n  }\n\n  /**\n   * applyEffect\n   * Applies the effect to the target element.\n   * This method should be overridden in subclasses.\n   *\n   * @param {HTMLElement} target - The target element.\n   * @param {string} text - The text to animate.\n   * @param {Function} callback - Callback to call after effect is complete.\n   */\n  applyEffect(target, text, callback) {\n    throw new Error(\"applyEffect must be implemented by subclass\");\n  }\n}\n\n/**\n * TypewriterEffect\n *\n * An example subclass of BaseEffect that implements a typewriter effect.\n */\nclass TypewriterEffect extends BaseEffect {\n  /**\n   * Applies the typewriter effect to the target element.\n   *\n   * @param {HTMLElement} target - The target element.\n   * @param {string} text - The text to animate.\n   * @param {Function} callback - Callback to call after effect is complete.\n   */\n  applyEffect(target, text, callback) {\n    // Here we simply delegate to VisualEffectsManager's animateHTMLText using the configured speed.\n    // In a real implementation, additional logic could be added.\n    // For demonstration, we assume a global instance is available.\n    // Alternatively, this method could accept an instance of VisualEffectsManager.\n    target.innerHTML = \"\";\n    let pos = 0;\n    let currentHTML = \"\";\n    const intervalId = setInterval(() => {\n      if (pos >= text.length) {\n        clearInterval(intervalId);\n        if (callback) callback();\n        return;\n      }\n      currentHTML += text[pos];\n      target.innerHTML = currentHTML;\n      pos++;\n    }, this.config.speed);\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/managers/VisualEffectsManager.js?");

/***/ }),

/***/ "./src/utils/GameEntityLoader.js":
/*!***************************************!*\
  !*** ./src/utils/GameEntityLoader.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getQuestKeyToEventKeyMap: () => (/* binding */ getQuestKeyToEventKeyMap),\n/* harmony export */   loadGameEntitiesConfig: () => (/* binding */ loadGameEntitiesConfig)\n/* harmony export */ });\n/**\n * GameEntityLoader.js\n * \n * Provides functions to load the game entities configuration (events, quests, and sequence)\n * from a unified JSON file and derive mappings for use in managers.\n */\n\n/**\n * Loads the game entities configuration by fetching the JSON file.\n * Returns an object containing `events`, `quests`, and `sequence`.\n */\nasync function loadGameEntitiesConfig() {\n  const response = await fetch('./src/config/gameEntities.json');\n  if (!response.ok) {\n    throw new Error('Failed to load game entities configuration');\n  }\n  const config = await response.json();\n  return config;\n}\n\n/**\n * Constructs a mapping from questKey to its parent eventKey based on the sequence.\n * \n * Example return value:\n * {\n *   \"mirror_quest\": \"welcome\",\n *   \"repeating_quest\": \"post_repeating_event\",\n *   \"final_quest\": \"final_event\"\n * }\n * \n * Usage:\n *   const questKeyToEventKey = await getQuestKeyToEventKeyMap();\n */\nasync function getQuestKeyToEventKeyMap() {\n  const config = await loadGameEntitiesConfig();\n  const map = {};\n  config.sequence.forEach(triad => {\n    // triad: { eventKey, questKey, nextEventKey }\n    map[triad.questKey] = triad.eventKey;\n  });\n  return map;\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/utils/GameEntityLoader.js?");

/***/ }),

/***/ "./src/utils/ImageUtils.js":
/*!*********************************!*\
  !*** ./src/utils/ImageUtils.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageUtils: () => (/* binding */ ImageUtils)\n/* harmony export */ });\n// ImageUtils.js\nclass ImageUtils {\n  /**\n   * Converts the canvas image to grayscale and returns the data URL.\n   * @param {HTMLCanvasElement} canvas \n   * @returns {string} Data URL with PNG format.\n   */\n  static convertToGrayscale(canvas) {\n    const ctx = canvas.getContext(\"2d\");\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const pixels = imageData.data;\n    for (let i = 0; i < pixels.length; i += 4) {\n      const avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;\n      pixels[i] = avg;\n      pixels[i + 1] = avg;\n      pixels[i + 2] = avg;\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas.toDataURL(\"image/png\");\n  }\n\n  /**\n   * Performs pixel-wise comparison between two base64 images.\n   * @param {string} img1 Base64 string of the first image.\n   * @param {string} img2 Base64 string of the second image.\n   * @returns {number} Matching coefficient between 0 and 1.\n   */\n  static pixelWiseComparison(img1, img2) {\n    const decodeBase64 = img => atob(img.split(',')[1]);\n    const image1 = decodeBase64(img1);\n    const image2 = decodeBase64(img2);\n    let matchCount = 0;\n    const len = Math.min(image1.length, image2.length);\n    for (let i = 0; i < len; i++) {\n      if (Math.abs(image1.charCodeAt(i) - image2.charCodeAt(i)) < 100) {\n        matchCount++;\n      }\n    }\n    return matchCount / len;\n  }\n\n  /**\n   * Performs histogram comparison between two base64 images.\n   * @param {string} img1 Base64 string of the first image.\n   * @param {string} img2 Base64 string of the second image.\n   * @returns {number} Matching coefficient between 0 and 1.\n   */\n  static histogramComparison(img1, img2) {\n    const hist1 = this.createHistogram(img1);\n    const hist2 = this.createHistogram(img2);\n    const diff = hist1.reduce((acc, val, i) => acc + Math.abs(val - hist2[i]), 0);\n    const totalPixels = hist1.reduce((sum, val) => sum + val, 0);\n    return 1 - diff / (totalPixels * 1.2);\n  }\n\n  /**\n   * Creates a histogram (256 levels) for a base64 image.\n   * @param {string} img Base64 string of the image.\n   * @returns {number[]} Array of length 256 with pixel counts.\n   */\n  static createHistogram(img) {\n    const hist = new Array(256).fill(0);\n    const imgData = atob(img.split(',')[1]);\n    for (let i = 0; i < imgData.length; i++) {\n      hist[imgData.charCodeAt(i)]++;\n    }\n    return hist;\n  }\n\n  /**\n   * applyFilterToCanvas\n   * Applies a filter effect to a canvas and returns a new data URL.\n   * For example, for 'nightVision' the image brightness/contrast can be adjusted.\n   * @param {HTMLCanvasElement} canvas\n   * @param {string} filterType - 'nightVision', 'blackWhite', or ''.\n   * @returns {string} Data URL of the processed image.\n   */\n  static applyFilterToCanvas(canvas, filterType) {\n    const ctx = canvas.getContext(\"2d\");\n    // Save current state\n    ctx.save();\n    if (filterType === 'nightVision') {\n      // Example: increase brightness and add a green tint\n      ctx.filter = 'brightness(150%) contrast(120%) sepia(100%) hue-rotate(90deg)';\n    } else if (filterType === 'blackWhite') {\n      ctx.filter = 'grayscale(100%)';\n    } else {\n      ctx.filter = 'none';\n    }\n    // Redraw the current canvas content with the filter applied\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.putImageData(imageData, 0, 0);\n    // Restore state and return new data URL\n    ctx.restore();\n    return canvas.toDataURL(\"image/png\");\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/utils/ImageUtils.js?");

/***/ }),

/***/ "./src/utils/SequenceManager.js":
/*!**************************************!*\
  !*** ./src/utils/SequenceManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SequenceManager: () => (/* binding */ SequenceManager)\n/* harmony export */ });\n/**\n * SequenceManager.js\n * \n * Provides methods to manage the event–quest sequence.\n *\n * @typedef {Object} SequenceEntry\n * @property {string} eventKey - The event key.\n * @property {string} questKey - The quest key that will be started after the event.\n * @property {string|null} nextEventKey - The key of the next event (or null if the sequence is complete).\n */\n\nclass SequenceManager {\n  /**\n   * @param {SequenceEntry[]} sequenceList - The list of sequence entries.\n   */\n  constructor(sequenceList) {\n    this.sequenceList = sequenceList;\n    this.currentIndex = 0;\n  }\n\n  /**\n   * Returns the current sequence entry.\n   * @returns {SequenceEntry|null}\n   */\n  getCurrentEntry() {\n    return this.sequenceList && this.sequenceList[this.currentIndex] || null;\n  }\n\n  /**\n   * Checks if the provided quest key matches the expected quest in the current sequence entry.\n   * @param {string} questKey \n   * @returns {boolean}\n   */\n  isNextQuest(questKey) {\n    const entry = this.getCurrentEntry();\n    return entry ? entry.questKey === questKey : false;\n  }\n\n  /**\n   * Checks if the provided event key matches the expected event in the current sequence entry.\n   * @param {string} eventKey \n   * @returns {boolean}\n   */\n  isNextEvent(eventKey) {\n    const entry = this.getCurrentEntry();\n    return entry ? entry.eventKey === eventKey : false;\n  }\n\n  /**\n   * Increments the sequence index if not at the end.\n   */\n  increment() {\n    if (this.currentIndex < this.sequenceList.length - 1) {\n      this.currentIndex++;\n    }\n  }\n\n  /**\n   * Resets the sequence index to the beginning.\n   */\n  reset() {\n    this.currentIndex = 0;\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/utils/SequenceManager.js?");

/***/ }),

/***/ "./src/utils/SpiritBoardUtils.js":
/*!***************************************!*\
  !*** ./src/utils/SpiritBoardUtils.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animateText: () => (/* binding */ animateText)\n/* harmony export */ });\n/**\n * SpiritBoardUtils.js\n *\n * This module provides utility functions for visual effects on the spirit board.\n * It includes functions to animate text by sequentially revealing letters.\n */\n\n/**\n * animateText\n * Sequentially animates each letter of the given text within the provided HTML element.\n * It splits the text into individual letters, wraps each in a span, and applies a fade-in effect.\n *\n * @param {HTMLElement} element - The target element where the text animation will occur.\n * @param {string} text - The text to be animated.\n */\nfunction animateText(element, text) {\n  // Clear the current content of the element\n  element.innerHTML = '';\n\n  // Split the text into individual letters\n  const letters = text.split('');\n\n  // Create a span for each letter and animate its appearance\n  letters.forEach((letter, index) => {\n    const span = document.createElement('span');\n    span.innerText = letter;\n    // Set initial opacity to 0 for the animation effect\n    span.style.opacity = '0';\n    span.style.transition = 'opacity 0.3s ease-in';\n    element.appendChild(span);\n\n    // Reveal each letter sequentially with a delay (e.g., 100ms between letters)\n    setTimeout(() => {\n      span.style.opacity = '1';\n    }, index * 100);\n  });\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/utils/SpiritBoardUtils.js?");

/***/ }),

/***/ "./src/utils/TemplateEngine.js":
/*!*************************************!*\
  !*** ./src/utils/TemplateEngine.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TemplateEngine: () => (/* binding */ TemplateEngine)\n/* harmony export */ });\n/**\n * TemplateEngine.js\n *\n * A simple template engine for dynamic HTML rendering.\n * It replaces placeholders in the template string with values from a data object.\n *\n * Placeholders are defined using double curly braces, e.g., {{ variableName }}.\n *\n * Example usage:\n *   const template = \"<h1>{{ title }}</h1><p>{{ content }}</p>\";\n *   const data = { title: \"Hello\", content: \"World\" };\n *   const renderedHTML = TemplateEngine.render(template, data);\n *   // renderedHTML: \"<h1>Hello</h1><p>World</p>\"\n */\nclass TemplateEngine {\n  /**\n   * Renders an HTML template using the provided data.\n   *\n   * @param {string} template - The template string containing placeholders.\n   * @param {Object} data - The data object with keys corresponding to placeholder names.\n   * @returns {string} - The rendered HTML string with placeholders replaced by data values.\n   */\n  static render(template, data) {\n    return template.replace(/{{\\s*([\\s\\S]+?)\\s*}}/g, (match, key) => {\n      const trimmedKey = key.trim();\n      return data.hasOwnProperty(trimmedKey) ? data[trimmedKey] : match;\n    });\n  }\n\n  /**\n   * Loads an HTML template from `templatePath` with `fetch`, then renders it with the data.\n   * @param {string} templatePath – relative / absolute URL to the HTML file.\n   * @param {Object} [data={}] – placeholder values.\n   */\n  static async renderFile(templatePath, data = {}) {\n    const response = await fetch(templatePath);\n    if (!response.ok) {\n      throw new Error(`[TemplateEngine] Failed to load template: ${templatePath}`);\n    }\n    const templateText = await response.text();\n    return TemplateEngine.render(templateText, data);\n  }\n}\n\n//# sourceURL=webpack://testerer-deploy.github.io/./src/utils/TemplateEngine.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "testerer-deploy.github.io:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunktesterer_deploy_github_io"] = self["webpackChunktesterer_deploy_github_io"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./main.js");
/******/ 	
/******/ })()
;